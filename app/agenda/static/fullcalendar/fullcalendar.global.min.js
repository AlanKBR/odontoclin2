/*!
FullCalendar Premium Bundle v6.1.18
Docs: https://fullcalendar.io/docs/initialize-globals
(c) 2024 Adam Shaw
*/
var FullCalendar = (e => {
    var H, R, W, B, j, L, z = {},
        U = [],
        G = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;

    function F(e, t) {
        for (var r in t) e[r] = t[r];
        return e
    }

    function V(e) {
        var t = e.parentNode;
        t && t.removeChild(e)
    }

    function b(e, t, r) {
        var n, i, s, o = {};
        for (s in t) "key" == s ? n = t[s] : "ref" == s ? i = t[s] : o[s] = t[s];
        if (2 < arguments.length && (o.children = 3 < arguments.length ? H.call(arguments, 2) : r), "function" == typeof e && null != e.defaultProps)
            for (s in e.defaultProps) void 0 === o[s] && (o[s] = e.defaultProps[s]);
        return q(e, o, n, i, null)
    }

    function q(e, t, r, n, i) {
        e = {
            type: e,
            props: t,
            key: r,
            ref: n,
            __k: null,
            __: null,
            __b: 0,
            __e: null,
            __d: void 0,
            __c: null,
            __h: null,
            constructor: void 0,
            __v: null == i ? ++W : i
        };
        return null == i && null != R.vnode && R.vnode(e), e
    }

    function A(e) {
        return e.children
    }

    function Y(e, t, r) {
        "-" === t[0] ? e.setProperty(t, null == r ? "" : r) : e[t] = null == r ? "" : "number" != typeof r || G.test(t) ? r : r + "px"
    }

    function Q(e, t, r, n, i) {
        var s;
        e: if ("style" === t)
            if ("string" == typeof r) e.style.cssText = r;
            else {
                if ("string" == typeof n && (e.style.cssText = n = ""), n)
                    for (t in n) r && t in r || Y(e.style, t, "");
                if (r)
                    for (t in r) n && r[t] === n[t] || Y(e.style, t, r[t])
            }
        else if ("o" === t[0] && "n" === t[1]) s = t !== (t = t.replace(/Capture$/, "")), t = (t.toLowerCase() in e ? t.toLowerCase() : t).slice(2), e.l || (e.l = {}), (e.l[t + s] = r) ? n || e.addEventListener(t, s ? X : Z, s) : e.removeEventListener(t, s ? X : Z, s);
        else if ("dangerouslySetInnerHTML" !== t) {
            if (i) t = t.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
            else if ("width" !== t && "height" !== t && "href" !== t && "list" !== t && "form" !== t && "tabIndex" !== t && "download" !== t && t in e) try {
                e[t] = null == r ? "" : r;
                break e
            } catch (e) {}
            "function" != typeof r && (null == r || !1 === r && -1 == t.indexOf("-") ? e.removeAttribute(t) : e.setAttribute(t, r))
        }
    }

    function Z(e) {
        j = !0;
        try {
            return this.l[e.type + !1](R.event ? R.event(e) : e)
        } finally {
            j = !1
        }
    }

    function X(e) {
        j = !0;
        try {
            return this.l[e.type + !0](R.event ? R.event(e) : e)
        } finally {
            j = !1
        }
    }

    function x(e, t) {
        this.props = e, this.context = t
    }

    function J(e, t) {
        if (null == t) return e.__ ? J(e.__, e.__.__k.indexOf(e) + 1) : null;
        for (var r; t < e.__k.length; t++)
            if (null != (r = e.__k[t]) && null != r.__e) return r.__e;
        return "function" == typeof e.type ? J(e) : null
    }

    function K(e) {
        (j ? setTimeout : he)(e)
    }

    function $(e) {
        (e.__d || (e.__d = !0, !ue.push(e)) || ee.__r++) && L === R.debounceRendering || ((L = R.debounceRendering) || K)(ee)
    }

    function ee() {
        var e, t, r, n, i, s, o;
        for (ue.sort(function(e, t) {
                return e.__v.__b - t.__v.__b
            }); t = ue.shift();) t.__d && (e = ue.length, n = void 0, s = (i = (t = t).__v).__e, (o = t.__P) && (r = [], (n = F({}, i)).__v = i.__v + 1, ie(o, i, n, t.__n, void 0 !== o.ownerSVGElement, null != i.__h ? [s] : null, r, null == s ? J(i) : s, i.__h), se(r, i), i.__e != s) && function e(t) {
            var r, n;
            if (null != (t = t.__) && null != t.__c) {
                for (t.__e = t.__c.base = null, r = 0; r < t.__k.length; r++)
                    if (null != (n = t.__k[r]) && null != n.__e) {
                        t.__e = t.__c.base = n.__e;
                        break
                    } return e(t)
            }
        }(i), ue.length > e) && ue.sort(function(e, t) {
            return e.__v.__b - t.__v.__b
        });
        ee.__r = 0
    }

    function te(e, t, r, n, i, s, o, a, l, c) {
        var d, u, h, f, g, p, m, v = n && n.__k || U,
            y = v.length;
        for (r.__k = [], d = 0; d < t.length; d++)
            if (null != (f = r.__k[d] = null == (f = t[d]) || "boolean" == typeof f ? null : "string" == typeof f || "number" == typeof f || "bigint" == typeof f ? q(null, f, null, null, f) : Array.isArray(f) ? q(A, {
                    children: f
                }, null, null, null) : 0 < f.__b ? q(f.type, f.props, f.key, f.ref || null, f.__v) : f)) {
                if (f.__ = r, f.__b = r.__b + 1, null === (h = v[d]) || h && f.key == h.key && f.type === h.type) v[d] = void 0;
                else
                    for (u = 0; u < y; u++) {
                        if ((h = v[u]) && f.key == h.key && f.type === h.type) {
                            v[u] = void 0;
                            break
                        }
                        h = null
                    }
                ie(e, f, h = h || z, i, s, o, a, l, c), g = f.__e, (u = f.ref) && h.ref != u && (m = m || [], h.ref && m.push(h.ref, null, f), m.push(u, f.__c || g, f)), null != g ? (null == p && (p = g), "function" == typeof f.type && f.__k === h.__k ? f.__d = l = function e(t, r, n) {
                    for (var i, s = t.__k, o = 0; s && o < s.length; o++)(i = s[o]) && (i.__ = t, r = "function" == typeof i.type ? e(i, r, n) : ne(n, i, i, s, i.__e, r));
                    return r
                }(f, l, e) : l = ne(e, f, h, v, g, l), "function" == typeof r.type && (r.__d = l)) : l && h.__e == l && l.parentNode != e && (l = J(h))
            } for (r.__e = p, d = y; d--;) null != v[d] && ("function" == typeof r.type && null != v[d].__e && v[d].__e == r.__d && (r.__d = function e(t) {
            var r, n;
            if (null == t.type || "string" == typeof t.type) return t.__e;
            if (t.__k)
                for (r = t.__k.length - 1; 0 <= r; r--)
                    if ((n = t.__k[r]) && (n = e(n))) return n;
            return null
        }(n).nextSibling), function e(t, r, n) {
            var i, s;
            if (R.unmount && R.unmount(t), !(i = t.ref) || i.current && i.current !== t.__e || oe(i, null, r), null != (i = t.__c)) {
                if (i.componentWillUnmount) try {
                    i.componentWillUnmount()
                } catch (t) {
                    R.__e(t, r)
                }
                i.base = i.__P = null, t.__c = void 0
            }
            if (i = t.__k)
                for (s = 0; s < i.length; s++) i[s] && e(i[s], r, n || "function" != typeof t.type);
            n || null == t.__e || V(t.__e), t.__ = t.__e = t.__d = void 0
        }(v[d], v[d]));
        if (m)
            for (d = 0; d < m.length; d++) oe(m[d], m[++d], m[++d])
    }

    function re(e, t) {
        return t = t || [], null != e && "boolean" != typeof e && (Array.isArray(e) ? e.some(function(e) {
            re(e, t)
        }) : t.push(e)), t
    }

    function ne(e, t, r, n, i, s) {
        var o, a, l;
        if (void 0 !== t.__d) o = t.__d, t.__d = void 0;
        else if (null == r || i != s || null == i.parentNode) e: if (null == s || s.parentNode !== e) e.appendChild(i), o = null;
            else {
                for (a = s, l = 0;
                    (a = a.nextSibling) && l < n.length; l += 1)
                    if (a == i) break e;
                e.insertBefore(i, s), o = s
            } return void 0 !== o ? o : i.nextSibling
    }

    function ie(e, t, r, n, i, s, o, a, l) {
        var c, d, u, h, f, g, p, m, v, y, b, S, E, C, w, D = t.type;
        if (void 0 === t.constructor) {
            null != r.__h && (l = r.__h, a = t.__e = r.__e, t.__h = null, s = [a]), (c = R.__b) && c(t);
            try {
                e: if ("function" == typeof D) {
                    if (m = t.props, v = (c = D.contextType) && n[c.__c], y = c ? v ? v.props.value : c.__ : n, r.__c ? p = (d = t.__c = r.__c).__ = d.__E : ("prototype" in D && D.prototype.render ? t.__c = d = new D(m, y) : (t.__c = d = new x(m, y), d.constructor = D, d.render = ae), v && v.sub(d), d.props = m, d.state || (d.state = {}), d.context = y, d.__n = n, u = d.__d = !0, d.__h = [], d._sb = []), null == d.__s && (d.__s = d.state), null != D.getDerivedStateFromProps && (d.__s == d.state && (d.__s = F({}, d.__s)), F(d.__s, D.getDerivedStateFromProps(m, d.__s))), h = d.props, f = d.state, d.__v = t, u) null == D.getDerivedStateFromProps && null != d.componentWillMount && d.componentWillMount(), null != d.componentDidMount && d.__h.push(d.componentDidMount);
                    else {
                        if (null == D.getDerivedStateFromProps && m !== h && null != d.componentWillReceiveProps && d.componentWillReceiveProps(m, y), !d.__e && null != d.shouldComponentUpdate && !1 === d.shouldComponentUpdate(m, d.__s, y) || t.__v === r.__v) {
                            for (t.__v !== r.__v && (d.props = m, d.state = d.__s, d.__d = !1), t.__e = r.__e, t.__k = r.__k, t.__k.forEach(function(e) {
                                    e && (e.__ = t)
                                }), b = 0; b < d._sb.length; b++) d.__h.push(d._sb[b]);
                            d._sb = [], d.__h.length && o.push(d);
                            break e
                        }
                        null != d.componentWillUpdate && d.componentWillUpdate(m, d.__s, y), null != d.componentDidUpdate && d.__h.push(function() {
                            d.componentDidUpdate(h, f, g)
                        })
                    }
                    if (d.context = y, d.props = m, d.__P = e, S = R.__r, E = 0, "prototype" in D && D.prototype.render) {
                        for (d.state = d.__s, d.__d = !1, S && S(t), c = d.render(d.props, d.state, d.context), C = 0; C < d._sb.length; C++) d.__h.push(d._sb[C]);
                        d._sb = []
                    } else
                        for (; d.__d = !1, S && S(t), c = d.render(d.props, d.state, d.context), d.state = d.__s, d.__d && ++E < 25;);
                    d.state = d.__s, null != d.getChildContext && (n = F(F({}, n), d.getChildContext())), u || null == d.getSnapshotBeforeUpdate || (g = d.getSnapshotBeforeUpdate(h, f)), w = null != c && c.type === A && null == c.key ? c.props.children : c, te(e, Array.isArray(w) ? w : [w], t, r, n, i, s, o, a, l), d.base = t.__e, t.__h = null, d.__h.length && o.push(d), p && (d.__E = d.__ = null), d.__e = !1
                } else null == s && t.__v === r.__v ? (t.__k = r.__k, t.__e = r.__e) : t.__e = ((e, t, r, n, i, s, o, a) => {
                    var l, c, d, u = r.props,
                        h = t.props,
                        f = t.type,
                        g = 0;
                    if ("svg" === f && (i = !0), null != s)
                        for (; g < s.length; g++)
                            if ((l = s[g]) && "setAttribute" in l == !!f && (f ? l.localName === f : 3 === l.nodeType)) {
                                e = l, s[g] = null;
                                break
                            } if (null == e) {
                        if (null === f) return document.createTextNode(h);
                        e = i ? document.createElementNS("http://www.w3.org/2000/svg", f) : document.createElement(f, h.is && h), s = null, a = !1
                    }
                    if (null === f) u === h || a && e.data === h || (e.data = h);
                    else {
                        if (s = s && H.call(e.childNodes), c = (u = r.props || z).dangerouslySetInnerHTML, d = h.dangerouslySetInnerHTML, !a) {
                            if (null != s)
                                for (u = {}, g = 0; g < e.attributes.length; g++) u[e.attributes[g].name] = e.attributes[g].value;
                            !d && !c || d && (c && d.__html == c.__html || d.__html === e.innerHTML) || (e.innerHTML = d && d.__html || "")
                        }
                        if (((e, t, r, n, i) => {
                                for (var s in r) "children" === s || "key" === s || s in t || Q(e, s, null, r[s], n);
                                for (s in t) i && "function" != typeof t[s] || "children" === s || "key" === s || "value" === s || "checked" === s || r[s] === t[s] || Q(e, s, t[s], r[s], n)
                            })(e, h, u, i, a), d) t.__k = [];
                        else if (g = t.props.children, te(e, Array.isArray(g) ? g : [g], t, r, n, i && "foreignObject" !== f, s, o, s ? s[0] : r.__k && J(r, 0), a), null != s)
                            for (g = s.length; g--;) null != s[g] && V(s[g]);
                        a || ("value" in h && void 0 !== (g = h.value) && (g !== e.value || "progress" === f && !g || "option" === f && g !== u.value) && Q(e, "value", g, u.value, !1), "checked" in h && void 0 !== (g = h.checked) && g !== e.checked && Q(e, "checked", g, u.checked, !1))
                    }
                    return e
                })(r.__e, t, r, n, i, s, o, l);
                (c = R.diffed) && c(t)
            }
            catch (e) {
                t.__v = null, !l && null == s || (t.__e = a, t.__h = !!l, s[s.indexOf(a)] = null), R.__e(e, t, r)
            }
        }
    }

    function se(e, t) {
        R.__c && R.__c(t, e), e.some(function(t) {
            try {
                e = t.__h, t.__h = [], e.some(function(e) {
                    e.call(t)
                })
            } catch (e) {
                R.__e(e, t.__v)
            }
        })
    }

    function oe(e, t, r) {
        try {
            "function" == typeof e ? e(t) : e.current = t
        } catch (e) {
            R.__e(e, r)
        }
    }

    function ae(e, t, r) {
        return this.constructor(e, r)
    }

    function le(e, t, r) {
        var n, i, s;
        R.__ && R.__(e, t), i = (n = "function" == typeof r) ? null : r && r.__k || t.__k, s = [], ie(t, e = (!n && r || t).__k = b(A, null, [e]), i || z, z, void 0 !== t.ownerSVGElement, !n && r ? [r] : !i && t.firstChild ? H.call(t.childNodes) : null, s, !n && r ? r : i ? i.__e : t.firstChild, n), se(s, e)
    }
    H = U.slice, R = {
        __e: function(e, t, r, n) {
            for (var i, s, o; t = t.__;)
                if ((i = t.__c) && !i.__) try {
                    if ((s = i.constructor) && null != s.getDerivedStateFromError && (i.setState(s.getDerivedStateFromError(e)), o = i.__d), null != i.componentDidCatch && (i.componentDidCatch(e, n || {}), o = i.__d), o) return i.__E = i
                } catch (t) {
                    e = t
                }
            throw e
        }
    }, W = 0, j = !(B = function(e) {
        return null != e && void 0 === e.constructor
    }), x.prototype.setState = function(e, t) {
        var r = null != this.__s && this.__s !== this.state ? this.__s : this.__s = F({}, this.state);
        (e = "function" == typeof e ? e(F({}, r), this.props) : e) && F(r, e), null != e && this.__v && (t && this._sb.push(t), $(this))
    }, x.prototype.forceUpdate = function(e) {
        this.__v && (this.__e = !0, e && this.__h.push(e), $(this))
    }, x.prototype.render = A;
    var n, ce, de, ue = [],
        he = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout,
        fe = ee.__r = 0,
        ge = [],
        pe = [],
        me = R.__b,
        ve = R.__r,
        ye = R.diffed,
        be = R.__c,
        Se = R.unmount;

    function Ee() {
        for (var t; t = ge.shift();)
            if (t.__P && t.__H) try {
                t.__H.__h.forEach(we), t.__H.__h.forEach(De), t.__H.__h = []
            } catch (e) {
                t.__H.__h = [], R.__e(e, t.__v)
            }
    }
    R.__b = function(e) {
        n = null, me && me(e)
    }, R.__r = function(e) {
        ve && ve(e);
        e = (n = e.__c).__H;
        e && (ce === n ? (e.__h = [], n.__h = [], e.__.forEach(function(e) {
            e.__N && (e.__ = e.__N), e.__V = pe, e.__N = e.i = void 0
        })) : (e.__h.forEach(we), e.__h.forEach(De), e.__h = [])), ce = n
    }, R.diffed = function(e) {
        ye && ye(e);
        e = e.__c;
        e && e.__H && (!e.__H.__h.length || 1 !== ge.push(e) && de === R.requestAnimationFrame || ((de = R.requestAnimationFrame) || function(e) {
            function t() {
                clearTimeout(n), Ce && cancelAnimationFrame(r), setTimeout(e)
            }
            var r, n = setTimeout(t, 100);
            Ce && (r = requestAnimationFrame(t))
        })(Ee), e.__H.__.forEach(function(e) {
            e.i && (e.__H = e.i), e.__V !== pe && (e.__ = e.__V), e.i = void 0, e.__V = pe
        })), ce = n = null
    }, R.__c = function(e, r) {
        r.some(function(t) {
            try {
                t.__h.forEach(we), t.__h = t.__h.filter(function(e) {
                    return !e.__ || De(e)
                })
            } catch (e) {
                r.some(function(e) {
                    e.__h && (e.__h = [])
                }), r = [], R.__e(e, t.__v)
            }
        }), be && be(e, r)
    }, R.unmount = function(e) {
        Se && Se(e);
        var t, e = e.__c;
        e && e.__H && (e.__H.__.forEach(function(e) {
            try {
                we(e)
            } catch (e) {
                t = e
            }
        }), e.__H = void 0, t) && R.__e(t, e.__v)
    };
    var Ce = "function" == typeof requestAnimationFrame;

    function we(e) {
        var t = n,
            r = e.__c;
        "function" == typeof r && (e.__c = void 0, r()), n = t
    }

    function De(e) {
        var t = n;
        e.__c = e.__(), n = t
    }(new x).isPureReactComponent = !0;
    var Re = R.__b,
        Ae = (R.__b = function(e) {
            e.type && e.type.__f && e.ref && (e.props.ref = e.ref, e.ref = null), Re && Re(e)
        }, R.__e),
        xe = (R.__e = function(e, t, r, n) {
            if (e.then)
                for (var i, s = t; s = s.__;)
                    if ((i = s.__c) && i.__c) return null == t.__e && (t.__e = r.__e, t.__k = r.__k), i.__c(e, t);
            Ae(e, t, r, n)
        }, R.unmount);

    function Te(e) {
        var t = e.__.__c;
        return t && t.__a && t.__a(e)
    }

    function Me(e, t, r) {
        if (++r[1] === r[0] && e.o.delete(t), e.props.revealOrder && ("t" !== e.props.revealOrder[0] || !e.o.size))
            for (r = e.u; r;) {
                for (; 3 < r.length;) r.pop()();
                if (r[1] < r[0]) break;
                e.u = r = r[2]
            }
    }

    function ke(e) {
        return this.getChildContext = function() {
            return e.context
        }, e.children
    }

    function _e(e) {
        var r = this,
            t = e.i;
        r.componentWillUnmount = function() {
            le(null, r.l), r.l = null, r.i = null
        }, r.i && r.i !== t && r.componentWillUnmount(), e.__v ? (r.l || (r.i = t, r.l = {
            nodeType: 1,
            parentNode: t,
            childNodes: [],
            appendChild: function(e) {
                this.childNodes.push(e), r.i.appendChild(e)
            },
            insertBefore: function(e, t) {
                this.childNodes.push(e), r.i.appendChild(e)
            },
            removeChild: function(e) {
                this.childNodes.splice(this.childNodes.indexOf(e) >>> 1, 1), r.i.removeChild(e)
            }
        }), le(b(ke, {
            context: r.context
        }, e.__v), r.l)) : r.l && r.componentWillUnmount()
    }
    R.unmount = function(e) {
        var t = e.__c;
        t && t.__R && t.__R(), t && !0 === e.__h && (e.type = null), xe && xe(e)
    }, (new x).__c = function(e, t) {
        function r() {
            o || (o = !0, n.__R = null, s ? s(a) : a())
        }
        var n = t.__c,
            i = this,
            s = (null == i.t && (i.t = []), i.t.push(n), Te(i.__v)),
            o = !1,
            a = (n.__R = r, function() {
                var e, t;
                if (!--i.__u)
                    for (i.state.__a && (e = i.state.__a, i.__v.__k[0] = function t(e, r, n) {
                            return e && (e.__v = null, e.__k = e.__k && e.__k.map(function(e) {
                                return t(e, r, n)
                            }), e.__c) && e.__c.__P === r && (e.__e && n.insertBefore(e.__e, e.__d), e.__c.__e = !0, e.__c.__P = n), e
                        }(e, e.__c.__P, e.__c.__O)), i.setState({
                            __a: i.__b = null
                        }); t = i.t.pop();) t.forceUpdate()
            }),
            t = !0 === t.__h;
        i.__u++ || t || i.setState({
            __a: i.__b = i.__v.__k[0]
        }), e.then(r, r)
    }, (new x).__a = function(r) {
        var n = this,
            i = Te(n.__v),
            s = n.o.get(r);
        return s[0]++,
            function(e) {
                function t() {
                    n.props.revealOrder ? (s.push(e), Me(n, r, s)) : e()
                }
                i ? i(t) : t()
            }
    };
    var Ie = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103,
        Oe = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
        Pe = "undefined" != typeof document,
        Ne = (x.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t) {
            Object.defineProperty(x.prototype, t, {
                configurable: !0,
                get: function() {
                    return this["UNSAFE_" + t]
                },
                set: function(e) {
                    Object.defineProperty(this, t, {
                        configurable: !0,
                        writable: !0,
                        value: e
                    })
                }
            })
        }), R.event);

    function He() {}

    function We() {
        return this.cancelBubble
    }

    function Be() {
        return this.defaultPrevented
    }
    R.event = function(e) {
        return (e = Ne ? Ne(e) : e).persist = He, e.isPropagationStopped = We, e.isDefaultPrevented = Be, e.nativeEvent = e
    };
    var je = {
            configurable: !0,
            get: function() {
                return this.class
            }
        },
        Le = R.vnode,
        ze = (R.vnode = function(e) {
            var t, r = e.type,
                n = e.props,
                i = n;
            if ("string" == typeof r) {
                var s, o = -1 === r.indexOf("-"),
                    i = {};
                for (s in n) {
                    var a = n[s];
                    Pe && "children" === s && "noscript" === r || "value" === s && "defaultValue" in n && null == a || ("defaultValue" === s && "value" in n && null == n.value ? s = "value" : "download" === s && !0 === a ? a = "" : /ondoubleclick/i.test(s) ? s = "ondblclick" : /^onchange(textarea|input)/i.test(s + r) && (t = n.type, !("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(t)) ? s = "oninput" : /^onfocus$/i.test(s) ? s = "onfocusin" : /^onblur$/i.test(s) ? s = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(s) ? s = s.toLowerCase() : o && Oe.test(s) ? s = s.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === a && (a = void 0), /^oninput$/i.test(s) && (s = s.toLowerCase(), i[s]) && (s = "oninputCapture"), i[s] = a)
                }
                "select" == r && i.multiple && Array.isArray(i.value) && (i.value = re(n.children).forEach(function(e) {
                    e.props.selected = -1 != i.value.indexOf(e.props.value)
                })), "select" == r && null != i.defaultValue && (i.value = re(n.children).forEach(function(e) {
                    e.props.selected = i.multiple ? -1 != i.defaultValue.indexOf(e.props.value) : i.defaultValue == e.props.value
                })), e.props = i, n.class != n.className && (je.enumerable = "className" in n, null != n.className && (i.class = n.className), Object.defineProperty(i, "className", je))
            }
            e.$$typeof = Ie, Le && Le(e)
        }, R.__r);
    R.__r = function(e) {
        ze && ze(e), e.__c
    };
    let Ue = [],
        Ge = new Map;

    function Fe(t) {
        Ue.push(t), Ge.forEach(e => {
            qe(e, t)
        })
    }

    function Ve(e) {
        let t = Ge.get(e);
        if (!t || !t.isConnected) {
            (t = e.querySelector("style[data-fullcalendar]")) || ((t = document.createElement("style")).setAttribute("data-fullcalendar", ""), (o = Ye = void 0 === Ye ? (o = document.querySelector('meta[name="csp-nonce"]')) && o.hasAttribute("content") ? o.getAttribute("content") : (o = document.querySelector("script[nonce]")) && o.nonce || "" : Ye) && (t.nonce = o), r = e === document ? document.head : e, n = e === document ? r.querySelector("script,link[rel=stylesheet],link[as=style],style") : r.firstChild, r.insertBefore(t, n)), Ge.set(e, t);
            var r, n, i, s = t;
            for (i of Ue) qe(s, i)
        }
        var o
    }

    function qe(e, t) {
        let r = e.sheet,
            n = r.cssRules.length;
        t.split("}").forEach((e, t) => {
            (e = e.trim()) && r.insertRule(e + "}", n + t)
        })
    }
    let Ye;
    "undefined" != typeof document && Ve(document), Fe(':root{--fc-small-font-size:.85em;--fc-page-bg-color:#fff;--fc-neutral-bg-color:hsla(0,0%,82%,.3);--fc-neutral-text-color:grey;--fc-border-color:#ddd;--fc-button-text-color:#fff;--fc-button-bg-color:#2c3e50;--fc-button-border-color:#2c3e50;--fc-button-hover-bg-color:#1e2b37;--fc-button-hover-border-color:#1a252f;--fc-button-active-bg-color:#1a252f;--fc-button-active-border-color:#151e27;--fc-event-bg-color:#3788d8;--fc-event-border-color:#3788d8;--fc-event-text-color:#fff;--fc-event-selected-overlay-color:rgba(0,0,0,.25);--fc-more-link-bg-color:#d0d0d0;--fc-more-link-text-color:inherit;--fc-event-resizer-thickness:8px;--fc-event-resizer-dot-total-width:8px;--fc-event-resizer-dot-border-width:1px;--fc-non-business-color:hsla(0,0%,84%,.3);--fc-bg-event-color:#8fdf82;--fc-bg-event-opacity:0.3;--fc-highlight-color:rgba(188,232,241,.3);--fc-today-bg-color:rgba(255,220,40,.15);--fc-now-indicator-color:red}.fc-not-allowed,.fc-not-allowed .fc-event{cursor:not-allowed}.fc{display:flex;flex-direction:column;font-size:1em}.fc,.fc *,.fc :after,.fc :before{box-sizing:border-box}.fc table{border-collapse:collapse;border-spacing:0;font-size:1em}.fc th{text-align:center}.fc td,.fc th{padding:0;vertical-align:top}.fc a[data-navlink]{cursor:pointer}.fc a[data-navlink]:hover{text-decoration:underline}.fc-direction-ltr{direction:ltr;text-align:left}.fc-direction-rtl{direction:rtl;text-align:right}.fc-theme-standard td,.fc-theme-standard th{border:1px solid var(--fc-border-color)}.fc-liquid-hack td,.fc-liquid-hack th{position:relative}@font-face{font-family:fcicons;font-style:normal;font-weight:400;src:url("data:application/x-font-ttf;charset=utf-8;base64,AAEAAAALAIAAAwAwT1MvMg8SBfAAAAC8AAAAYGNtYXAXVtKNAAABHAAAAFRnYXNwAAAAEAAAAXAAAAAIZ2x5ZgYydxIAAAF4AAAFNGhlYWQUJ7cIAAAGrAAAADZoaGVhB20DzAAABuQAAAAkaG10eCIABhQAAAcIAAAALGxvY2ED4AU6AAAHNAAAABhtYXhwAA8AjAAAB0wAAAAgbmFtZXsr690AAAdsAAABhnBvc3QAAwAAAAAI9AAAACAAAwPAAZAABQAAApkCzAAAAI8CmQLMAAAB6wAzAQkAAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAABAAADpBgPA/8AAQAPAAEAAAAABAAAAAAAAAAAAAAAgAAAAAAADAAAAAwAAABwAAQADAAAAHAADAAEAAAAcAAQAOAAAAAoACAACAAIAAQAg6Qb//f//AAAAAAAg6QD//f//AAH/4xcEAAMAAQAAAAAAAAAAAAAAAQAB//8ADwABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAAAAAAAAAAIAADc5AQAAAAABAWIAjQKeAskAEwAAJSc3NjQnJiIHAQYUFwEWMjc2NCcCnuLiDQ0MJAz/AA0NAQAMJAwNDcni4gwjDQwM/wANIwz/AA0NDCMNAAAAAQFiAI0CngLJABMAACUBNjQnASYiBwYUHwEHBhQXFjI3AZ4BAA0N/wAMJAwNDeLiDQ0MJAyNAQAMIw0BAAwMDSMM4uINIwwNDQAAAAIA4gC3Ax4CngATACcAACUnNzY0JyYiDwEGFB8BFjI3NjQnISc3NjQnJiIPAQYUHwEWMjc2NCcB87e3DQ0MIw3VDQ3VDSMMDQ0BK7e3DQ0MJAzVDQ3VDCQMDQ3zuLcMJAwNDdUNIwzWDAwNIwy4twwkDA0N1Q0jDNYMDA0jDAAAAgDiALcDHgKeABMAJwAAJTc2NC8BJiIHBhQfAQcGFBcWMjchNzY0LwEmIgcGFB8BBwYUFxYyNwJJ1Q0N1Q0jDA0Nt7cNDQwjDf7V1Q0N1QwkDA0Nt7cNDQwkDLfWDCMN1Q0NDCQMt7gMIw0MDNYMIw3VDQ0MJAy3uAwjDQwMAAADAFUAAAOrA1UAMwBoAHcAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMhMjY1NCYjISIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAAVYRGRkR/qoRGRkRA1UFBAUOCQkVDAsZDf2rDRkLDBUJCA4FBQUFBQUOCQgVDAsZDQJVDRkLDBUJCQ4FBAVVAgECBQMCBwQECAX9qwQJAwQHAwMFAQICAgIBBQMDBwQDCQQCVQUIBAQHAgMFAgEC/oAZEhEZGRESGQAAAAADAFUAAAOrA1UAMwBoAIkAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMzFRQWMzI2PQEzMjY1NCYrATU0JiMiBh0BIyIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAgBkSEhmAERkZEYAZEhIZgBEZGREDVQUEBQ4JCRUMCxkN/asNGQsMFQkIDgUFBQUFBQ4JCBUMCxkNAlUNGQsMFQkJDgUEBVUCAQIFAwIHBAQIBf2rBAkDBAcDAwUBAgICAgEFAwMHBAMJBAJVBQgEBAcCAwUCAQL+gIASGRkSgBkSERmAEhkZEoAZERIZAAABAOIAjQMeAskAIAAAExcHBhQXFjI/ARcWMjc2NC8BNzY0JyYiDwEnJiIHBhQX4uLiDQ0MJAzi4gwkDA0N4uINDQwkDOLiDCQMDQ0CjeLiDSMMDQ3h4Q0NDCMN4uIMIw0MDOLiDAwNIwwAAAABAAAAAQAAa5n0y18PPPUACwQAAAAAANivOVsAAAAA2K85WwAAAAADqwNVAAAACAACAAAAAAAAAAEAAAPA/8AAAAQAAAAAAAOrAAEAAAAAAAAAAAAAAAAAAAALBAAAAAAAAAAAAAAAAgAAAAQAAWIEAAFiBAAA4gQAAOIEAABVBAAAVQQAAOIAAAAAAAoAFAAeAEQAagCqAOoBngJkApoAAQAAAAsAigADAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA4ArgABAAAAAAABAAcAAAABAAAAAAACAAcAYAABAAAAAAADAAcANgABAAAAAAAEAAcAdQABAAAAAAAFAAsAFQABAAAAAAAGAAcASwABAAAAAAAKABoAigADAAEECQABAA4ABwADAAEECQACAA4AZwADAAEECQADAA4APQADAAEECQAEAA4AfAADAAEECQAFABYAIAADAAEECQAGAA4AUgADAAEECQAKADQApGZjaWNvbnMAZgBjAGkAYwBvAG4Ac1ZlcnNpb24gMS4wAFYAZQByAHMAaQBvAG4AIAAxAC4AMGZjaWNvbnMAZgBjAGkAYwBvAG4Ac2ZjaWNvbnMAZgBjAGkAYwBvAG4Ac1JlZ3VsYXIAUgBlAGcAdQBsAGEAcmZjaWNvbnMAZgBjAGkAYwBvAG4Ac0ZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=") format("truetype")}.fc-icon{speak:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;display:inline-block;font-family:fcicons!important;font-style:normal;font-variant:normal;font-weight:400;height:1em;line-height:1;text-align:center;text-transform:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:1em}.fc-icon-chevron-left:before{content:"\\e900"}.fc-icon-chevron-right:before{content:"\\e901"}.fc-icon-chevrons-left:before{content:"\\e902"}.fc-icon-chevrons-right:before{content:"\\e903"}.fc-icon-minus-square:before{content:"\\e904"}.fc-icon-plus-square:before{content:"\\e905"}.fc-icon-x:before{content:"\\e906"}.fc .fc-button{border-radius:0;font-family:inherit;font-size:inherit;line-height:inherit;margin:0;overflow:visible;text-transform:none}.fc .fc-button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}.fc .fc-button{-webkit-appearance:button}.fc .fc-button:not(:disabled){cursor:pointer}.fc .fc-button{background-color:transparent;border:1px solid transparent;border-radius:.25em;display:inline-block;font-size:1em;font-weight:400;line-height:1.5;padding:.4em .65em;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle}.fc .fc-button:hover{text-decoration:none}.fc .fc-button:focus{box-shadow:0 0 0 .2rem rgba(44,62,80,.25);outline:0}.fc .fc-button:disabled{opacity:.65}.fc .fc-button-primary{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:hover{background-color:var(--fc-button-hover-bg-color);border-color:var(--fc-button-hover-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:disabled{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button-primary:not(:disabled).fc-button-active,.fc .fc-button-primary:not(:disabled):active{background-color:var(--fc-button-active-bg-color);border-color:var(--fc-button-active-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:not(:disabled).fc-button-active:focus,.fc .fc-button-primary:not(:disabled):active:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button .fc-icon{font-size:1.5em;vertical-align:middle}.fc .fc-button-group{display:inline-flex;position:relative;vertical-align:middle}.fc .fc-button-group>.fc-button{flex:1 1 auto;position:relative}.fc .fc-button-group>.fc-button.fc-button-active,.fc .fc-button-group>.fc-button:active,.fc .fc-button-group>.fc-button:focus,.fc .fc-button-group>.fc-button:hover{z-index:1}.fc-direction-ltr .fc-button-group>.fc-button:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0;margin-left:-1px}.fc-direction-ltr .fc-button-group>.fc-button:not(:last-child){border-bottom-right-radius:0;border-top-right-radius:0}.fc-direction-rtl .fc-button-group>.fc-button:not(:first-child){border-bottom-right-radius:0;border-top-right-radius:0;margin-right:-1px}.fc-direction-rtl .fc-button-group>.fc-button:not(:last-child){border-bottom-left-radius:0;border-top-left-radius:0}.fc .fc-toolbar{align-items:center;display:flex;justify-content:space-between}.fc .fc-toolbar.fc-header-toolbar{margin-bottom:1.5em}.fc .fc-toolbar.fc-footer-toolbar{margin-top:1.5em}.fc .fc-toolbar-title{font-size:1.75em;margin:0}.fc-direction-ltr .fc-toolbar>*>:not(:first-child){margin-left:.75em}.fc-direction-rtl .fc-toolbar>*>:not(:first-child){margin-right:.75em}.fc-direction-rtl .fc-toolbar-ltr{flex-direction:row-reverse}.fc .fc-scroller{-webkit-overflow-scrolling:touch;position:relative}.fc .fc-scroller-liquid{height:100%}.fc .fc-scroller-liquid-absolute{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-scroller-harness{direction:ltr;overflow:hidden;position:relative}.fc .fc-scroller-harness-liquid{height:100%}.fc-direction-rtl .fc-scroller-harness>.fc-scroller{direction:rtl}.fc-theme-standard .fc-scrollgrid{border:1px solid var(--fc-border-color)}.fc .fc-scrollgrid,.fc .fc-scrollgrid table{table-layout:fixed;width:100%}.fc .fc-scrollgrid table{border-left-style:hidden;border-right-style:hidden;border-top-style:hidden}.fc .fc-scrollgrid{border-bottom-width:0;border-collapse:separate;border-right-width:0}.fc .fc-scrollgrid-liquid{height:100%}.fc .fc-scrollgrid-section,.fc .fc-scrollgrid-section table,.fc .fc-scrollgrid-section>td{height:1px}.fc .fc-scrollgrid-section-liquid>td{height:100%}.fc .fc-scrollgrid-section>*{border-left-width:0;border-top-width:0}.fc .fc-scrollgrid-section-footer>*,.fc .fc-scrollgrid-section-header>*{border-bottom-width:0}.fc .fc-scrollgrid-section-body table,.fc .fc-scrollgrid-section-footer table{border-bottom-style:hidden}.fc .fc-scrollgrid-section-sticky>*{background:var(--fc-page-bg-color);position:sticky;z-index:3}.fc .fc-scrollgrid-section-header.fc-scrollgrid-section-sticky>*{top:0}.fc .fc-scrollgrid-section-footer.fc-scrollgrid-section-sticky>*{bottom:0}.fc .fc-scrollgrid-sticky-shim{height:1px;margin-bottom:-1px}.fc-sticky{position:sticky}.fc .fc-view-harness{flex-grow:1;position:relative}.fc .fc-view-harness-active>.fc-view{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-col-header-cell-cushion{display:inline-block;padding:2px 4px}.fc .fc-bg-event,.fc .fc-highlight,.fc .fc-non-business{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-non-business{background:var(--fc-non-business-color)}.fc .fc-bg-event{background:var(--fc-bg-event-color);opacity:var(--fc-bg-event-opacity)}.fc .fc-bg-event .fc-event-title{font-size:var(--fc-small-font-size);font-style:italic;margin:.5em}.fc .fc-highlight{background:var(--fc-highlight-color)}.fc .fc-cell-shaded,.fc .fc-day-disabled{background:var(--fc-neutral-bg-color)}a.fc-event,a.fc-event:hover{text-decoration:none}.fc-event.fc-event-draggable,.fc-event[href]{cursor:pointer}.fc-event .fc-event-main{position:relative;z-index:2}.fc-event-dragging:not(.fc-event-selected){opacity:.75}.fc-event-dragging.fc-event-selected{box-shadow:0 2px 7px rgba(0,0,0,.3)}.fc-event .fc-event-resizer{display:none;position:absolute;z-index:4}.fc-event-selected .fc-event-resizer,.fc-event:hover .fc-event-resizer{display:block}.fc-event-selected .fc-event-resizer{background:var(--fc-page-bg-color);border-color:inherit;border-radius:calc(var(--fc-event-resizer-dot-total-width)/2);border-style:solid;border-width:var(--fc-event-resizer-dot-border-width);height:var(--fc-event-resizer-dot-total-width);width:var(--fc-event-resizer-dot-total-width)}.fc-event-selected .fc-event-resizer:before{bottom:-20px;content:"";left:-20px;position:absolute;right:-20px;top:-20px}.fc-event-selected,.fc-event:focus{box-shadow:0 2px 5px rgba(0,0,0,.2)}.fc-event-selected:before,.fc-event:focus:before{bottom:0;content:"";left:0;position:absolute;right:0;top:0;z-index:3}.fc-event-selected:after,.fc-event:focus:after{background:var(--fc-event-selected-overlay-color);bottom:-1px;content:"";left:-1px;position:absolute;right:-1px;top:-1px;z-index:1}.fc-h-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-h-event .fc-event-main{color:var(--fc-event-text-color)}.fc-h-event .fc-event-main-frame{display:flex}.fc-h-event .fc-event-time{max-width:100%;overflow:hidden}.fc-h-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-width:0}.fc-h-event .fc-event-title{display:inline-block;left:0;max-width:100%;overflow:hidden;right:0;vertical-align:top}.fc-h-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-end){border-bottom-left-radius:0;border-left-width:0;border-top-left-radius:0}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-start){border-bottom-right-radius:0;border-right-width:0;border-top-right-radius:0}.fc-h-event:not(.fc-event-selected) .fc-event-resizer{bottom:0;top:0;width:var(--fc-event-resizer-thickness)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end{cursor:w-resize;left:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start{cursor:e-resize;right:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-h-event.fc-event-selected .fc-event-resizer{margin-top:calc(var(--fc-event-resizer-dot-total-width)*-.5);top:50%}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-start,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-end{left:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-end,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-start{right:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc .fc-popover{box-shadow:0 2px 6px rgba(0,0,0,.15);position:absolute;z-index:9999}.fc .fc-popover-header{align-items:center;display:flex;flex-direction:row;justify-content:space-between;padding:3px 4px}.fc .fc-popover-title{margin:0 2px}.fc .fc-popover-close{cursor:pointer;font-size:1.1em;opacity:.65}.fc-theme-standard .fc-popover{background:var(--fc-page-bg-color);border:1px solid var(--fc-border-color)}.fc-theme-standard .fc-popover-header{background:var(--fc-neutral-bg-color)}');
    class Qe {
        constructor(e) {
            this.drainedOption = e, this.isRunning = !1, this.isDirty = !1, this.pauseDepths = {}, this.timeoutId = 0
        }
        request(e) {
            this.isDirty = !0, this.isPaused() || (this.clearTimeout(), null == e ? this.tryDrain() : this.timeoutId = setTimeout(this.tryDrain.bind(this), e))
        }
        pause(e = "") {
            var t = this.pauseDepths;
            t[e] = (t[e] || 0) + 1, this.clearTimeout()
        }
        resume(e = "", t) {
            var r = this.pauseDepths;
            e in r && ((t || (--r[e], r[e] <= 0)) && delete r[e], this.tryDrain())
        }
        isPaused() {
            return Object.keys(this.pauseDepths).length
        }
        tryDrain() {
            if (!this.isRunning && !this.isPaused()) {
                for (this.isRunning = !0; this.isDirty;) this.isDirty = !1, this.drained();
                this.isRunning = !1
            }
        }
        clear() {
            this.clearTimeout(), this.isDirty = !1, this.pauseDepths = {}
        }
        clearTimeout() {
            this.timeoutId && (clearTimeout(this.timeoutId), this.timeoutId = 0)
        }
        drained() {
            this.drainedOption && this.drainedOption()
        }
    }

    function Ze(e) {
        e.parentNode && e.parentNode.removeChild(e)
    }

    function l(e, t) {
        if (e.closest) return e.closest(t);
        if (document.documentElement.contains(e))
            do {
                if (Xe(e, t)) return e
            } while (null !== (e = e.parentElement || e.parentNode) && 1 === e.nodeType);
        return null
    }

    function Xe(e, t) {
        return (e.matches || e.matchesSelector || e.msMatchesSelector).call(e, t)
    }

    function Je(e, t) {
        var r = e instanceof HTMLElement ? [e] : e,
            n = [];
        for (let e = 0; e < r.length; e += 1) {
            var i = r[e].querySelectorAll(t);
            for (let e = 0; e < i.length; e += 1) n.push(i[e])
        }
        return n
    }

    function Ke(e, t) {
        var r = e instanceof HTMLElement ? [e] : e,
            n = [];
        for (let e = 0; e < r.length; e += 1) {
            var i = r[e].children;
            for (let e = 0; e < i.length; e += 1) {
                var s = i[e];
                t && !Xe(s, t) || n.push(s)
            }
        }
        return n
    }
    let $e = /(top|left|right|bottom|width|height)$/i;

    function et(e, t) {
        for (var r in t) tt(e, r, t[r])
    }

    function tt(e, t, r) {
        null == r ? e.style[t] = "" : "number" == typeof r && $e.test(t) ? e.style[t] = r + "px" : e.style[t] = r
    }

    function rt(e) {
        var t;
        return null != (t = null == (t = e.composedPath) ? void 0 : t.call(e)[0]) ? t : e.target
    }
    let nt = 0;

    function t() {
        return "fc-dom-" + (nt += 1)
    }

    function it(e) {
        e.preventDefault()
    }

    function st(e, t, r, n) {
        s = r, o = n;
        let i = e => {
            var t = l(e.target, s);
            t && o.call(t, e, t)
        };
        var s, o;
        return e.addEventListener(t, i), () => {
            e.removeEventListener(t, i)
        }
    }
    let ot = ["webkitTransitionEnd", "otransitionend", "oTransitionEnd", "msTransitionEnd", "transitionend"];

    function at(t, r) {
        let n = e => {
            r(e), ot.forEach(e => {
                t.removeEventListener(e, n)
            })
        };
        ot.forEach(e => {
            t.addEventListener(e, n)
        })
    }

    function lt(e) {
        return Object.assign({
            onClick: e
        }, ct(e))
    }

    function ct(t) {
        return {
            tabIndex: 0,
            onKeyDown(e) {
                "Enter" !== e.key && " " !== e.key || (t(e), e.preventDefault())
            }
        }
    }
    let dt = 0;

    function c() {
        return dt += 1, String(dt)
    }

    function ut() {
        document.body.classList.add("fc-not-allowed")
    }

    function ht() {
        document.body.classList.remove("fc-not-allowed")
    }

    function ft(e) {
        e.style.userSelect = "none", e.style.webkitUserSelect = "none", e.addEventListener("selectstart", it)
    }

    function gt(e) {
        e.style.userSelect = "", e.style.webkitUserSelect = "", e.removeEventListener("selectstart", it)
    }

    function pt(e) {
        e.addEventListener("contextmenu", it)
    }

    function mt(e) {
        e.removeEventListener("contextmenu", it)
    }

    function vt(e) {
        let t, r, n = [],
            i = [];
        for ("string" == typeof e ? i = e.split(/\s*,\s*/) : "function" == typeof e ? i = [e] : Array.isArray(e) && (i = e), t = 0; t < i.length; t += 1) "string" == typeof(r = i[t]) ? n.push("-" === r.charAt(0) ? {
            field: r.substring(1),
            order: -1
        } : {
            field: r,
            order: 1
        }) : "function" == typeof r && n.push({
            func: r
        });
        return n
    }

    function yt(e, t, r) {
        let n, i;
        for (n = 0; n < r.length; n += 1)
            if (s = e, o = t, i = (a = r[n]).func ? a.func(s, o) : bt(s[a.field], o[a.field]) * (a.order || 1)) return i;
        var s, o, a;
        return 0
    }

    function bt(e, t) {
        return e || t ? null == t ? -1 : null == e ? 1 : "string" == typeof e || "string" == typeof t ? String(e).localeCompare(String(t)) : e - t : 0
    }

    function T(e, t) {
        e = String(e);
        return "000".substr(0, t - e.length) + e
    }

    function St(e, t, r) {
        return "function" == typeof e ? e(...t) : "string" == typeof e ? t.reduce((e, t, r) => e.replace("$" + r, t || ""), e) : r
    }

    function Et(e, t) {
        return e - t
    }

    function Ct(e) {
        return e % 1 == 0
    }
    let wt = ["years", "months", "days", "milliseconds"],
        Dt = /^(-?)(?:(\d+)\.)?(\d+):(\d\d)(?::(\d\d)(?:\.(\d\d\d))?)?/;

    function M(e, t) {
        return "string" == typeof e ? (r = e, (r = Dt.exec(r)) ? {
            years: 0,
            months: 0,
            days: (n = r[1] ? -1 : 1) * (r[2] ? parseInt(r[2], 10) : 0),
            milliseconds: n * (60 * (r[3] ? parseInt(r[3], 10) : 0) * 60 * 1e3 + 60 * (r[4] ? parseInt(r[4], 10) : 0) * 1e3 + 1e3 * (r[5] ? parseInt(r[5], 10) : 0) + (r[6] ? parseInt(r[6], 10) : 0))
        } : null) : "object" == typeof e && e ? Rt(e) : "number" == typeof e ? Rt({
            [t || "milliseconds"]: e
        }) : null;
        var r, n
    }

    function Rt(e) {
        var t = {
                years: e.years || e.year || 0,
                months: e.months || e.month || 0,
                days: e.days || e.day || 0,
                milliseconds: 60 * (e.hours || e.hour || 0) * 60 * 1e3 + 60 * (e.minutes || e.minute || 0) * 1e3 + 1e3 * (e.seconds || e.second || 0) + (e.milliseconds || e.millisecond || e.ms || 0)
            },
            e = e.weeks || e.week;
        return e && (t.days += 7 * e, t.specifiedWeeks = !0), t
    }

    function At(e) {
        return e.years || e.months || e.milliseconds ? 0 : e.days
    }

    function xt(e, t) {
        return {
            years: e.years + t.years,
            months: e.months + t.months,
            days: e.days + t.days,
            milliseconds: e.milliseconds + t.milliseconds
        }
    }

    function Tt(e, t) {
        return {
            years: e.years * t,
            months: e.months * t,
            days: e.days * t,
            milliseconds: e.milliseconds * t
        }
    }

    function Mt(e) {
        return k(e) / 864e5
    }

    function kt(e) {
        return k(e) / 6e4
    }

    function _t(e) {
        return k(e) / 1e3
    }

    function k(e) {
        return 31536e6 * e.years + 2592e6 * e.months + 864e5 * e.days + e.milliseconds
    }

    function It(t, r) {
        let n = null;
        for (let e = 0; e < wt.length; e += 1) {
            var i = wt[e];
            if (r[i]) {
                var s = t[i] / r[i];
                if (!Ct(s) || null !== n && n !== s) return null;
                n = s
            } else if (t[i]) return null
        }
        return n
    }

    function Ot(e) {
        var t = e.milliseconds;
        if (t) {
            if (t % 1e3 != 0) return {
                unit: "millisecond",
                value: t
            };
            if (t % 6e4 != 0) return {
                unit: "second",
                value: t / 1e3
            };
            if (t % 36e5 != 0) return {
                unit: "minute",
                value: t / 6e4
            };
            if (t) return {
                unit: "hour",
                value: t / 36e5
            }
        }
        return e.days ? e.specifiedWeeks && e.days % 7 == 0 ? {
            unit: "week",
            value: e.days / 7
        } : {
            unit: "day",
            value: e.days
        } : e.months ? {
            unit: "month",
            value: e.months
        } : e.years ? {
            unit: "year",
            value: e.years
        } : {
            unit: "millisecond",
            value: 0
        }
    }

    function Pt(e, t) {
        let r = 0,
            n = 0;
        for (; n < e.length;) e[n] === t ? (e.splice(n, 1), r += 1) : n += 1;
        return r
    }

    function d(r, n, i) {
        if (r !== n) {
            let e, t = r.length;
            if (t !== n.length) return !1;
            for (e = 0; e < t; e += 1)
                if (!(i ? i(r[e], n[e]) : r[e] === n[e])) return !1
        }
        return !0
    }
    let Nt = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];

    function Ht(e, t) {
        e = Vt(e);
        return e[2] += 7 * t, i(e)
    }

    function _(e, t) {
        e = Vt(e);
        return e[2] += t, i(e)
    }

    function p(e, t) {
        e = Vt(e);
        return e[6] += t, i(e)
    }

    function Wt(e, t) {
        return Bt(e, t) / 7
    }

    function Bt(e, t) {
        return (t.valueOf() - e.valueOf()) / 864e5
    }

    function jt(e, t) {
        var r = v(e),
            n = v(t);
        return {
            years: 0,
            months: 0,
            days: Math.round(Bt(r, n)),
            milliseconds: t.valueOf() - n.valueOf() - (e.valueOf() - r.valueOf())
        }
    }

    function Lt(e, t) {
        e = zt(e, t);
        return null !== e && e % 7 == 0 ? e / 7 : null
    }

    function zt(e, t) {
        return Yt(e) === Yt(t) ? Math.round(Bt(e, t)) : null
    }

    function v(e) {
        return i([e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate()])
    }

    function Ut(e, t, r, n) {
        t = i([t, 0, 1 + ((e, t, r) => -(7 + i([e, 0, r = 7 + t - r]).getUTCDay() - t) % 7 + r - 1)(t, r, n)]), r = v(e), n = Math.round(Bt(t, r));
        return Math.floor(n / 7) + 1
    }

    function Gt(e) {
        return [e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()]
    }

    function Ft(e) {
        return new Date(e[0], e[1] || 0, null == e[2] ? 1 : e[2], e[3] || 0, e[4] || 0, e[5] || 0)
    }

    function Vt(e) {
        return [e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds(), e.getUTCMilliseconds()]
    }

    function i(e) {
        return 1 === e.length && (e = e.concat([0])), new Date(Date.UTC(...e))
    }

    function qt(e) {
        return !isNaN(e.valueOf())
    }

    function Yt(e) {
        return 1e3 * e.getUTCHours() * 60 * 60 + 1e3 * e.getUTCMinutes() * 60 + 1e3 * e.getUTCSeconds() + e.getUTCMilliseconds()
    }

    function Qt(e, t, r = !1) {
        let n = e.toISOString();
        return n = n.replace(".000", ""), 10 < (n = r ? n.replace("T00:00:00Z", "") : n).length && (null == t ? n = n.replace("Z", "") : 0 !== t && (n = n.replace("Z", Kt(t, !0)))), n
    }

    function Zt(e) {
        return e.toISOString().replace(/T.*$/, "")
    }

    function Xt(e) {
        return e.toISOString().match(/^\d{4}-\d{2}/)[0]
    }

    function Jt(e) {
        return T(e.getUTCHours(), 2) + ":" + T(e.getUTCMinutes(), 2) + ":" + T(e.getUTCSeconds(), 2)
    }

    function Kt(e, t = !1) {
        var r = e < 0 ? "-" : "+",
            e = Math.abs(e),
            n = Math.floor(e / 60),
            e = Math.round(e % 60);
        return t ? r + T(n, 2) + ":" + T(e, 2) : "GMT" + r + n + (e ? ":" + T(e, 2) : "")
    }

    function f(r, n, i) {
        let s, o;
        return function(...e) {
            var t;
            return s ? d(s, e) || (i && i(o), t = r.apply(this, e), n && n(t, o)) || (o = t) : o = r.apply(this, e), s = e, o
        }
    }

    function $t(r, n, i) {
        let s, o;
        return e => {
            var t;
            return s ? h(s, e) || (i && i(o), t = r.call(this, e), n && n(t, o)) || (o = t) : o = r.call(this, e), s = e, o
        }
    }

    function er(s, o, a) {
        let l = [],
            c = [];
        return e => {
            let t = l.length,
                r = e.length,
                n = 0;
            for (; n < t; n += 1) {
                var i;
                e[n] ? d(l[n], e[n]) || (a && a(c[n]), i = s.apply(this, e[n]), o && o(i, c[n])) || (c[n] = i) : a && a(c[n])
            }
            for (; n < r; n += 1) c[n] = s.apply(this, e[n]);
            return l = e, c.splice(r), c
        }
    }

    function tr(i, s, o) {
        let a = {},
            l = {};
        return e => {
            var t, r, n = {};
            for (t in e) l[t] ? d(a[t], e[t]) ? n[t] = l[t] : (o && o(l[t]), r = i.apply(this, e[t]), n[t] = s && s(r, l[t]) ? l[t] : r) : n[t] = i.apply(this, e[t]);
            return a = e, l = n
        }
    }
    let rr = {
            week: 3,
            separator: 9,
            omitZeroMinute: 9,
            meridiem: 9,
            omitCommas: 9
        },
        nr = {
            timeZoneName: 7,
            era: 6,
            year: 5,
            month: 4,
            day: 2,
            weekday: 2,
            hour: 1,
            minute: 1,
            second: 1
        },
        ir = /\s*([ap])\.?m\.?/i,
        sr = /,/g,
        or = /\s+/g,
        ar = /\u200e/g,
        lr = /UTC|GMT/;
    class cr {
        constructor(e) {
            let t = {},
                r = {},
                n = 9;
            for (var i in e) i in rr ? (r[i] = e[i], rr[i] < 9 && (n = Math.min(rr[i], n))) : (t[i] = e[i], i in nr && (n = Math.min(nr[i], n)));
            this.standardDateProps = t, this.extendedSettings = r, this.smallestUnitNum = n, this.buildFormattingFunc = f(dr)
        }
        format(e, t) {
            return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, t)(e)
        }
        formatRange(e, t, r, n) {
            var {
                standardDateProps: i,
                extendedSettings: s
            } = this, o = (l = e.marker, c = t.marker, (o = r.calendarSystem).getMarkerYear(l) !== o.getMarkerYear(c) ? 5 : o.getMarkerMonth(l) !== o.getMarkerMonth(c) ? 4 : o.getMarkerDay(l) !== o.getMarkerDay(c) ? 2 : Yt(l) !== Yt(c) ? 1 : 0);
            if (!o) return this.format(e, r);
            let a = o;
            !(1 < a) || "numeric" !== i.year && "2-digit" !== i.year || "numeric" !== i.month && "2-digit" !== i.month || "numeric" !== i.day && "2-digit" !== i.day || (a = 1);
            var l = this.format(e, r),
                c = this.format(t, r);
            return l === c ? l : (o = ((r, n, i, s) => {
                let o = 0;
                for (; o < r.length;) {
                    var a = r.indexOf(n, o);
                    if (-1 === a) break;
                    var l = r.substr(0, a);
                    o = a + n.length;
                    let e = r.substr(o),
                        t = 0;
                    for (; t < i.length;) {
                        var c = i.indexOf(s, t);
                        if (-1 === c) break;
                        var d = i.substr(0, c),
                            c = (t = c + s.length, i.substr(t));
                        if (l === d && e === c) return {
                            before: l,
                            after: e
                        }
                    }
                }
                return null
            })(l, i = (o = dr(((e, t) => {
                var r, n = {};
                for (r in e) r in nr && !(nr[r] <= t) || (n[r] = e[r]);
                return n
            })(i, a), s, r))(e), c, e = o(t)), t = s.separator || n || r.defaultSeparator || "", o ? o.before + i + t + e + o.after : l + t + c)
        }
        getSmallestUnit() {
            switch (this.smallestUnitNum) {
                case 7:
                case 6:
                case 5:
                    return "year";
                case 4:
                    return "month";
                case 3:
                    return "week";
                case 2:
                    return "day";
                default:
                    return "time"
            }
        }
    }

    function dr(e, a, l) {
        var t = Object.keys(e).length;
        {
            if (1 === t && "short" === e.timeZoneName) return e => Kt(e.timeZoneOffset);
            if (0 === t && a.week) return e => {
                return e = l.computeWeekNumber(e.marker), t = l.weekText, r = l.locale, n = a.week, i = [], "long" === n ? i.push(l.weekTextLong) : "short" !== n && "narrow" !== n || i.push(t), "long" !== n && "short" !== n || i.push(" "), i.push(r.simpleNumberFormat.format(e)), "rtl" === r.options.direction && i.reverse(), i.join("");
                var t, r, n, i
            };
            {
                var c = e,
                    d = a,
                    u = l;
                c = Object.assign({}, c), d = Object.assign({}, d), t = d, (e = c).timeZoneName && (e.hour || (e.hour = "2-digit"), e.minute || (e.minute = "2-digit")), "long" === e.timeZoneName && (e.timeZoneName = "short"), t.omitZeroMinute && (e.second || e.millisecond) && delete t.omitZeroMinute, c.timeZone = "UTC";
                let s, o = new Intl.DateTimeFormat(u.locale.codes, c);
                return d.omitZeroMinute && (delete(e = Object.assign({}, c)).minute, s = new Intl.DateTimeFormat(u.locale.codes, e)), e => {
                    var t, r, n = e.marker,
                        i = s && !n.getUTCMinutes() ? s : o;
                    return i = i.format(n), n = e, e = c, t = d, r = u, i = i.replace(ar, ""), "short" === e.timeZoneName && (i = ((e, t) => {
                        let r = !1;
                        return e = e.replace(lr, () => (r = !0, t)), r || (e += " " + t), e
                    })(i, "UTC" === r.timeZone || null == n.timeZoneOffset ? "UTC" : Kt(n.timeZoneOffset))), t.omitCommas && (i = i.replace(sr, "").trim()), t.omitZeroMinute && (i = i.replace(":00", "")), !1 === t.meridiem ? i = i.replace(ir, "").trim() : "narrow" === t.meridiem ? i = i.replace(ir, (e, t) => t.toLocaleLowerCase()) : "short" === t.meridiem ? i = i.replace(ir, (e, t) => t.toLocaleLowerCase() + "m") : "lowercase" === t.meridiem && (i = i.replace(ir, e => e.toLocaleLowerCase())), (i = i.replace(or, " ")).trim()
                }
            }
        }
    }

    function ur(e, t) {
        t = t.markerToArray(e.marker);
        return {
            marker: e.marker,
            timeZoneOffset: e.timeZoneOffset,
            array: t,
            year: t[0],
            month: t[1],
            day: t[2],
            hour: t[3],
            minute: t[4],
            second: t[5],
            millisecond: t[6]
        }
    }

    function hr(e, t, r, n) {
        e = ur(e, r.calendarSystem);
        return {
            date: e,
            start: e,
            end: t ? ur(t, r.calendarSystem) : null,
            timeZone: r.timeZone,
            localeCodes: r.locale.codes,
            defaultSeparator: n || r.defaultSeparator
        }
    }
    class fr {
        constructor(e) {
            this.cmdStr = e
        }
        format(e, t, r) {
            return t.cmdFormatter(this.cmdStr, hr(e, null, t, r))
        }
        formatRange(e, t, r, n) {
            return r.cmdFormatter(this.cmdStr, hr(e, t, r, n))
        }
    }
    class gr {
        constructor(e) {
            this.func = e
        }
        format(e, t, r) {
            return this.func(hr(e, null, t, r))
        }
        formatRange(e, t, r, n) {
            return this.func(hr(e, t, r, n))
        }
    }

    function I(e) {
        return "object" == typeof e && e ? new cr(e) : "string" == typeof e ? new fr(e) : "function" == typeof e ? new gr(e) : null
    }
    let pr = {
            navLinkDayClick: r,
            navLinkWeekClick: r,
            duration: M,
            bootstrapFontAwesome: r,
            buttonIcons: r,
            customButtons: r,
            defaultAllDayEventDuration: M,
            defaultTimedEventDuration: M,
            nextDayThreshold: M,
            scrollTime: M,
            scrollTimeReset: Boolean,
            slotMinTime: M,
            slotMaxTime: M,
            dayPopoverFormat: I,
            slotDuration: M,
            snapDuration: M,
            headerToolbar: r,
            footerToolbar: r,
            defaultRangeSeparator: String,
            titleRangeSeparator: String,
            forceEventDuration: Boolean,
            dayHeaders: Boolean,
            dayHeaderFormat: I,
            dayHeaderClassNames: r,
            dayHeaderContent: r,
            dayHeaderDidMount: r,
            dayHeaderWillUnmount: r,
            dayCellClassNames: r,
            dayCellContent: r,
            dayCellDidMount: r,
            dayCellWillUnmount: r,
            initialView: String,
            aspectRatio: Number,
            weekends: Boolean,
            weekNumberCalculation: r,
            weekNumbers: Boolean,
            weekNumberClassNames: r,
            weekNumberContent: r,
            weekNumberDidMount: r,
            weekNumberWillUnmount: r,
            editable: Boolean,
            viewClassNames: r,
            viewDidMount: r,
            viewWillUnmount: r,
            nowIndicator: Boolean,
            nowIndicatorClassNames: r,
            nowIndicatorContent: r,
            nowIndicatorDidMount: r,
            nowIndicatorWillUnmount: r,
            showNonCurrentDates: Boolean,
            lazyFetching: Boolean,
            startParam: String,
            endParam: String,
            timeZoneParam: String,
            timeZone: String,
            locales: r,
            locale: r,
            themeSystem: String,
            dragRevertDuration: Number,
            dragScroll: Boolean,
            allDayMaintainDuration: Boolean,
            unselectAuto: Boolean,
            dropAccept: r,
            eventOrder: vt,
            eventOrderStrict: Boolean,
            handleWindowResize: Boolean,
            windowResizeDelay: Number,
            longPressDelay: Number,
            eventDragMinDistance: Number,
            expandRows: Boolean,
            height: r,
            contentHeight: r,
            direction: String,
            weekNumberFormat: I,
            eventResizableFromStart: Boolean,
            displayEventTime: Boolean,
            displayEventEnd: Boolean,
            weekText: String,
            weekTextLong: String,
            progressiveEventRendering: Boolean,
            businessHours: r,
            initialDate: r,
            now: r,
            eventDataTransform: r,
            stickyHeaderDates: r,
            stickyFooterScrollbar: r,
            viewHeight: r,
            defaultAllDay: Boolean,
            eventSourceFailure: r,
            eventSourceSuccess: r,
            eventDisplay: String,
            eventStartEditable: Boolean,
            eventDurationEditable: Boolean,
            eventOverlap: r,
            eventConstraint: r,
            eventAllow: r,
            eventBackgroundColor: String,
            eventBorderColor: String,
            eventTextColor: String,
            eventColor: String,
            eventClassNames: r,
            eventContent: r,
            eventDidMount: r,
            eventWillUnmount: r,
            selectConstraint: r,
            selectOverlap: r,
            selectAllow: r,
            droppable: Boolean,
            unselectCancel: String,
            slotLabelFormat: r,
            slotLaneClassNames: r,
            slotLaneContent: r,
            slotLaneDidMount: r,
            slotLaneWillUnmount: r,
            slotLabelClassNames: r,
            slotLabelContent: r,
            slotLabelDidMount: r,
            slotLabelWillUnmount: r,
            dayMaxEvents: r,
            dayMaxEventRows: r,
            dayMinWidth: Number,
            slotLabelInterval: M,
            allDayText: String,
            allDayClassNames: r,
            allDayContent: r,
            allDayDidMount: r,
            allDayWillUnmount: r,
            slotMinWidth: Number,
            navLinks: Boolean,
            eventTimeFormat: I,
            rerenderDelay: Number,
            moreLinkText: r,
            moreLinkHint: r,
            selectMinDistance: Number,
            selectable: Boolean,
            selectLongPressDelay: Number,
            eventLongPressDelay: Number,
            selectMirror: Boolean,
            eventMaxStack: Number,
            eventMinHeight: Number,
            eventMinWidth: Number,
            eventShortHeight: Number,
            slotEventOverlap: Boolean,
            plugins: r,
            firstDay: Number,
            dayCount: Number,
            dateAlignment: String,
            dateIncrement: M,
            hiddenDays: r,
            fixedWeekCount: Boolean,
            validRange: r,
            visibleRange: r,
            titleFormat: r,
            eventInteractive: Boolean,
            noEventsText: String,
            viewHint: r,
            navLinkHint: r,
            closeHint: String,
            timeHint: String,
            eventHint: String,
            moreLinkClick: r,
            moreLinkClassNames: r,
            moreLinkContent: r,
            moreLinkDidMount: r,
            moreLinkWillUnmount: r,
            monthStartFormat: I,
            handleCustomRendering: r,
            customRenderingMetaMap: r,
            customRenderingReplaces: Boolean
        },
        mr = {
            eventDisplay: "auto",
            defaultRangeSeparator: " - ",
            titleRangeSeparator: "  ",
            defaultTimedEventDuration: "01:00:00",
            defaultAllDayEventDuration: {
                day: 1
            },
            forceEventDuration: !1,
            nextDayThreshold: "00:00:00",
            dayHeaders: !0,
            initialView: "",
            aspectRatio: 1.35,
            headerToolbar: {
                start: "title",
                center: "",
                end: "today prev,next"
            },
            weekends: !0,
            weekNumbers: !1,
            weekNumberCalculation: "local",
            editable: !1,
            nowIndicator: !1,
            scrollTime: "06:00:00",
            scrollTimeReset: !0,
            slotMinTime: "00:00:00",
            slotMaxTime: "24:00:00",
            showNonCurrentDates: !0,
            lazyFetching: !0,
            startParam: "start",
            endParam: "end",
            timeZoneParam: "timeZone",
            timeZone: "local",
            locales: [],
            locale: "",
            themeSystem: "standard",
            dragRevertDuration: 500,
            dragScroll: !0,
            allDayMaintainDuration: !1,
            unselectAuto: !0,
            dropAccept: "*",
            eventOrder: "start,-duration,allDay,title",
            dayPopoverFormat: {
                month: "long",
                day: "numeric",
                year: "numeric"
            },
            handleWindowResize: !0,
            windowResizeDelay: 100,
            longPressDelay: 1e3,
            eventDragMinDistance: 5,
            expandRows: !1,
            navLinks: !1,
            selectable: !1,
            eventMinHeight: 15,
            eventMinWidth: 30,
            eventShortHeight: 30,
            monthStartFormat: {
                month: "long",
                day: "numeric"
            }
        },
        vr = {
            datesSet: r,
            eventsSet: r,
            eventAdd: r,
            eventChange: r,
            eventRemove: r,
            windowResize: r,
            eventClick: r,
            eventMouseEnter: r,
            eventMouseLeave: r,
            select: r,
            unselect: r,
            loading: r,
            _unmount: r,
            _beforeprint: r,
            _afterprint: r,
            _noEventDrop: r,
            _noEventResize: r,
            _resize: r,
            _scrollRequest: r
        },
        yr = {
            buttonText: r,
            buttonHints: r,
            views: r,
            plugins: r,
            initialEvents: r,
            events: r,
            eventSources: r
        },
        br = {
            headerToolbar: Sr,
            footerToolbar: Sr,
            buttonText: Sr,
            buttonHints: Sr,
            buttonIcons: Sr,
            dateIncrement: Sr,
            plugins: Er,
            events: Er,
            eventSources: Er,
            resources: Er
        };

    function Sr(e, t) {
        return "object" == typeof e && "object" == typeof t && e && t ? h(e, t) : e === t
    }

    function Er(e, t) {
        return Array.isArray(e) && Array.isArray(t) ? d(e, t) : e === t
    }
    let Cr = {
        type: String,
        component: r,
        buttonText: String,
        buttonTextKey: String,
        dateProfileGeneratorClass: r,
        usesMinMaxTime: Boolean,
        classNames: r,
        content: r,
        didMount: r,
        willUnmount: r
    };

    function wr(e) {
        return Ar(e, br)
    }

    function Dr(e, t) {
        var r, n, i = {},
            s = {};
        for (r in t) r in e && (i[r] = t[r](e[r]));
        for (n in e) n in t || (s[n] = e[n]);
        return {
            refined: i,
            extra: s
        }
    }

    function r(e) {
        return e
    }
    let Rr = Object.prototype.hasOwnProperty;

    function Ar(t, e) {
        var r = {};
        if (e)
            for (var n in e)
                if (e[n] === Sr) {
                    var i = [];
                    for (let e = t.length - 1; 0 <= e; --e) {
                        var s = t[e][n];
                        if ("object" == typeof s && s) i.unshift(s);
                        else if (void 0 !== s) {
                            r[n] = s;
                            break
                        }
                    }
                    i.length && (r[n] = Ar(i))
                } for (let e = t.length - 1; 0 <= e; --e) {
            var o, a = t[e];
            for (o in a) o in r || (r[o] = a[o])
        }
        return r
    }

    function xr(e, t) {
        var r, n = {};
        for (r in e) t(e[r], r) && (n[r] = e[r]);
        return n
    }

    function O(e, t) {
        var r, n = {};
        for (r in e) n[r] = t(e[r], r);
        return n
    }

    function Tr(e) {
        var t, r = {};
        for (t of e) r[t] = !0;
        return r
    }

    function Mr(e) {
        var t, r = [];
        for (t in e) r.push(e[t]);
        return r
    }

    function h(e, t) {
        if (e !== t) {
            for (var r in e)
                if (Rr.call(e, r) && !(r in t)) return !1;
            for (var n in t)
                if (Rr.call(t, n) && e[n] !== t[n]) return !1
        }
        return !0
    }
    let kr = /^on[A-Z]/;

    function _r(e, t, r = {}) {
        if (e !== t) {
            for (var n in t)
                if (!(n in e && (i = e[n], s = t[n], n = r[n], i === s || !0 === n || n && n(i, s)))) return !1;
            var i, s, o;
            for (o in e)
                if (!(o in t)) return !1
        }
        return !0
    }

    function Ir(t, r = 0, n, i = 1) {
        var s = [];
        null == n && (n = Object.keys(t).length);
        for (let e = r; e < n; e += i) {
            var o = t[e];
            void 0 !== o && s.push(o)
        }
        return s
    }
    let Or = {},
        Pr = (Or.gregory = class {
            getMarkerYear(e) {
                return e.getUTCFullYear()
            }
            getMarkerMonth(e) {
                return e.getUTCMonth()
            }
            getMarkerDay(e) {
                return e.getUTCDate()
            }
            arrayToMarker(e) {
                return i(e)
            }
            markerToArray(e) {
                return Vt(e)
            }
        }, /^\s*(\d{4})(-?(\d{2})(-?(\d{2})([T ](\d{2}):?(\d{2})(:?(\d{2})(\.(\d+))?)?(Z|(([-+])(\d{2})(:?(\d{2}))?))?)?)?)?$/);

    function Nr(t) {
        t = Pr.exec(t);
        if (t) {
            var r = new Date(Date.UTC(Number(t[1]), t[3] ? Number(t[3]) - 1 : 0, Number(t[5] || 1), Number(t[7] || 0), Number(t[8] || 0), Number(t[10] || 0), t[12] ? 1e3 * Number("0." + t[12]) : 0));
            if (qt(r)) {
                let e = null;
                return t[13] && (e = ("-" === t[15] ? -1 : 1) * (60 * Number(t[16] || 0) + Number(t[18] || 0))), {
                    marker: r,
                    isTimeUnspecified: !t[6],
                    timeZoneOffset: e
                }
            }
        }
        return null
    }
    class Hr {
        constructor(e) {
            var t = this.timeZone = e.timeZone,
                r = "local" !== t && "UTC" !== t;
            e.namedTimeZoneImpl && r && (this.namedTimeZoneImpl = new e.namedTimeZoneImpl(t)), this.canComputeOffset = Boolean(!r || this.namedTimeZoneImpl), this.calendarSystem = (t = e.calendarSystem, new Or[t]), this.locale = e.locale, this.weekDow = e.locale.week.dow, this.weekDoy = e.locale.week.doy, "ISO" === e.weekNumberCalculation && (this.weekDow = 1, this.weekDoy = 4), "number" == typeof e.firstDay && (this.weekDow = e.firstDay), "function" == typeof e.weekNumberCalculation && (this.weekNumberFunc = e.weekNumberCalculation), this.weekText = (null != e.weekText ? e : e.locale.options).weekText, this.weekTextLong = (null != e.weekTextLong ? e : e.locale.options).weekTextLong || this.weekText, this.cmdFormatter = e.cmdFormatter, this.defaultSeparator = e.defaultSeparator
        }
        createMarker(e) {
            e = this.createMarkerMeta(e);
            return null === e ? null : e.marker
        }
        createNowMarker() {
            return this.canComputeOffset ? this.timestampToMarker((new Date).valueOf()) : i(Gt(new Date))
        }
        createMarkerMeta(e) {
            if ("string" == typeof e) return this.parse(e);
            let t = null;
            return "number" == typeof e ? t = this.timestampToMarker(e) : e instanceof Date ? (e = e.valueOf(), isNaN(e) || (t = this.timestampToMarker(e))) : Array.isArray(e) && (t = i(e)), null !== t && qt(t) ? {
                marker: t,
                isTimeUnspecified: !1,
                forcedTzo: null
            } : null
        }
        parse(e) {
            e = Nr(e);
            if (null === e) return null;
            let t = e.marker,
                r = null;
            return null !== e.timeZoneOffset && (this.canComputeOffset ? t = this.timestampToMarker(t.valueOf() - 60 * e.timeZoneOffset * 1e3) : r = e.timeZoneOffset), {
                marker: t,
                isTimeUnspecified: e.isTimeUnspecified,
                forcedTzo: r
            }
        }
        getYear(e) {
            return this.calendarSystem.getMarkerYear(e)
        }
        getMonth(e) {
            return this.calendarSystem.getMarkerMonth(e)
        }
        getDay(e) {
            return this.calendarSystem.getMarkerDay(e)
        }
        add(e, t) {
            e = this.calendarSystem.markerToArray(e);
            return e[0] += t.years, e[1] += t.months, e[2] += t.days, e[6] += t.milliseconds, this.calendarSystem.arrayToMarker(e)
        }
        subtract(e, t) {
            e = this.calendarSystem.markerToArray(e);
            return e[0] -= t.years, e[1] -= t.months, e[2] -= t.days, e[6] -= t.milliseconds, this.calendarSystem.arrayToMarker(e)
        }
        addYears(e, t) {
            e = this.calendarSystem.markerToArray(e);
            return e[0] += t, this.calendarSystem.arrayToMarker(e)
        }
        addMonths(e, t) {
            e = this.calendarSystem.markerToArray(e);
            return e[1] += t, this.calendarSystem.arrayToMarker(e)
        }
        diffWholeYears(e, t) {
            var r = this.calendarSystem;
            return Yt(e) === Yt(t) && r.getMarkerDay(e) === r.getMarkerDay(t) && r.getMarkerMonth(e) === r.getMarkerMonth(t) ? r.getMarkerYear(t) - r.getMarkerYear(e) : null
        }
        diffWholeMonths(e, t) {
            var r = this.calendarSystem;
            return Yt(e) === Yt(t) && r.getMarkerDay(e) === r.getMarkerDay(t) ? r.getMarkerMonth(t) - r.getMarkerMonth(e) + 12 * (r.getMarkerYear(t) - r.getMarkerYear(e)) : null
        }
        greatestWholeUnit(e, t) {
            var r, n = this.diffWholeYears(e, t);
            return null !== n ? {
                unit: "year",
                value: n
            } : null !== (n = this.diffWholeMonths(e, t)) ? {
                unit: "month",
                value: n
            } : null !== (n = Lt(e, t)) ? {
                unit: "week",
                value: n
            } : null !== (n = zt(e, t)) ? {
                unit: "day",
                value: n
            } : (r = e, Ct(n = (t.valueOf() - r.valueOf()) / 36e5) ? {
                unit: "hour",
                value: n
            } : (r = e, Ct(n = (t.valueOf() - r.valueOf()) / 6e4) ? {
                unit: "minute",
                value: n
            } : (r = e, Ct(n = (t.valueOf() - r.valueOf()) / 1e3) ? {
                unit: "second",
                value: n
            } : {
                unit: "millisecond",
                value: t.valueOf() - e.valueOf()
            })))
        }
        countDurationsBetween(e, t, r) {
            let n;
            return r.years && null !== (n = this.diffWholeYears(e, t)) ? n / (Mt(r) / 365) : r.months && null !== (n = this.diffWholeMonths(e, t)) ? n / (Mt(r) / 30) : r.days && null !== (n = zt(e, t)) ? n / Mt(r) : (t.valueOf() - e.valueOf()) / k(r)
        }
        startOf(e, t) {
            return "year" === t ? this.startOfYear(e) : "month" === t ? this.startOfMonth(e) : "week" === t ? this.startOfWeek(e) : "day" === t ? v(e) : "hour" === t ? i([(r = e).getUTCFullYear(), r.getUTCMonth(), r.getUTCDate(), r.getUTCHours()]) : "minute" === t ? i([(r = e).getUTCFullYear(), r.getUTCMonth(), r.getUTCDate(), r.getUTCHours(), r.getUTCMinutes()]) : "second" === t ? i([(t = e).getUTCFullYear(), t.getUTCMonth(), t.getUTCDate(), t.getUTCHours(), t.getUTCMinutes(), t.getUTCSeconds()]) : null;
            var r
        }
        startOfYear(e) {
            return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(e)])
        }
        startOfMonth(e) {
            return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(e), this.calendarSystem.getMarkerMonth(e)])
        }
        startOfWeek(e) {
            return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(e), this.calendarSystem.getMarkerMonth(e), e.getUTCDate() - (e.getUTCDay() - this.weekDow + 7) % 7])
        }
        computeWeekNumber(e) {
            return this.weekNumberFunc ? this.weekNumberFunc(this.toDate(e)) : (e = e, t = this.weekDow, r = this.weekDoy, n = e.getUTCFullYear(), (i = Ut(e, n, t, r)) < 1 ? Ut(e, n - 1, t, r) : 1 <= (e = Ut(e, n + 1, t, r)) ? Math.min(i, e) : i);
            var t, r, n, i
        }
        format(e, t, r = {}) {
            return t.format({
                marker: e,
                timeZoneOffset: null != r.forcedTzo ? r.forcedTzo : this.offsetForMarker(e)
            }, this)
        }
        formatRange(e, t, r, n = {}) {
            return n.isEndExclusive && (t = p(t, -1)), r.formatRange({
                marker: e,
                timeZoneOffset: null != n.forcedStartTzo ? n.forcedStartTzo : this.offsetForMarker(e)
            }, {
                marker: t,
                timeZoneOffset: null != n.forcedEndTzo ? n.forcedEndTzo : this.offsetForMarker(t)
            }, this, n.defaultSeparator)
        }
        formatIso(e, t = {}) {
            let r = null;
            return Qt(e, r = t.omitTimeZoneOffset ? r : null != t.forcedTzo ? t.forcedTzo : this.offsetForMarker(e), t.omitTime)
        }
        timestampToMarker(e) {
            return "local" === this.timeZone ? i(Gt(new Date(e))) : "UTC" !== this.timeZone && this.namedTimeZoneImpl ? i(this.namedTimeZoneImpl.timestampToArray(e)) : new Date(e)
        }
        offsetForMarker(e) {
            return "local" === this.timeZone ? -Ft(Vt(e)).getTimezoneOffset() : "UTC" === this.timeZone ? 0 : this.namedTimeZoneImpl ? this.namedTimeZoneImpl.offsetForArray(Vt(e)) : null
        }
        toDate(e, t) {
            return "local" === this.timeZone ? Ft(Vt(e)) : "UTC" === this.timeZone ? new Date(e.valueOf()) : this.namedTimeZoneImpl ? new Date(e.valueOf() - 1e3 * this.namedTimeZoneImpl.offsetForArray(Vt(e)) * 60) : new Date(e.valueOf() - (t || 0))
        }
    }
    class Wr {
        constructor(e) {
            this.iconOverrideOption && this.setIconOverride(e[this.iconOverrideOption])
        }
        setIconOverride(e) {
            let t, r;
            if ("object" == typeof e && e) {
                for (r in t = Object.assign({}, this.iconClasses), e) t[r] = this.applyIconOverridePrefix(e[r]);
                this.iconClasses = t
            } else !1 === e && (this.iconClasses = {})
        }
        applyIconOverridePrefix(e) {
            var t = this.iconOverridePrefix;
            return e = t && 0 !== e.indexOf(t) ? t + e : e
        }
        getClass(e) {
            return this.classes[e] || ""
        }
        getIconClass(e, t) {
            t = t && this.rtlIconClasses && this.rtlIconClasses[e] || this.iconClasses[e];
            return t ? this.baseIconClass + " " + t : ""
        }
        getCustomButtonIconClass(e) {
            let t;
            return this.iconOverrideCustomButtonOption && (t = e[this.iconOverrideCustomButtonOption]) ? this.baseIconClass + " " + this.applyIconOverridePrefix(t) : ""
        }
    }

    function Br(e) {
        e();
        let t = R.debounceRendering,
            r = [];
        for (R.debounceRendering = function(e) {
                r.push(e)
            }, le(b(jr, {}), document.createElement("div")); r.length;) r.shift()();
        R.debounceRendering = t
    }
    Wr.prototype.classes = {}, Wr.prototype.iconClasses = {}, Wr.prototype.baseIconClass = "", Wr.prototype.iconOverridePrefix = "";
    class jr extends x {
        render() {
            return b("div", {})
        }
        componentDidMount() {
            this.setState({})
        }
    }

    function Lr(e) {
        let t = (e = {
                __c: n = "__cC" + fe++,
                __: e,
                Consumer: function(e, t) {
                    return e.children(t)
                },
                Provider: function(e) {
                    var r, t;
                    return this.getChildContext || (r = [], ((t = {})[n] = this).getChildContext = function() {
                        return t
                    }, this.shouldComponentUpdate = function(e) {
                        this.props.value !== e.value && r.some(function(e) {
                            e.__e = !0, $(e)
                        })
                    }, this.sub = function(e) {
                        r.push(e);
                        var t = e.componentWillUnmount;
                        e.componentWillUnmount = function() {
                            r.splice(r.indexOf(e), 1), t && t.call(e)
                        }
                    }), e.children
                }
            }).Provider.__ = e.Consumer.contextType = e,
            r = t.Provider;
        var n;
        return t.Provider = function() {
            var e = !this.getChildContext,
                t = r.apply(this, arguments);
            if (e) {
                let r = [];
                this.shouldComponentUpdate = t => {
                    this.props.value !== t.value && r.forEach(e => {
                        e.context = t.value, e.forceUpdate()
                    })
                }, this.sub = e => {
                    r.push(e);
                    let t = e.componentWillUnmount;
                    e.componentWillUnmount = () => {
                        r.splice(r.indexOf(e), 1), t && t.call(e)
                    }
                }
            }
            return t
        }, t
    }
    class zr {
        constructor(e, t, r, n) {
            this.execFunc = e, this.emitter = t, this.scrollTime = r, this.scrollTimeReset = n, this.handleScrollRequest = e => {
                this.queuedRequest = Object.assign({}, this.queuedRequest || {}, e), this.drain()
            }, t.on("_scrollRequest", this.handleScrollRequest), this.fireInitialScroll()
        }
        detach() {
            this.emitter.off("_scrollRequest", this.handleScrollRequest)
        }
        update(e) {
            e && this.scrollTimeReset ? this.fireInitialScroll() : this.drain()
        }
        fireInitialScroll() {
            this.handleScrollRequest({
                time: this.scrollTime
            })
        }
        drain() {
            this.queuedRequest && this.execFunc(this.queuedRequest) && (this.queuedRequest = null)
        }
    }
    let u = Lr({});

    function Ur(e, t, r, n, i, s, o, a, l, c, d, u, h, f) {
        return {
            dateEnv: i,
            nowManager: s,
            options: r,
            pluginHooks: a,
            emitter: d,
            dispatch: l,
            getCurrentData: c,
            calendarApi: u,
            viewSpec: e,
            viewApi: t,
            dateProfileGenerator: n,
            theme: o,
            isRtl: "rtl" === r.direction,
            addResizeHandler(e) {
                d.on("_resize", e)
            },
            removeResizeHandler(e) {
                d.off("_resize", e)
            },
            createScrollResponder: e => new zr(e, d, M(r.scrollTime), r.scrollTimeReset),
            registerInteractiveComponent: h,
            unregisterInteractiveComponent: f
        }
    }
    class Gr extends x {
        shouldComponentUpdate(e, t) {
            return !_r(this.props, e, this.propEquality) || !_r(this.state, t, this.stateEquality)
        }
        safeSetState(e) {
            _r(this.state, Object.assign(Object.assign({}, this.state), e), this.stateEquality) || this.setState(e)
        }
    }
    Gr.addPropsEquality = function(e) {
        var t = Object.create(this.prototype.propEquality);
        Object.assign(t, e), this.prototype.propEquality = t
    }, Gr.addStateEquality = function(e) {
        var t = Object.create(this.prototype.stateEquality);
        Object.assign(t, e), this.prototype.stateEquality = t
    }, Gr.contextType = u, Gr.prototype.propEquality = {}, Gr.prototype.stateEquality = {};
    class s extends Gr {}

    function o(e, t) {
        "function" == typeof e ? e(t) : e && (e.current = t)
    }
    s.contextType = u;
    class Fr extends s {
        constructor() {
            super(...arguments), this.id = c(), this.queuedDomNodes = [], this.currentDomNodes = [], this.handleEl = e => {
                var t = this.context.options,
                    r = this.props.generatorName;
                t.customRenderingReplaces && Vr(r, t) || this.updateElRef(e)
            }, this.updateElRef = e => {
                this.props.elRef && o(this.props.elRef, e)
            }
        }
        render() {
            let {
                props: e,
                context: t
            } = this, r = t.options, {
                customGenerator: n,
                defaultGenerator: i,
                renderProps: s
            } = e, o = qr(e, [], this.handleEl), a, l, c = !1, d = [];
            if (null != n) {
                let t = "function" == typeof n ? n(s, b) : n;
                if (!0 === t) c = !0;
                else {
                    let e = t && "object" == typeof t;
                    e && "html" in t ? o.dangerouslySetInnerHTML = {
                        __html: t.html
                    } : e && "domNodes" in t ? d = Array.prototype.slice.call(t.domNodes) : (e ? B(t) : "function" != typeof t) ? a = t : l = t
                }
            } else c = !Vr(e.generatorName, r);
            return c && i && (a = i(s)), this.queuedDomNodes = d, this.currentGeneratorMeta = l, b(e.elTag, o, a)
        }
        componentDidMount() {
            this.applyQueueudDomNodes(), this.triggerCustomRendering(!0)
        }
        componentDidUpdate() {
            this.applyQueueudDomNodes(), this.triggerCustomRendering(!0)
        }
        componentWillUnmount() {
            this.triggerCustomRendering(!1)
        }
        triggerCustomRendering(t) {
            let r, {
                    props: n,
                    context: e
                } = this,
                {
                    handleCustomRendering: i,
                    customRenderingMetaMap: s
                } = e.options;
            if (i) {
                let e = null != (r = this.currentGeneratorMeta) ? r : null == s ? void 0 : s[n.generatorName];
                e && i(Object.assign(Object.assign({
                    id: this.id,
                    isActive: t,
                    containerEl: this.base,
                    reportNewContainerEl: this.updateElRef,
                    generatorMeta: e
                }, n), {
                    elClasses: (n.elClasses || []).filter(Yr)
                }))
            }
        }
        applyQueueudDomNodes() {
            var {
                queuedDomNodes: e,
                currentDomNodes: t
            } = this, r = this.base;
            if (!d(e, t)) {
                t.forEach(Ze);
                for (var n of e) r.appendChild(n);
                this.currentDomNodes = e
            }
        }
    }

    function Vr(e, t) {
        return Boolean(t.handleCustomRendering && e && (null == (t = t.customRenderingMetaMap) ? void 0 : t[e]))
    }

    function qr(e, t, r) {
        r = Object.assign(Object.assign({}, e.elAttrs), {
            ref: r
        });
        return (e.elClasses || t) && (r.className = (e.elClasses || []).concat(t || []).concat(r.className || []).filter(Boolean).join(" ")), e.elStyle && (r.style = e.elStyle), r
    }

    function Yr(e) {
        return Boolean(e)
    }
    Fr.addPropsEquality({
        elClasses: d,
        elStyle: h,
        elAttrs: function(e, t) {
            var r;
            for (r of ((e, t) => {
                    var r, n, i = [];
                    for (r in e) !Rr.call(e, r) || r in t || i.push(r);
                    for (n in t) Rr.call(t, n) && e[n] !== t[n] && i.push(n);
                    return i
                })(e, t))
                if (!kr.test(r)) return !1;
            return !0
        },
        renderProps: h
    });
    let Qr = Lr(0);
    class g extends x {
        constructor() {
            super(...arguments), this.InnerContent = function(e, t) {
                var r = e.props;
                return b(Fr, Object.assign({
                    renderProps: r.renderProps,
                    generatorName: r.generatorName,
                    customGenerator: r.customGenerator,
                    defaultGenerator: r.defaultGenerator,
                    renderId: e.context
                }, t))
            }.bind(void 0, this), this.handleEl = e => {
                this.el = e, this.props.elRef && (o(this.props.elRef, e), e) && this.didMountMisfire && this.componentDidMount()
            }
        }
        render() {
            let t = this.props,
                e = (e => "string" == typeof(e = "function" == typeof e ? e(t.renderProps) : e || []) ? [e] : e)(t.classNameGenerator);
            var r, n;
            return t.children ? (r = qr(t, e, this.handleEl), n = t.children(this.InnerContent, t.renderProps, r), t.elTag ? b(t.elTag, r, n) : n) : b(Fr, Object.assign(Object.assign({}, t), {
                elRef: this.handleEl,
                elTag: t.elTag || "div",
                elClasses: (t.elClasses || []).concat(e),
                renderId: this.context
            }))
        }
        componentDidMount() {
            var e, t;
            this.el ? null != (t = (e = this.props).didMount) && t.call(e, Object.assign(Object.assign({}, this.props.renderProps), {
                el: this.el
            })) : this.didMountMisfire = !0
        }
        componentWillUnmount() {
            var e, t;
            null != (t = (e = this.props).willUnmount) && t.call(e, Object.assign(Object.assign({}, this.props.renderProps), {
                el: this.el
            }))
        }
    }
    g.contextType = Qr;
    class Zr extends s {
        render() {
            let {
                props: e,
                context: t
            } = this, r = t.options, n = {
                view: t.viewApi
            };
            return b(g, {
                elRef: e.elRef,
                elTag: e.elTag || "div",
                elAttrs: e.elAttrs,
                elClasses: [...Xr(e.viewSpec), ...e.elClasses || []],
                elStyle: e.elStyle,
                renderProps: n,
                classNameGenerator: r.viewClassNames,
                generatorName: void 0,
                didMount: r.viewDidMount,
                willUnmount: r.viewWillUnmount
            }, () => e.children)
        }
    }

    function Xr(e) {
        return [`fc-${e.type}-view`, "fc-view"]
    }

    function Jr(e, t) {
        let r, n, i = [],
            s = t.start;
        for (e.sort(Kr), r = 0; r < e.length; r += 1)(n = e[r]).start > s && i.push({
            start: s,
            end: n.start
        }), n.end > s && (s = n.end);
        return s < t.end && i.push({
            start: s,
            end: t.end
        }), i
    }

    function Kr(e, t) {
        return e.start.valueOf() - t.start.valueOf()
    }

    function D(e, t) {
        let {
            start: r,
            end: n
        } = e, i = null;
        return null !== t.start && (r = null === r ? t.start : new Date(Math.max(r.valueOf(), t.start.valueOf()))), null != t.end && (n = null === n ? t.end : new Date(Math.min(n.valueOf(), t.end.valueOf()))), i = null === r || null === n || r < n ? {
            start: r,
            end: n
        } : i
    }

    function $r(e, t) {
        return (null === e.start ? null : e.start.valueOf()) === (null === t.start ? null : t.start.valueOf()) && (null === e.end ? null : e.end.valueOf()) === (null === t.end ? null : t.end.valueOf())
    }

    function en(e, t) {
        return (null === e.end || null === t.start || e.end > t.start) && (null === e.start || null === t.end || e.start < t.end)
    }

    function tn(e, t) {
        return (null === e.start || null !== t.start && t.start >= e.start) && (null === e.end || null !== t.end && t.end <= e.end)
    }

    function S(e, t) {
        return (null === e.start || t >= e.start) && (null === e.end || t < e.end)
    }

    function rn(e) {
        var t = Math.floor(Bt(e.start, e.end)) || 1,
            e = v(e.start);
        return {
            start: e,
            end: _(e, t)
        }
    }

    function nn(e, t = M(0)) {
        let r = null,
            n = null;
        var i;
        return e.end && (n = v(e.end), i = e.end.valueOf() - n.valueOf()) && i >= k(t) && (n = _(n, 1)), e.start && (r = v(e.start), n) && n <= r && (n = _(r, 1)), {
            start: r,
            end: n
        }
    }

    function sn(e) {
        e = nn(e);
        return 1 < Bt(e.start, e.end)
    }

    function on(e, t, r, n) {
        return "year" === n ? M(r.diffWholeYears(e, t), "year") : "month" === n ? M(r.diffWholeMonths(e, t), "month") : jt(e, t)
    }
    class an {
        constructor(e) {
            this.props = e, this.initHiddenDays()
        }
        buildPrev(e, t, r) {
            var n = this.props.dateEnv,
                n = n.subtract(n.startOf(t, e.currentRangeUnit), e.dateIncrement);
            return this.build(n, -1, r)
        }
        buildNext(e, t, r) {
            var n = this.props.dateEnv,
                n = n.add(n.startOf(t, e.currentRangeUnit), e.dateIncrement);
            return this.build(n, 1, r)
        }
        build(e, t, r = !0) {
            let n, i, s, o, a, l, c = this.props,
                d;
            return n = this.buildValidRange(), n = this.trimHiddenDays(n), r && (d = e, e = null != n.start && d < n.start ? n.start : null != n.end && d >= n.end ? new Date(n.end.valueOf() - 1) : d), i = this.buildCurrentRangeInfo(e, t), s = /^(year|month|week|day)$/.test(i.unit), o = this.buildRenderRange(this.trimHiddenDays(i.range), i.unit, s), o = this.trimHiddenDays(o), a = o, c.showNonCurrentDates || (a = D(a, i.range)), a = D(a = this.adjustActiveRange(a), n), l = en(i.range, n), {
                currentDate: e = S(o, e) ? e : o.start,
                validRange: n,
                currentRange: i.range,
                currentRangeUnit: i.unit,
                isRangeAllDay: s,
                activeRange: a,
                renderRange: o,
                slotMinTime: c.slotMinTime,
                slotMaxTime: c.slotMaxTime,
                isValid: l,
                dateIncrement: this.buildDateIncrement(i.duration)
            }
        }
        buildValidRange() {
            var e = this.props.validRangeInput,
                e = "function" == typeof e ? e.call(this.props.calendarApi, this.props.dateEnv.toDate(this.props.nowManager.getDateMarker())) : e;
            return this.refineRange(e) || {
                start: null,
                end: null
            }
        }
        buildCurrentRangeInfo(e, t) {
            let r, n = this.props,
                i = null,
                s = null,
                o = null;
            return n.duration ? (i = n.duration, s = n.durationUnit, o = this.buildRangeFromDuration(e, t, i, s)) : (r = this.props.dayCount) ? (s = "day", o = this.buildRangeFromDayCount(e, t, r)) : (o = this.buildCustomVisibleRange(e)) ? s = n.dateEnv.greatestWholeUnit(o.start, o.end).unit : (i = this.getFallbackDuration(), s = Ot(i).unit, o = this.buildRangeFromDuration(e, t, i, s)), {
                duration: i,
                unit: s,
                range: o
            }
        }
        getFallbackDuration() {
            return M({
                day: 1
            })
        }
        adjustActiveRange(e) {
            let {
                dateEnv: t,
                usesMinMaxTime: r,
                slotMinTime: n,
                slotMaxTime: i
            } = this.props, {
                start: s,
                end: o
            } = e;
            return r && (Mt(n) < 0 && (s = v(s), s = t.add(s, n)), 1 < Mt(i)) && (o = _(o = v(o), -1), o = t.add(o, i)), {
                start: s,
                end: o
            }
        }
        buildRangeFromDuration(e, t, r, n) {
            let i, s, o, {
                dateEnv: a,
                dateAlignment: l
            } = this.props;
            var c;

            function d() {
                i = a.startOf(e, l), s = a.add(i, r), o = {
                    start: i,
                    end: s
                }
            }
            return l || (c = this.props.dateIncrement, l = c && k(c) < k(r) ? Ot(c).unit : n), Mt(r) <= 1 && this.isHiddenDay(i) && (i = v(i = this.skipHiddenDays(i, t))), d(), this.trimHiddenDays(o) || (e = this.skipHiddenDays(e, t), d()), o
        }
        buildRangeFromDayCount(e, t, r) {
            let n, {
                    dateEnv: i,
                    dateAlignment: s
                } = this.props,
                o = 0,
                a = e;
            for (a = v(a = s ? i.startOf(a, s) : a), a = this.skipHiddenDays(a, t), n = a; n = _(n, 1), this.isHiddenDay(n) || (o += 1), o < r;);
            return {
                start: a,
                end: n
            }
        }
        buildCustomVisibleRange(e) {
            var t = this.props,
                r = t.visibleRangeInput,
                t = "function" == typeof r ? r.call(t.calendarApi, t.dateEnv.toDate(e)) : r,
                e = this.refineRange(t);
            return !e || null != e.start && null != e.end ? e : null
        }
        buildRenderRange(e, t, r) {
            return e
        }
        buildDateIncrement(e) {
            var t = this.props.dateIncrement;
            return t || ((t = this.props.dateAlignment) ? M(1, t) : e || M({
                days: 1
            }))
        }
        refineRange(t) {
            if (t) {
                let e = ((e, t) => {
                    let r = null,
                        n = null;
                    return e.start && (r = t.createMarker(e.start)), e.end && (n = t.createMarker(e.end)), !r && !n || r && n && n < r ? null : {
                        start: r,
                        end: n
                    }
                })(t, this.props.dateEnv);
                return e = e && nn(e)
            }
            return null
        }
        initHiddenDays() {
            let e, t = this.props.hiddenDays || [],
                r = [],
                n = 0;
            for (!1 === this.props.weekends && t.push(0, 6), e = 0; e < 7; e += 1)(r[e] = -1 !== t.indexOf(e)) || (n += 1);
            if (!n) throw new Error("invalid hiddenDays");
            this.isHiddenDayHash = r
        }
        trimHiddenDays(e) {
            let {
                start: t,
                end: r
            } = e;
            return t = t && this.skipHiddenDays(t), r = r && this.skipHiddenDays(r, -1, !0), null == t || null == r || t < r ? {
                start: t,
                end: r
            } : null
        }
        isHiddenDay(e) {
            return e instanceof Date && (e = e.getUTCDay()), this.isHiddenDayHash[e]
        }
        skipHiddenDays(e, t = 1, r = !1) {
            for (; this.isHiddenDayHash[(e.getUTCDay() + (r ? t : 0) + 7) % 7];) e = _(e, t);
            return e
        }
    }

    function ln(e, t, r, n) {
        return {
            instanceId: c(),
            defId: e,
            range: t,
            forcedStartTzo: null == r ? null : r,
            forcedEndTzo: null == n ? null : n
        }
    }

    function cn(e, t, r) {
        let {
            dateEnv: n,
            pluginHooks: i,
            options: s
        } = r, {
            defs: o,
            instances: a
        } = e;
        for (var l in a = xr(a, e => !o[e.defId].recurringDef), o) {
            var c, d = o[l];
            if (d.recurringDef) {
                let e = d.recurringDef.duration;
                for (c of ((e, t, r, n, i) => {
                        let s = i[e.recurringDef.typeId].expand(e.recurringDef.typeData, {
                            start: n.subtract(r.start, t),
                            end: r.end
                        }, n);
                        return s = e.allDay ? s.map(v) : s
                    })(d, e = e || (d.allDay ? s.defaultAllDayEventDuration : s.defaultTimedEventDuration), t, n, i.recurringTypes)) {
                    var u = ln(l, {
                        start: c,
                        end: n.add(c, e)
                    });
                    a[u.instanceId] = u
                }
            }
        }
        return {
            defs: o,
            instances: a
        }
    }
    let dn = {
            id: String,
            groupId: String,
            title: String,
            url: String,
            interactive: Boolean
        },
        un = {
            start: r,
            end: r,
            date: r,
            allDay: Boolean
        },
        hn = Object.assign(Object.assign(Object.assign({}, dn), un), {
            extendedProps: r
        });

    function fn(e, t, r, n, i = pn(r), s, o) {
        var a, {
                refined: e,
                extra: i
            } = gn(e, r, i),
            l = (() => {
                let e = null;
                return e = null == (e = t ? t.defaultAllDay : e) ? r.options.defaultAllDay : e
            })(),
            c = ((r, n, e, i) => {
                for (let t = 0; t < i.length; t += 1) {
                    var s = i[t].parse(r, e);
                    if (s) {
                        let e = r.allDay;
                        return {
                            allDay: e = null == e && null == (e = n) && null == (e = s.allDayGuess) ? !1 : e,
                            duration: s.duration,
                            typeData: s.typeData,
                            typeId: t
                        }
                    }
                }
                return null
            })(e, l, r.dateEnv, r.pluginHooks.recurringTypes);
        return c ? ((a = mn(e, i, t ? t.sourceId : "", c.allDay, Boolean(c.duration), r, s)).recurringDef = {
            typeId: c.typeId,
            typeData: c.typeData,
            duration: c.duration
        }, {
            def: a,
            instance: null
        }) : (c = ((e, t, r, n) => {
            let i, s, o = e.allDay,
                a = null,
                l = !1,
                c = null,
                d = null != e.start ? e.start : e.date;
            if (i = r.dateEnv.createMarkerMeta(d)) a = i.marker;
            else if (!n) return null;
            return null != e.end && (s = r.dateEnv.createMarkerMeta(e.end)), (o = null == o ? null != t ? t : (!i || i.isTimeUnspecified) && (!s || s.isTimeUnspecified) : o) && (a = a && v(a)), (c = s && (c = s.marker, o && (c = v(c)), a) && c <= a ? null : c) ? l = !0 : n || (l = r.options.forceEventDuration || !1, c = r.dateEnv.add(a, o ? r.options.defaultAllDayEventDuration : r.options.defaultTimedEventDuration)), {
                allDay: o,
                hasEnd: l,
                range: {
                    start: a,
                    end: c
                },
                forcedStartTzo: i ? i.forcedTzo : null,
                forcedEndTzo: s ? s.forcedTzo : null
            }
        })(e, l, r, n)) ? (l = ln((a = mn(e, i, t ? t.sourceId : "", c.allDay, c.hasEnd, r, s)).defId, c.range, c.forcedStartTzo, c.forcedEndTzo), o && a.publicId && o[a.publicId] && (l.instanceId = o[a.publicId]), {
            def: a,
            instance: l
        }) : null
    }

    function gn(e, t, r = pn(t)) {
        return Dr(e, r)
    }

    function pn(e) {
        return Object.assign(Object.assign(Object.assign({}, wn), hn), e.pluginHooks.eventRefiners)
    }

    function mn(e, t, r, n, i, s, o) {
        var a, l = {
            title: e.title || "",
            groupId: e.groupId || "",
            publicId: e.id || "",
            url: e.url || "",
            recurringDef: null,
            defId: (o && e.id ? o[e.id] : "") || c(),
            sourceId: r,
            allDay: n,
            hasEnd: i,
            interactive: e.interactive,
            ui: Rn(e, s),
            extendedProps: Object.assign(Object.assign({}, e.extendedProps || {}), t)
        };
        for (a of s.pluginHooks.eventDefMemberAdders) Object.assign(l, a(e));
        return Object.freeze(l.ui.classNames), Object.freeze(l.extendedProps), l
    }

    function vn(e, t, r, n, i, s) {
        var o, a = {
                defs: {},
                instances: {}
            },
            l = pn(r);
        for (o of e) {
            var c = fn(o, t, r, n, l, i, s);
            c && yn(c, a)
        }
        return a
    }

    function yn(e, t = {
        defs: {},
        instances: {}
    }) {
        return t.defs[e.def.defId] = e.def, e.instance && (t.instances[e.instance.instanceId] = e.instance), t
    }

    function bn(t, n) {
        n = t.instances[n];
        if (n) {
            let r = t.defs[n.defId],
                e = En(t, e => {
                    return t = r, Boolean(t.groupId && t.groupId === e.groupId);
                    var t
                });
            return e.defs[r.defId] = r, e.instances[n.instanceId] = n, e
        }
        return {
            defs: {},
            instances: {}
        }
    }

    function Sn(e, t) {
        return {
            defs: Object.assign(Object.assign({}, e.defs), t.defs),
            instances: Object.assign(Object.assign({}, e.instances), t.instances)
        }
    }

    function En(e, t) {
        let r = xr(e.defs, t),
            n = xr(e.instances, e => r[e.defId]);
        return {
            defs: r,
            instances: n
        }
    }

    function Cn(e) {
        return Array.isArray(e) ? e : "string" == typeof e ? e.split(/\s+/) : []
    }
    let wn = {
            display: String,
            editable: Boolean,
            startEditable: Boolean,
            durationEditable: Boolean,
            constraint: r,
            overlap: r,
            allow: r,
            className: Cn,
            classNames: Cn,
            color: String,
            backgroundColor: String,
            borderColor: String,
            textColor: String
        },
        Dn = {
            display: null,
            startEditable: null,
            durationEditable: null,
            constraints: [],
            overlap: null,
            allows: [],
            backgroundColor: "",
            borderColor: "",
            textColor: "",
            classNames: []
        };

    function Rn(e, t) {
        r = e.constraint, t = t;
        var r, t = Array.isArray(r) ? vn(r, null, t, !0) : "object" == typeof r && r ? vn([r], null, t, !0) : null != r ? String(r) : null;
        return {
            display: e.display || null,
            startEditable: null != e.startEditable ? e.startEditable : e.editable,
            durationEditable: null != e.durationEditable ? e.durationEditable : e.editable,
            constraints: null != t ? [t] : [],
            overlap: null != e.overlap ? e.overlap : null,
            allows: null != e.allow ? [e.allow] : [],
            backgroundColor: e.backgroundColor || e.color || "",
            borderColor: e.borderColor || e.color || "",
            textColor: e.textColor || "",
            classNames: (e.className || []).concat(e.classNames || [])
        }
    }

    function An(e) {
        return e.reduce(xn, Dn)
    }

    function xn(e, t) {
        return {
            display: (null != t.display ? t : e).display,
            startEditable: (null != t.startEditable ? t : e).startEditable,
            durationEditable: (null != t.durationEditable ? t : e).durationEditable,
            constraints: e.constraints.concat(t.constraints),
            overlap: ("boolean" == typeof t.overlap ? t : e).overlap,
            allows: e.allows.concat(t.allows),
            backgroundColor: t.backgroundColor || e.backgroundColor,
            borderColor: t.borderColor || e.borderColor,
            textColor: t.textColor || e.textColor,
            classNames: e.classNames.concat(t.classNames)
        }
    }
    let Tn = {
        id: String,
        defaultAllDay: Boolean,
        url: String,
        format: String,
        events: r,
        eventDataTransform: r,
        success: r,
        failure: r
    };

    function Mn(e, i, t = kn(i)) {
        let r;
        if ("string" == typeof e ? r = {
                url: e
            } : "function" == typeof e || Array.isArray(e) ? r = {
                events: e
            } : "object" == typeof e && e && (r = e), r) {
            var {
                refined: t,
                extra: n
            } = Dr(r, t), s = (t => {
                var r = i.pluginHooks.eventSourceDefs;
                for (let e = r.length - 1; 0 <= e; --e) {
                    var n = r[e].parseMeta(t);
                    if (n) return {
                        sourceDefId: e,
                        meta: n
                    }
                }
                return null
            })(t);
            if (s) return {
                _raw: e,
                isFetching: !1,
                latestFetchId: "",
                fetchRange: null,
                defaultAllDay: t.defaultAllDay,
                eventDataTransform: t.eventDataTransform,
                success: t.success,
                failure: t.failure,
                publicId: t.id || "",
                sourceId: c(),
                sourceDefId: s.sourceDefId,
                meta: s.meta,
                ui: Rn(t, i),
                extendedProps: n
            }
        }
        return null
    }

    function kn(e) {
        return Object.assign(Object.assign(Object.assign({}, wn), Tn), e.pluginHooks.eventSourceRefiners)
    }

    function _n(e, t, r, n, i) {
        switch (t.type) {
            case "RECEIVE_EVENTS":
                var s = e,
                    o = r[t.sourceId],
                    a = t.fetchRange,
                    l = i;
                if (o && t.fetchId === o.latestFetchId) {
                    let e = vn(In(t.rawEvents, o, l), o, l);
                    return a && (e = cn(e, a, l)), Sn(Nn(s, o.sourceId), e)
                }
                return s;
            case "RESET_RAW_EVENTS":
                var c = e,
                    a = r[t.sourceId],
                    l = t.rawEvents,
                    o = n.activeRange,
                    s = i,
                    {
                        defIdMap: d,
                        instanceIdMap: u
                    } = (() => {
                        let {
                            defs: n,
                            instances: i
                        } = c, r = {}, s = {};
                        for (var o in n) {
                            let e = n[o],
                                t = e.publicId;
                            t && (r[t] = o)
                        }
                        for (var a in i) {
                            let e = i[a],
                                t = n[e.defId],
                                r = t.publicId;
                            r && (s[r] = a)
                        }
                        return {
                            defIdMap: r,
                            instanceIdMap: s
                        }
                    })();
                return cn(vn(In(l, a, s), a, s, !1, d, u), o, s);
            case "ADD_EVENTS":
                return d = t.eventStore, u = n ? n.activeRange : null, Sn(e, d = u ? cn(d, u, i) : d);
            case "RESET_EVENTS":
                return t.eventStore;
            case "MERGE_EVENTS":
                return Sn(e, t.eventStore);
            case "PREV":
            case "NEXT":
            case "CHANGE_DATE":
            case "CHANGE_VIEW_TYPE":
                return n ? cn(e, n.activeRange, i) : e;
            case "REMOVE_EVENTS":
                var h, f, g = t.eventStore,
                    {
                        defs: p,
                        instances: m
                    } = e,
                    v = {},
                    y = {};
                for (h in p) g.defs[h] || (v[h] = p[h]);
                for (f in m) !g.instances[f] && v[m[f].defId] && (y[f] = m[f]);
                return {
                    defs: v, instances: y
                };
            case "REMOVE_EVENT_SOURCE":
                return Nn(e, t.sourceId);
            case "REMOVE_ALL_EVENT_SOURCES":
                return En(e, e => !e.sourceId);
            case "REMOVE_ALL_EVENTS":
                return {
                    defs: {}, instances: {}
                };
            default:
                return e
        }
    }

    function In(e, t, r) {
        r = r.options.eventDataTransform, t = t ? t.eventDataTransform : null;
        return t && (e = On(e, t)), e = r ? On(e, r) : e
    }

    function On(e, t) {
        let r;
        if (t) {
            r = [];
            for (var n of e) {
                var i = t(n);
                i ? r.push(i) : null == i && r.push(n)
            }
        } else r = e;
        return r
    }

    function Pn(e, t, r) {
        let n = e.defs,
            i = O(e.instances, e => n[e.defId].allDay ? e : Object.assign(Object.assign({}, e), {
                range: {
                    start: r.createMarker(t.toDate(e.range.start, e.forcedStartTzo)),
                    end: r.createMarker(t.toDate(e.range.end, e.forcedEndTzo))
                },
                forcedStartTzo: r.canComputeOffset ? null : e.forcedStartTzo,
                forcedEndTzo: r.canComputeOffset ? null : e.forcedEndTzo
            }));
        return {
            defs: n,
            instances: i
        }
    }

    function Nn(e, t) {
        return En(e, e => e.sourceId !== t)
    }
    class Hn {
        constructor() {
            this.handlers = {}, this.thisContext = null
        }
        setThisContext(e) {
            this.thisContext = e
        }
        setOptions(e) {
            this.options = e
        }
        on(e, t) {
            var r;
            r = this.handlers, t = t, (r[e] || (r[e] = [])).push(t)
        }
        off(e, t) {
            var r, n;
            r = this.handlers, e = e, (n = t) ? r[e] && (r[e] = r[e].filter(e => e !== n)) : delete r[e]
        }
        trigger(e, ...t) {
            var r, n = this.handlers[e] || [],
                e = this.options && this.options[e];
            for (r of [].concat(e || [], n)) r.apply(this.thisContext, t)
        }
        hasHandlers(e) {
            return Boolean(this.handlers[e] && this.handlers[e].length || this.options && this.options[e])
        }
    }
    let Wn = {
        startTime: "09:00",
        endTime: "17:00",
        daysOfWeek: [1, 2, 3, 4, 5],
        display: "inverse-background",
        classNames: "fc-non-business",
        groupId: "_businessHours"
    };

    function Bn(e, t) {
        return vn((e => {
            let t;
            return t = (t = !0 === e ? [{}] : Array.isArray(e) ? e.filter(e => e.daysOfWeek) : "object" == typeof e && e ? [e] : []).map(e => Object.assign(Object.assign({}, Wn), e))
        })(e), null, t)
    }

    function jn(e, t, r) {
        r.emitter.trigger("select", Object.assign(Object.assign({}, Ln(e, r)), {
            jsEvent: t ? t.origEvent : null,
            view: r.viewApi || r.calendarApi.view
        }))
    }

    function Ln(e, t) {
        var r, n, i = {};
        for (r of t.pluginHooks.dateSpanTransforms) Object.assign(i, r(e, t));
        return Object.assign(i, Object.assign(Object.assign({}, ai((n = e).range, t.dateEnv, n.allDay)), {
            allDay: n.allDay
        })), i
    }

    function zn(e, t, r) {
        let {
            dateEnv: n,
            options: i
        } = r, s = t;
        return s = e ? (s = v(s), n.add(s, i.defaultAllDayEventDuration)) : n.add(s, i.defaultTimedEventDuration)
    }

    function Un(e, t, r, n) {
        var i, s, o, a, l, c, d, u, h = Xn(e.defs, t),
            f = {
                defs: {},
                instances: {}
            };
        for (i in e.defs) {
            var g = e.defs[i];
            f.defs[i] = ((e, t, r, n) => {
                var i, s = r.standardProps || {},
                    o = (null == s.hasEnd && t.durationEditable && (r.startDelta || r.endDelta) && (s.hasEnd = !0), Object.assign(Object.assign(Object.assign({}, e), s), {
                        ui: Object.assign(Object.assign({}, e.ui), s.ui)
                    }));
                r.extendedProps && (o.extendedProps = Object.assign(Object.assign({}, o.extendedProps), r.extendedProps));
                for (i of n.pluginHooks.eventDefMutationAppliers) i(o, r, n);
                return !o.hasEnd && n.options.forceEventDuration && (o.hasEnd = !0), o
            })(g, h[i], r, n)
        }
        for (s in e.instances) {
            var p = e.instances[s],
                m = f.defs[p.defId];
            f.instances[s] = (m = m, o = h[(p = p).defId], a = r, u = d = c = void 0, c = (l = n).dateEnv, d = a.standardProps && !0 === a.standardProps.allDay, u = a.standardProps && !1 === a.standardProps.hasEnd, p = Object.assign({}, p), d && (p.range = rn(p.range)), a.datesDelta && o.startEditable && (p.range = {
                start: c.add(p.range.start, a.datesDelta),
                end: c.add(p.range.end, a.datesDelta)
            }), a.startDelta && o.durationEditable && (p.range = {
                start: c.add(p.range.start, a.startDelta),
                end: p.range.end
            }), a.endDelta && o.durationEditable && (p.range = {
                start: p.range.start,
                end: c.add(p.range.end, a.endDelta)
            }), u && (p.range = {
                start: p.range.start,
                end: zn(m.allDay, p.range.start, l)
            }), m.allDay && (p.range = {
                start: v(p.range.start),
                end: v(p.range.end)
            }), p.range.end < p.range.start && (p.range.end = zn(m.allDay, p.range.start, l)), p)
        }
        return f
    }
    class Gn {
        constructor(e, t) {
            this.context = e, this.internalEventSource = t
        }
        remove() {
            this.context.dispatch({
                type: "REMOVE_EVENT_SOURCE",
                sourceId: this.internalEventSource.sourceId
            })
        }
        refetch() {
            this.context.dispatch({
                type: "FETCH_EVENT_SOURCES",
                sourceIds: [this.internalEventSource.sourceId],
                isRefetch: !0
            })
        }
        get id() {
            return this.internalEventSource.publicId
        }
        get url() {
            return this.internalEventSource.meta.url
        }
        get format() {
            return this.internalEventSource.meta.format
        }
    }
    class P {
        constructor(e, t, r) {
            this._context = e, this._def = t, this._instance = r || null
        }
        setProp(e, t) {
            e in un ? console.warn("Could not set date-related prop 'name'. Use one of the date-related methods instead.") : "id" === e ? (t = dn[e](t), this.mutate({
                standardProps: {
                    publicId: t
                }
            })) : e in dn ? (t = dn[e](t), this.mutate({
                standardProps: {
                    [e]: t
                }
            })) : e in wn ? (wn[e](t), this.mutate({
                standardProps: {
                    ui: "color" === e ? {
                        backgroundColor: t,
                        borderColor: t
                    } : "editable" === e ? {
                        startEditable: t,
                        durationEditable: t
                    } : {
                        [e]: t
                    }
                }
            })) : console.warn(`Could not set prop '${e}'. Use setExtendedProp instead.`)
        }
        setExtendedProp(e, t) {
            this.mutate({
                extendedProps: {
                    [e]: t
                }
            })
        }
        setStart(e, t = {}) {
            var r = this._context.dateEnv,
                e = r.createMarker(e);
            e && this._instance && (e = on(this._instance.range.start, e, r, t.granularity), t.maintainDuration ? this.mutate({
                datesDelta: e
            }) : this.mutate({
                startDelta: e
            }))
        }
        setEnd(e, t = {}) {
            let r, n = this._context.dateEnv;
            (null == e || (r = n.createMarker(e))) && this._instance && (r ? (e = on(this._instance.range.end, r, n, t.granularity), this.mutate({
                endDelta: e
            })) : this.mutate({
                standardProps: {
                    hasEnd: !1
                }
            }))
        }
        setDates(t, r, n = {}) {
            let i, s = this._context.dateEnv,
                o = {
                    allDay: n.allDay
                },
                a = s.createMarker(t);
            if (a && (null == r || (i = s.createMarker(r))) && this._instance) {
                let e = this._instance.range;
                t = on((e = !0 === n.allDay ? rn(e) : e).start, a, s, n.granularity);
                i ? (r = on(e.end, i, s, n.granularity), t.years === r.years && t.months === r.months && t.days === r.days && t.milliseconds === r.milliseconds ? this.mutate({
                    datesDelta: t,
                    standardProps: o
                }) : this.mutate({
                    startDelta: t,
                    endDelta: r,
                    standardProps: o
                })) : (o.hasEnd = !1, this.mutate({
                    datesDelta: t,
                    standardProps: o
                }))
            }
        }
        moveStart(e) {
            e = M(e);
            e && this.mutate({
                startDelta: e
            })
        }
        moveEnd(e) {
            e = M(e);
            e && this.mutate({
                endDelta: e
            })
        }
        moveDates(e) {
            e = M(e);
            e && this.mutate({
                datesDelta: e
            })
        }
        setAllDay(e, t = {}) {
            let r = {
                    allDay: e
                },
                n = t.maintainDuration;
            null == n && (n = this._context.options.allDayMaintainDuration), this._def.allDay !== e && (r.hasEnd = n), this.mutate({
                standardProps: r
            })
        }
        formatRange(e) {
            var t = this._context.dateEnv,
                r = this._instance,
                e = I(e);
            return this._def.hasEnd ? t.formatRange(r.range.start, r.range.end, e, {
                forcedStartTzo: r.forcedStartTzo,
                forcedEndTzo: r.forcedEndTzo
            }) : t.format(r.range.start, e, {
                forcedTzo: r.forcedStartTzo
            })
        }
        mutate(i) {
            var s = this._instance;
            if (s) {
                let e = this._def,
                    t = this._context,
                    r = t.getCurrentData().eventStore,
                    n = bn(r, s.instanceId);
                n = Un(n, {
                    "": {
                        display: "",
                        startEditable: !0,
                        durationEditable: !0,
                        constraints: [],
                        overlap: null,
                        allows: [],
                        backgroundColor: "",
                        borderColor: "",
                        textColor: "",
                        classNames: []
                    }
                }, i, t);
                i = new P(t, e, s);
                this._def = n.defs[e.defId], this._instance = n.instances[s.instanceId], t.dispatch({
                    type: "MERGE_EVENTS",
                    eventStore: n
                }), t.emitter.trigger("eventChange", {
                    oldEvent: i,
                    event: this,
                    relatedEvents: Vn(n, t, s),
                    revert() {
                        t.dispatch({
                            type: "RESET_EVENTS",
                            eventStore: r
                        })
                    }
                })
            }
        }
        remove() {
            let e = this._context,
                t = Fn(this);
            e.dispatch({
                type: "REMOVE_EVENTS",
                eventStore: t
            }), e.emitter.trigger("eventRemove", {
                event: this,
                relatedEvents: [],
                revert() {
                    e.dispatch({
                        type: "MERGE_EVENTS",
                        eventStore: t
                    })
                }
            })
        }
        get source() {
            var e = this._def.sourceId;
            return e ? new Gn(this._context, this._context.getCurrentData().eventSources[e]) : null
        }
        get start() {
            return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null
        }
        get end() {
            return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null
        }
        get startStr() {
            var e = this._instance;
            return e ? this._context.dateEnv.formatIso(e.range.start, {
                omitTime: this._def.allDay,
                forcedTzo: e.forcedStartTzo
            }) : ""
        }
        get endStr() {
            var e = this._instance;
            return e && this._def.hasEnd ? this._context.dateEnv.formatIso(e.range.end, {
                omitTime: this._def.allDay,
                forcedTzo: e.forcedEndTzo
            }) : ""
        }
        get id() {
            return this._def.publicId
        }
        get groupId() {
            return this._def.groupId
        }
        get allDay() {
            return this._def.allDay
        }
        get title() {
            return this._def.title
        }
        get url() {
            return this._def.url
        }
        get display() {
            return this._def.ui.display || "auto"
        }
        get startEditable() {
            return this._def.ui.startEditable
        }
        get durationEditable() {
            return this._def.ui.durationEditable
        }
        get constraint() {
            return this._def.ui.constraints[0] || null
        }
        get overlap() {
            return this._def.ui.overlap
        }
        get allow() {
            return this._def.ui.allows[0] || null
        }
        get backgroundColor() {
            return this._def.ui.backgroundColor
        }
        get borderColor() {
            return this._def.ui.borderColor
        }
        get textColor() {
            return this._def.ui.textColor
        }
        get classNames() {
            return this._def.ui.classNames
        }
        get extendedProps() {
            return this._def.extendedProps
        }
        toPlainObject(e = {}) {
            var t = this._def,
                r = t.ui,
                {
                    startStr: n,
                    endStr: i
                } = this,
                s = {
                    allDay: t.allDay
                };
            return t.title && (s.title = t.title), n && (s.start = n), i && (s.end = i), t.publicId && (s.id = t.publicId), t.groupId && (s.groupId = t.groupId), t.url && (s.url = t.url), r.display && "auto" !== r.display && (s.display = r.display), e.collapseColor && r.backgroundColor && r.backgroundColor === r.borderColor ? s.color = r.backgroundColor : (r.backgroundColor && (s.backgroundColor = r.backgroundColor), r.borderColor && (s.borderColor = r.borderColor)), r.textColor && (s.textColor = r.textColor), r.classNames.length && (s.classNames = r.classNames), Object.keys(t.extendedProps).length && (e.collapseExtendedProps ? Object.assign(s, t.extendedProps) : s.extendedProps = t.extendedProps), s
        }
        toJSON() {
            return this.toPlainObject()
        }
    }

    function Fn(e) {
        var t = e._def,
            e = e._instance;
        return {
            defs: {
                [t.defId]: t
            },
            instances: e ? {
                [e.instanceId]: e
            } : {}
        }
    }

    function Vn(e, t, r) {
        var n, {
                defs: i,
                instances: s
            } = e,
            o = [],
            a = r ? r.instanceId : "";
        for (n in s) {
            var l = s[n],
                c = i[l.defId];
            l.instanceId !== a && o.push(new P(t, c, l))
        }
        return o
    }

    function qn(e, t, r, n) {
        var i, s, o, a, l, c, d = {},
            u = {},
            h = {},
            f = [],
            g = [],
            p = Xn(e.defs, t);
        for (i in e.defs) {
            var m = e.defs[i];
            "inverse-background" === p[m.defId].display && (m.groupId ? (d[m.groupId] = [], h[m.groupId] || (h[m.groupId] = m)) : u[i] = [])
        }
        for (s in e.instances) {
            var v = e.instances[s],
                y = e.defs[v.defId],
                b = p[y.defId],
                S = v.range,
                S = !y.allDay && n ? nn(S, n) : S,
                E = D(S, r);
            E && ("inverse-background" === b.display ? (y.groupId ? d[y.groupId] : u[v.defId]).push(E) : "none" !== b.display && ("background" === b.display ? f : g).push({
                def: y,
                ui: b,
                instance: v,
                range: E,
                isStart: S.start && S.start.valueOf() === E.start.valueOf(),
                isEnd: S.end && S.end.valueOf() === E.end.valueOf()
            }))
        }
        for (o in d)
            for (a of Jr(d[o], r)) {
                var C = h[o],
                    w = p[C.defId];
                f.push({
                    def: C,
                    ui: w,
                    instance: null,
                    range: a,
                    isStart: !1,
                    isEnd: !1
                })
            }
        for (l in u)
            for (c of Jr(u[l], r)) f.push({
                def: e.defs[l],
                ui: p[l],
                instance: null,
                range: c,
                isStart: !1,
                isEnd: !1
            });
        return {
            bg: f,
            fg: g
        }
    }

    function Yn(e) {
        return "background" === e.ui.display || "inverse-background" === e.ui.display
    }

    function Qn(e, t) {
        e.fcSeg = t
    }

    function Zn(e) {
        return e.fcSeg || e.parentNode.fcSeg || null
    }

    function Xn(e, t) {
        return O(e, e => Jn(e, t))
    }

    function Jn(e, t) {
        var r = [];
        return t[""] && r.push(t[""]), t[e.defId] && r.push(t[e.defId]), r.push(e.ui), An(r)
    }

    function Kn(e, r) {
        e = e.map($n);
        return e.sort((e, t) => yt(e, t, r)), e.map(e => e._seg)
    }

    function $n(e) {
        var t = e.eventRange,
            r = t.def,
            t = (t.instance || t).range,
            n = t.start ? t.start.valueOf() : 0,
            t = t.end ? t.end.valueOf() : 0;
        return Object.assign(Object.assign(Object.assign({}, r.extendedProps), r), {
            id: r.publicId,
            start: n,
            end: t,
            duration: t - n,
            allDay: Number(r.allDay),
            _seg: e
        })
    }

    function ei(e, t, r, n, i, s, o) {
        let {
            dateEnv: a,
            options: l
        } = r, {
            displayEventTime: c,
            displayEventEnd: d
        } = l, u = e.eventRange.def, h = e.eventRange.instance;
        null == c && (c = !1 !== n), null == d && (d = !1 !== i);
        var r = h.range.start,
            n = h.range.end,
            i = s || e.start || e.eventRange.range.start,
            e = o || e.end || e.eventRange.range.end,
            f = v(r).valueOf() === v(i).valueOf(),
            g = v(p(n, -1)).valueOf() === v(p(e, -1)).valueOf();
        return c && !u.allDay && (f || g) ? (i = f ? r : i, d && u.hasEnd ? a.formatRange(i, g ? n : e, t, {
            forcedStartTzo: s ? null : h.forcedStartTzo,
            forcedEndTzo: o ? null : h.forcedEndTzo
        }) : a.format(i, t, {
            forcedTzo: s ? null : h.forcedStartTzo
        })) : ""
    }

    function E(e, t, r) {
        e = e.eventRange.range;
        return {
            isPast: e.end <= (r || t.start),
            isFuture: e.start >= (r || t.end),
            isToday: t && S(t, e.start)
        }
    }

    function ti(e) {
        return e.instance ? e.instance.instanceId : e.def.defId + ":" + e.range.start.toISOString()
    }

    function ri(e, t) {
        let {
            def: r,
            instance: n
        } = e.eventRange, i = r.url;
        if (i) return {
            href: i
        };
        let {
            emitter: s,
            options: o
        } = t, a = o.eventInteractive;
        return (a = null == a && null == (a = r.interactive) ? Boolean(s.hasHandlers("eventClick")) : a) ? ct(e => {
            s.trigger("eventClick", {
                el: e.target,
                event: new P(t, r, n),
                jsEvent: e,
                view: t.viewApi
            })
        }) : {}
    }
    let ni = {
        start: r,
        end: r,
        allDay: Boolean
    };

    function ii(o, e, t) {
        var r = (e => {
                let {
                    refined: t,
                    extra: r
                } = Dr(o, ni), n = t.start ? e.createMarkerMeta(t.start) : null, i = t.end ? e.createMarkerMeta(t.end) : null, s = t.allDay;
                return null == s && (s = n && n.isTimeUnspecified && (!i || i.isTimeUnspecified)), Object.assign({
                    range: {
                        start: n ? n.marker : null,
                        end: i ? i.marker : null
                    },
                    allDay: s
                }, r)
            })(e),
            n = r.range;
        if (!n.start) return null;
        if (!n.end) {
            if (null == t) return null;
            n.end = e.add(n.start, t)
        }
        return r
    }

    function si(e, t) {
        return $r(e.range, t.range) && e.allDay === t.allDay && ((e, t) => {
            for (var r in t)
                if ("range" !== r && "allDay" !== r && e[r] !== t[r]) return !1;
            for (var n in e)
                if (!(n in t)) return !1;
            return !0
        })(e, t)
    }

    function oi(e, t, r) {
        return Object.assign(Object.assign({}, ai(e, t, r)), {
            timeZone: t.timeZone
        })
    }

    function ai(e, t, r) {
        return {
            start: t.toDate(e.start),
            end: t.toDate(e.end),
            startStr: t.formatIso(e.start, {
                omitTime: r
            }),
            endStr: t.formatIso(e.end, {
                omitTime: r
            })
        }
    }

    function li(e, t, r) {
        function n(e) {
            s || (s = !0, t(e))
        }

        function i(e) {
            s || (s = !0, r(e))
        }
        let s = !1,
            o = e(n, i);
        o && "function" == typeof o.then && o.then(n, i)
    }
    class ci extends Error {
        constructor(e, t) {
            super(e), this.response = t
        }
    }

    function di(e, t, r) {
        var n = {
            method: e = e.toUpperCase()
        };
        return "GET" === e ? t += (-1 === t.indexOf("?") ? "?" : "&") + new URLSearchParams(r) : (n.body = new URLSearchParams(r), n.headers = {
            "Content-Type": "application/x-www-form-urlencoded"
        }), fetch(t, n).then(t => {
            if (t.ok) return t.json().then(e => [e, t], () => {
                throw new ci("Failure parsing JSON", t)
            });
            throw new ci("Request failed", t)
        })
    }
    let ui;

    function hi() {
        return ui = null == ui ? "undefined" == typeof document || ((e = document.createElement("div")).style.position = "absolute", e.style.top = "0px", e.style.left = "0px", e.innerHTML = "<table><tr><td><div></div></td></tr></table>", e.querySelector("table").style.height = "100px", e.querySelector("div").style.height = "100%", document.body.appendChild(e), t = 0 < e.querySelector("div").offsetHeight, document.body.removeChild(e), t) : ui;
        var e, t
    }
    class fi extends s {
        constructor() {
            super(...arguments), this.state = {
                forPrint: !1
            }, this.handleBeforePrint = () => {
                Br(() => {
                    this.setState({
                        forPrint: !0
                    })
                })
            }, this.handleAfterPrint = () => {
                Br(() => {
                    this.setState({
                        forPrint: !1
                    })
                })
            }
        }
        render() {
            var e = this.props,
                t = e.options,
                r = this.state.forPrint,
                n = r || "auto" === t.height || "auto" === t.contentHeight,
                i = n || null == t.height ? "" : t.height,
                t = ["fc", r ? "fc-media-print" : "fc-media-screen", "fc-direction-" + t.direction, e.theme.getClass("root")];
            return hi() || t.push("fc-liquid-hack"), e.children(t, i, n, r)
        }
        componentDidMount() {
            var e = this.props.emitter;
            e.on("_beforeprint", this.handleBeforePrint), e.on("_afterprint", this.handleAfterPrint)
        }
        componentWillUnmount() {
            var e = this.props.emitter;
            e.off("_beforeprint", this.handleBeforePrint), e.off("_afterprint", this.handleAfterPrint)
        }
    }
    class gi {
        constructor(e) {
            this.component = e.component, this.isHitComboAllowed = e.isHitComboAllowed || null
        }
        destroy() {}
    }

    function pi(e) {
        return {
            [e.component.uid]: e
        }
    }
    let mi = {};
    class m extends x {
        constructor(e, t) {
            super(e, t), this.handleRefresh = () => {
                var e = this.computeTiming();
                e.state.nowDate.valueOf() !== this.state.nowDate.valueOf() && this.setState(e.state), this.clearTimeout(), this.setTimeout(e.waitMs)
            }, this.handleVisibilityChange = () => {
                document.hidden || this.handleRefresh()
            }, this.state = this.computeTiming().state
        }
        render() {
            var {
                props: e,
                state: t
            } = this;
            return e.children(t.nowDate, t.todayRange)
        }
        componentDidMount() {
            this.setTimeout(), this.context.nowManager.addResetListener(this.handleRefresh), document.addEventListener("visibilitychange", this.handleVisibilityChange)
        }
        componentDidUpdate(e) {
            e.unit !== this.props.unit && (this.clearTimeout(), this.setTimeout())
        }
        componentWillUnmount() {
            this.clearTimeout(), this.context.nowManager.removeResetListener(this.handleRefresh), document.removeEventListener("visibilitychange", this.handleVisibilityChange)
        }
        computeTiming() {
            var {
                props: e,
                context: t
            } = this, r = t.nowManager.getDateMarker(), n = t.dateEnv.startOf(r, e.unit), t = t.dateEnv.add(n, M(1, e.unit)).valueOf() - r.valueOf(), t = Math.min(864e5, t);
            return {
                state: {
                    nowDate: n,
                    todayRange: (e => ({
                        start: e = v(e),
                        end: _(e, 1)
                    }))(n)
                },
                waitMs: t
            }
        }
        setTimeout(e = this.computeTiming().waitMs) {
            this.timeoutId = setTimeout(() => {
                let e = this.computeTiming();
                this.setState(e.state, () => {
                    this.setTimeout(e.waitMs)
                })
            }, e)
        }
        clearTimeout() {
            this.timeoutId && clearTimeout(this.timeoutId)
        }
    }
    m.contextType = u;
    class vi {
        getCurrentData() {
            return this.currentDataManager.getCurrentData()
        }
        dispatch(e) {
            this.currentDataManager.dispatch(e)
        }
        get view() {
            return this.getCurrentData().viewApi
        }
        batchRendering(e) {
            e()
        }
        updateSize() {
            this.trigger("_resize", !0)
        }
        setOption(e, t) {
            this.dispatch({
                type: "SET_OPTION",
                optionName: e,
                rawOptionValue: t
            })
        }
        getOption(e) {
            return this.currentDataManager.currentCalendarOptionsInput[e]
        }
        getAvailableLocaleCodes() {
            return Object.keys(this.getCurrentData().availableRawLocales)
        }
        on(e, t) {
            var r = this.currentDataManager;
            r.currentCalendarOptionsRefiners[e] ? r.emitter.on(e, t) : console.warn(`Unknown listener name '${e}'`)
        }
        off(e, t) {
            this.currentDataManager.emitter.off(e, t)
        }
        trigger(e, ...t) {
            this.currentDataManager.emitter.trigger(e, ...t)
        }
        changeView(t, r) {
            this.batchRendering(() => {
                var e;
                this.unselect(), r ? r.start && r.end ? (this.dispatch({
                    type: "CHANGE_VIEW_TYPE",
                    viewType: t
                }), this.dispatch({
                    type: "SET_OPTION",
                    optionName: "visibleRange",
                    rawOptionValue: r
                })) : (e = this.getCurrentData().dateEnv, this.dispatch({
                    type: "CHANGE_VIEW_TYPE",
                    viewType: t,
                    dateMarker: e.createMarker(r)
                })) : this.dispatch({
                    type: "CHANGE_VIEW_TYPE",
                    viewType: t
                })
            })
        }
        zoomTo(e, t) {
            t = t || "day", t = this.getCurrentData().viewSpecs[t] || this.getUnitViewSpec(t), this.unselect(), t ? this.dispatch({
                type: "CHANGE_VIEW_TYPE",
                viewType: t.type,
                dateMarker: e
            }) : this.dispatch({
                type: "CHANGE_DATE",
                dateMarker: e
            })
        }
        getUnitViewSpec(e) {
            let t, r, {
                    viewSpecs: n,
                    toolbarConfig: i
                } = this.getCurrentData(),
                s = [].concat(i.header ? i.header.viewsWithButtons : [], i.footer ? i.footer.viewsWithButtons : []);
            for (var o in n) s.push(o);
            for (t = 0; t < s.length; t += 1)
                if ((r = n[s[t]]) && r.singleUnit === e) return r;
            return null
        }
        prev() {
            this.unselect(), this.dispatch({
                type: "PREV"
            })
        }
        next() {
            this.unselect(), this.dispatch({
                type: "NEXT"
            })
        }
        prevYear() {
            var e = this.getCurrentData();
            this.unselect(), this.dispatch({
                type: "CHANGE_DATE",
                dateMarker: e.dateEnv.addYears(e.currentDate, -1)
            })
        }
        nextYear() {
            var e = this.getCurrentData();
            this.unselect(), this.dispatch({
                type: "CHANGE_DATE",
                dateMarker: e.dateEnv.addYears(e.currentDate, 1)
            })
        }
        today() {
            var e = this.getCurrentData();
            this.unselect(), this.dispatch({
                type: "CHANGE_DATE",
                dateMarker: e.nowManager.getDateMarker()
            })
        }
        gotoDate(e) {
            var t = this.getCurrentData();
            this.unselect(), this.dispatch({
                type: "CHANGE_DATE",
                dateMarker: t.dateEnv.createMarker(e)
            })
        }
        incrementDate(e) {
            var t = this.getCurrentData(),
                e = M(e);
            e && (this.unselect(), this.dispatch({
                type: "CHANGE_DATE",
                dateMarker: t.dateEnv.add(t.currentDate, e)
            }))
        }
        getDate() {
            var e = this.getCurrentData();
            return e.dateEnv.toDate(e.currentDate)
        }
        formatDate(e, t) {
            var r = this.getCurrentData().dateEnv;
            return r.format(r.createMarker(e), I(t))
        }
        formatRange(e, t, r) {
            var n = this.getCurrentData().dateEnv;
            return n.formatRange(n.createMarker(e), n.createMarker(t), I(r), r)
        }
        formatIso(e, t) {
            var r = this.getCurrentData().dateEnv;
            return r.formatIso(r.createMarker(e), {
                omitTime: t
            })
        }
        select(e, t) {
            e = null == t ? null != e.start ? e : {
                start: e,
                end: null
            } : {
                start: e,
                end: t
            }, t = this.getCurrentData(), e = ii(e, t.dateEnv, M({
                days: 1
            }));
            e && (this.dispatch({
                type: "SELECT_DATES",
                selection: e
            }), jn(e, null, t))
        }
        unselect(e) {
            var t = this.getCurrentData();
            t.dateSelection && (this.dispatch({
                type: "UNSELECT_DATES"
            }), (t = t).emitter.trigger("unselect", {
                jsEvent: e ? e.origEvent : null,
                view: t.viewApi || t.calendarApi.view
            }))
        }
        addEvent(e, t) {
            if (e instanceof P) return i = e._def, s = e._instance, this.getCurrentData().eventStore.defs[i.defId] || (this.dispatch({
                type: "ADD_EVENTS",
                eventStore: yn({
                    def: i,
                    instance: s
                })
            }), this.triggerEventAdd(e)), e;
            let r, n = this.getCurrentData();
            if (t instanceof Gn) r = t.internalEventSource;
            else if ("boolean" == typeof t) t && ([r] = Mr(n.eventSources));
            else if (null != t) {
                var i = this.getEventSourceById(t);
                if (!i) return console.warn(`Could not find an event source with ID "${t}"`), null;
                r = i.internalEventSource
            }
            var s = fn(e, r, n, !1);
            return s ? (t = new P(n, s.def, s.def.recurringDef ? null : s.instance), this.dispatch({
                type: "ADD_EVENTS",
                eventStore: yn(s)
            }), this.triggerEventAdd(t), t) : null
        }
        triggerEventAdd(e) {
            var t = this.getCurrentData().emitter;
            t.trigger("eventAdd", {
                event: e,
                relatedEvents: [],
                revert: () => {
                    this.dispatch({
                        type: "REMOVE_EVENTS",
                        eventStore: Fn(e)
                    })
                }
            })
        }
        getEventById(e) {
            var t, r = this.getCurrentData(),
                {
                    defs: n,
                    instances: i
                } = r.eventStore;
            for (t in e = String(e), n) {
                var s = n[t];
                if (s.publicId === e) {
                    if (s.recurringDef) return new P(r, s, null);
                    for (var o in i) {
                        o = i[o];
                        if (o.defId === s.defId) return new P(r, s, o)
                    }
                }
            }
            return null
        }
        getEvents() {
            var e = this.getCurrentData();
            return Vn(e.eventStore, e)
        }
        removeAllEvents() {
            this.dispatch({
                type: "REMOVE_ALL_EVENTS"
            })
        }
        getEventSources() {
            var e, t = this.getCurrentData(),
                r = t.eventSources,
                n = [];
            for (e in r) n.push(new Gn(t, r[e]));
            return n
        }
        getEventSourceById(e) {
            var t, r = this.getCurrentData(),
                n = r.eventSources;
            for (t in e = String(e), n)
                if (n[t].publicId === e) return new Gn(r, n[t]);
            return null
        }
        addEventSource(e) {
            var t = this.getCurrentData();
            return e instanceof Gn ? (t.eventSources[e.internalEventSource.sourceId] || this.dispatch({
                type: "ADD_EVENT_SOURCES",
                sources: [e.internalEventSource]
            }), e) : (e = Mn(e, t)) ? (this.dispatch({
                type: "ADD_EVENT_SOURCES",
                sources: [e]
            }), new Gn(t, e)) : null
        }
        removeAllEventSources() {
            this.dispatch({
                type: "REMOVE_ALL_EVENT_SOURCES"
            })
        }
        refetchEvents() {
            this.dispatch({
                type: "FETCH_EVENT_SOURCES",
                isRefetch: !0
            })
        }
        scrollToTime(e) {
            e = M(e);
            e && this.trigger("_scrollRequest", {
                time: e
            })
        }
    }

    function yi(e, t) {
        return e.left >= t.left && e.left < t.right && e.top >= t.top && e.top < t.bottom
    }

    function bi(e, t) {
        e = {
            left: Math.max(e.left, t.left),
            right: Math.min(e.right, t.right),
            top: Math.max(e.top, t.top),
            bottom: Math.min(e.bottom, t.bottom)
        };
        return e.left < e.right && e.top < e.bottom && e
    }

    function Si(e, t, r) {
        return {
            left: e.left + t,
            right: e.right + t,
            top: e.top + r,
            bottom: e.bottom + r
        }
    }

    function Ei(e, t) {
        return {
            left: Math.min(Math.max(e.left, t.left), t.right),
            top: Math.min(Math.max(e.top, t.top), t.bottom)
        }
    }

    function Ci(e) {
        return {
            left: (e.left + e.right) / 2,
            top: (e.top + e.bottom) / 2
        }
    }

    function wi(e, t) {
        return {
            left: e.left - t.left,
            top: e.top - t.top
        }
    }
    let Di = {
        defs: {},
        instances: {}
    };
    class Ri {
        constructor() {
            this.getKeysForEventDefs = f(this._getKeysForEventDefs), this.splitDateSelection = f(this._splitDateSpan), this.splitEventStore = f(this._splitEventStore), this.splitIndividualUi = f(this._splitIndividualUi), this.splitEventDrag = f(this._splitInteraction), this.splitEventResize = f(this._splitInteraction), this.eventUiBuilders = {}
        }
        splitProps(e) {
            var t, r = this.getKeyInfo(e),
                n = this.getKeysForEventDefs(e.eventStore),
                i = this.splitDateSelection(e.dateSelection),
                s = this.splitIndividualUi(e.eventUiBases, n),
                o = this.splitEventStore(e.eventStore, n),
                a = this.splitEventDrag(e.eventDrag),
                l = this.splitEventResize(e.eventResize),
                c = {};
            for (t in this.eventUiBuilders = O(r, (e, t) => this.eventUiBuilders[t] || f(Ai)), r) {
                var d = r[t],
                    u = o[t] || Di,
                    h = this.eventUiBuilders[t];
                c[t] = {
                    businessHours: d.businessHours || e.businessHours,
                    dateSelection: i[t] || null,
                    eventStore: u,
                    eventUiBases: h(e.eventUiBases[""], d.ui, s[t]),
                    eventSelection: u.instances[e.eventSelection] ? e.eventSelection : "",
                    eventDrag: a[t] || null,
                    eventResize: l[t] || null
                }
            }
            return c
        }
        _splitDateSpan(e) {
            var t, r = {};
            if (e)
                for (t of this.getKeysForDateSpan(e)) r[t] = e;
            return r
        }
        _getKeysForEventDefs(e) {
            return O(e.defs, e => this.getKeysForEventDef(e))
        }
        _splitEventStore(e, t) {
            var r, n, {
                    defs: i,
                    instances: s
                } = e,
                o = {};
            for (r in i)
                for (var a of t[r]) o[a] || (o[a] = {
                    defs: {},
                    instances: {}
                }), o[a].defs[r] = i[r];
            for (n in s) {
                var l, c = s[n];
                for (l of t[c.defId]) o[l] && (o[l].instances[n] = c)
            }
            return o
        }
        _splitIndividualUi(e, t) {
            var r, n = {};
            for (r in e)
                if (r)
                    for (var i of t[r]) n[i] || (n[i] = {}), n[i][r] = e[r];
            return n
        }
        _splitInteraction(i) {
            let s = {};
            if (i) {
                let t = this._splitEventStore(i.affectedEvents, this._getKeysForEventDefs(i.affectedEvents)),
                    e = this._getKeysForEventDefs(i.mutatedEvents),
                    r = this._splitEventStore(i.mutatedEvents, e),
                    n = e => {
                        s[e] || (s[e] = {
                            affectedEvents: t[e] || Di,
                            mutatedEvents: r[e] || Di,
                            isEvent: i.isEvent
                        })
                    };
                for (var o in t) n(o);
                for (var a in r) n(a)
            }
            return s
        }
    }

    function Ai(e, t, r) {
        var n = [],
            e = (e && n.push(e), t && n.push(t), {
                "": An(n)
            });
        return r && Object.assign(e, r), e
    }

    function xi(e, t, r, n) {
        return {
            dow: e.getUTCDay(),
            isDisabled: Boolean(n && (!n.activeRange || !S(n.activeRange, e))),
            isOther: Boolean(n && !S(n.currentRange, e)),
            isToday: Boolean(t && S(t, e)),
            isPast: Boolean(r ? e < r : !!t && e < t.start),
            isFuture: Boolean(r ? r < e : !!t && e >= t.end)
        }
    }

    function Ti(e, t) {
        var r = ["fc-day", "fc-day-" + Nt[e.dow]];
        return e.isDisabled ? r.push("fc-day-disabled") : (e.isToday && (r.push("fc-day-today"), r.push(t.getClass("today"))), e.isPast && r.push("fc-day-past"), e.isFuture && r.push("fc-day-future"), e.isOther && r.push("fc-day-other")), r
    }

    function Mi(e, t) {
        var r = ["fc-slot", "fc-slot-" + Nt[e.dow]];
        return e.isDisabled ? r.push("fc-slot-disabled") : (e.isToday && (r.push("fc-slot-today"), r.push(t.getClass("today"))), e.isPast && r.push("fc-slot-past"), e.isFuture && r.push("fc-slot-future")), r
    }
    let ki = I({
            year: "numeric",
            month: "long",
            day: "numeric"
        }),
        _i = I({
            week: "long"
        });

    function Ii(e, r, n = "day", t = !0) {
        let {
            dateEnv: i,
            options: s,
            calendarApi: o
        } = e;
        var a, l, e = i.format(r, "week" === n ? _i : ki);
        return s.navLinks ? (a = i.toDate(r), l = e => {
            var t = "day" === n ? s.navLinkDayClick : "week" === n ? s.navLinkWeekClick : null;
            "function" == typeof t ? t.call(o, i.toDate(r), e) : ("string" == typeof t && (n = t), o.zoomTo(r, n))
        }, Object.assign({
            title: St(s.navLinkHint, [e, a], e),
            "data-navlink": ""
        }, t ? lt(l) : {
            onClick: l
        })) : {
            "aria-label": e
        }
    }
    let Oi, Pi = null;

    function Ni() {
        return Pi = null === Pi ? (et(e = document.createElement("div"), {
            position: "absolute",
            top: -1e3,
            left: 0,
            border: 0,
            padding: 0,
            overflow: "scroll",
            direction: "rtl"
        }), e.innerHTML = "<div></div>", document.body.appendChild(e), t = e.firstChild.getBoundingClientRect().left > e.getBoundingClientRect().left, Ze(e), t) : Pi;
        var e, t
    }

    function Hi() {
        return Oi = Oi || ((e = document.createElement("div")).style.overflow = "scroll", e.style.position = "absolute", e.style.top = "-9999px", e.style.left = "-9999px", document.body.appendChild(e), t = Wi(e), document.body.removeChild(e), t);
        var e, t
    }

    function Wi(e) {
        return {
            x: e.offsetHeight - e.clientHeight,
            y: e.offsetWidth - e.clientWidth
        }
    }

    function Bi(e, t = !1) {
        var r = window.getComputedStyle(e),
            n = parseInt(r.borderLeftWidth, 10) || 0,
            i = parseInt(r.borderRightWidth, 10) || 0,
            s = parseInt(r.borderTopWidth, 10) || 0,
            o = parseInt(r.borderBottomWidth, 10) || 0,
            e = Wi(e),
            a = e.y - n - i,
            n = {
                borderLeft: n,
                borderRight: i,
                borderTop: s,
                borderBottom: o,
                scrollbarBottom: e.x - s - o,
                scrollbarLeft: 0,
                scrollbarRight: 0
            };
        return Ni() && "rtl" === r.direction ? n.scrollbarLeft = a : n.scrollbarRight = a, t && (n.paddingLeft = parseInt(r.paddingLeft, 10) || 0, n.paddingRight = parseInt(r.paddingRight, 10) || 0, n.paddingTop = parseInt(r.paddingTop, 10) || 0, n.paddingBottom = parseInt(r.paddingBottom, 10) || 0), n
    }

    function ji(e, t = !1, r) {
        r = r ? e.getBoundingClientRect() : Li(e), e = Bi(e, t), r = {
            left: r.left + e.borderLeft + e.scrollbarLeft,
            right: r.right - e.borderRight - e.scrollbarRight,
            top: r.top + e.borderTop,
            bottom: r.bottom - e.borderBottom - e.scrollbarBottom
        };
        return t && (r.left += e.paddingLeft, r.right -= e.paddingRight, r.top += e.paddingTop, r.bottom -= e.paddingBottom), r
    }

    function Li(e) {
        e = e.getBoundingClientRect();
        return {
            left: e.left + window.scrollX,
            top: e.top + window.scrollY,
            right: e.right + window.scrollX,
            bottom: e.bottom + window.scrollY
        }
    }

    function zi(e) {
        for (var t = []; e instanceof HTMLElement;) {
            var r = window.getComputedStyle(e);
            if ("fixed" === r.position) break;
            /(auto|scroll)/.test(r.overflow + r.overflowY + r.overflowX) && t.push(e), e = e.parentNode
        }
        return t
    }
    class Ui {
        constructor(e, t, r, n) {
            this.els = t;
            t = this.originClientRect = e.getBoundingClientRect();
            r && this.buildElHorizontals(t.left), n && this.buildElVerticals(t.top)
        }
        buildElHorizontals(e) {
            var t, r = [],
                n = [];
            for (t of this.els) {
                var i = t.getBoundingClientRect();
                r.push(i.left - e), n.push(i.right - e)
            }
            this.lefts = r, this.rights = n
        }
        buildElVerticals(e) {
            var t, r = [],
                n = [];
            for (t of this.els) {
                var i = t.getBoundingClientRect();
                r.push(i.top - e), n.push(i.bottom - e)
            }
            this.tops = r, this.bottoms = n
        }
        leftToIndex(e) {
            let t, {
                    lefts: r,
                    rights: n
                } = this,
                i = r.length;
            for (t = 0; t < i; t += 1)
                if (e >= r[t] && e < n[t]) return t
        }
        topToIndex(e) {
            let t, {
                    tops: r,
                    bottoms: n
                } = this,
                i = r.length;
            for (t = 0; t < i; t += 1)
                if (e >= r[t] && e < n[t]) return t
        }
        getWidth(e) {
            return this.rights[e] - this.lefts[e]
        }
        getHeight(e) {
            return this.bottoms[e] - this.tops[e]
        }
        similarTo(e) {
            return Gi(this.tops || [], e.tops || []) && Gi(this.bottoms || [], e.bottoms || []) && Gi(this.lefts || [], e.lefts || []) && Gi(this.rights || [], e.rights || [])
        }
    }

    function Gi(t, r) {
        var n = t.length;
        if (n !== r.length) return !1;
        for (let e = 0; e < n; e++)
            if (Math.round(t[e]) !== Math.round(r[e])) return !1;
        return !0
    }
    class Fi {
        getMaxScrollTop() {
            return this.getScrollHeight() - this.getClientHeight()
        }
        getMaxScrollLeft() {
            return this.getScrollWidth() - this.getClientWidth()
        }
        canScrollVertically() {
            return 0 < this.getMaxScrollTop()
        }
        canScrollHorizontally() {
            return 0 < this.getMaxScrollLeft()
        }
        canScrollUp() {
            return 0 < this.getScrollTop()
        }
        canScrollDown() {
            return this.getScrollTop() < this.getMaxScrollTop()
        }
        canScrollLeft() {
            return 0 < this.getScrollLeft()
        }
        canScrollRight() {
            return this.getScrollLeft() < this.getMaxScrollLeft()
        }
    }
    class Vi extends Fi {
        constructor(e) {
            super(), this.el = e
        }
        getScrollTop() {
            return this.el.scrollTop
        }
        getScrollLeft() {
            return this.el.scrollLeft
        }
        setScrollTop(e) {
            this.el.scrollTop = e
        }
        setScrollLeft(e) {
            this.el.scrollLeft = e
        }
        getScrollWidth() {
            return this.el.scrollWidth
        }
        getScrollHeight() {
            return this.el.scrollHeight
        }
        getClientHeight() {
            return this.el.clientHeight
        }
        getClientWidth() {
            return this.el.clientWidth
        }
    }
    class qi extends Fi {
        getScrollTop() {
            return window.scrollY
        }
        getScrollLeft() {
            return window.scrollX
        }
        setScrollTop(e) {
            window.scroll(window.scrollX, e)
        }
        setScrollLeft(e) {
            window.scroll(e, window.scrollY)
        }
        getScrollWidth() {
            return document.documentElement.scrollWidth
        }
        getScrollHeight() {
            return document.documentElement.scrollHeight
        }
        getClientHeight() {
            return document.documentElement.clientHeight
        }
        getClientWidth() {
            return document.documentElement.clientWidth
        }
    }
    class a extends s {
        constructor() {
            super(...arguments), this.uid = c()
        }
        prepareHits() {}
        queryHit(e, t, r, n) {
            return null
        }
        isValidSegDownEl(e) {
            return !this.props.eventDrag && !this.props.eventResize && !l(e, ".fc-event-mirror")
        }
        isValidDateDownEl(e) {
            return !(l(e, ".fc-event:not(.fc-bg-event)") || l(e, ".fc-more-link") || l(e, "a[data-navlink]") || l(e, ".fc-popover"))
        }
    }
    class Yi {
        constructor(e = e => e.thickness || 1) {
            this.getEntryThickness = e, this.strictOrder = !1, this.allowReslicing = !1, this.maxCoord = -1, this.maxStackCnt = -1, this.levelCoords = [], this.entriesByLevel = [], this.stackCnts = {}
        }
        addSegs(e) {
            var t, r = [];
            for (t of e) this.insertEntry(t, r);
            return r
        }
        insertEntry(e, t) {
            var r = this.findInsertion(e);
            this.isInsertionValid(r, e) ? this.insertEntryAt(e, r) : this.handleInvalidInsertion(r, e, t)
        }
        isInsertionValid(e, t) {
            return (-1 === this.maxCoord || e.levelCoord + this.getEntryThickness(t) <= this.maxCoord) && (-1 === this.maxStackCnt || e.stackCnt < this.maxStackCnt)
        }
        handleInvalidInsertion(e, t, r) {
            var n;
            this.allowReslicing && e.touchingEntry ? (n = Object.assign(Object.assign({}, t), {
                span: Ji(t.span, e.touchingEntry.span)
            }), r.push(n), this.splitEntry(t, e.touchingEntry, r)) : r.push(t)
        }
        splitEntry(e, t, r) {
            var n = e.span,
                t = t.span;
            n.start < t.start && this.insertEntry({
                index: e.index,
                thickness: e.thickness,
                span: {
                    start: n.start,
                    end: t.start
                }
            }, r), t.end < n.end && this.insertEntry({
                index: e.index,
                thickness: e.thickness,
                span: {
                    start: t.end,
                    end: n.end
                }
            }, r)
        }
        insertEntryAt(e, t) {
            var {
                entriesByLevel: r,
                levelCoords: n
            } = this; - 1 === t.lateral ? (Ki(n, t.level, t.levelCoord), Ki(r, t.level, [e])) : Ki(r[t.level], t.lateral, e), this.stackCnts[Zi(e)] = t.stackCnt
        }
        findInsertion(o) {
            let {
                levelCoords: a,
                entriesByLevel: l,
                strictOrder: c,
                stackCnts: d
            } = this, e = a.length, u = 0, h = -1, f = -1, g = null, p = 0;
            for (let s = 0; s < e; s += 1) {
                let e = a[s];
                if (!c && e >= u + this.getEntryThickness(o)) break;
                let t, r = l[s],
                    n = $i(r, o.span.start, Qi),
                    i = n[0] + n[1];
                for (;
                    (t = r[i]) && t.span.start < o.span.end;) {
                    var m = e + this.getEntryThickness(t);
                    m > u && (u = m, g = t, h = s, f = i), m === u && (p = Math.max(p, d[Zi(t)] + 1)), i += 1
                }
            }
            let t = 0;
            if (g)
                for (t = h + 1; t < e && a[t] < u;) t += 1;
            let r = -1;
            return t < e && a[t] === u && (r = $i(l[t], o.span.end, Qi)[0]), {
                touchingLevel: h,
                touchingLateral: f,
                touchingEntry: g,
                stackCnt: p,
                levelCoord: u,
                level: t,
                lateral: r
            }
        }
        toRects() {
            var {
                entriesByLevel: t,
                levelCoords: r
            } = this, n = t.length, i = [];
            for (let e = 0; e < n; e += 1) {
                var s, o = t[e],
                    a = r[e];
                for (s of o) i.push(Object.assign(Object.assign({}, s), {
                    thickness: this.getEntryThickness(s),
                    levelCoord: a
                }))
            }
            return i
        }
    }

    function Qi(e) {
        return e.span.end
    }

    function Zi(e) {
        return e.index + ":" + e.span.start
    }

    function Xi(e) {
        let r = [];
        for (var n of e) {
            let e = [],
                t = {
                    span: n.span,
                    entries: [n]
                };
            for (var i of r) Ji(i.span, t.span) ? t = {
                entries: i.entries.concat(t.entries),
                span: (s = i.span, o = t.span, {
                    start: Math.min(s.start, o.start),
                    end: Math.max(s.end, o.end)
                })
            } : e.push(i);
            e.push(t), r = e
        }
        var s, o;
        return r
    }

    function Ji(e, t) {
        var r = Math.max(e.start, t.start),
            e = Math.min(e.end, t.end);
        return r < e ? {
            start: r,
            end: e
        } : null
    }

    function Ki(e, t, r) {
        e.splice(t, 0, r)
    }

    function $i(e, t, r) {
        let n = 0,
            i = e.length;
        if (!i || t < r(e[n])) return [0, 0];
        if (t > r(e[i - 1])) return [i, 0];
        for (; n < i;) {
            var s = Math.floor(n + (i - n) / 2),
                o = r(e[s]);
            if (t < o) i = s;
            else {
                if (!(o < t)) return [s, 1];
                n = s + 1
            }
        }
        return [n, 0]
    }
    class es {
        constructor(e, t) {
            this.emitter = new Hn
        }
        destroy() {}
        setMirrorIsVisible(e) {}
        setMirrorNeedsRevert(e) {}
        setAutoScrollEnabled(e) {}
    }
    let N = {},
        ts = {
            startTime: M,
            duration: M,
            create: Boolean,
            sourceId: String
        };

    function rs(e) {
        var {
            refined: e,
            extra: t
        } = Dr(e, ts);
        return {
            startTime: e.startTime || null,
            duration: e.duration || null,
            create: null == e.create || e.create,
            sourceId: e.sourceId,
            leftoverProps: t
        }
    }

    function ns(e, t) {
        return I(!e || 10 < t ? {
            weekday: "short"
        } : 1 < t ? {
            weekday: "short",
            month: "numeric",
            day: "numeric",
            omitCommas: !0
        } : {
            weekday: "long"
        })
    }
    let is = "fc-col-header-cell";

    function ss(e) {
        return e.text
    }
    class os extends s {
        render() {
            let {
                dateEnv: e,
                options: t,
                theme: r,
                viewApi: n
            } = this.context, i = this.props, {
                date: s,
                dateProfile: o
            } = i, a = xi(s, i.todayRange, null, o), l = [is].concat(Ti(a, r)), c = e.format(s, i.dayHeaderFormat), d = !a.isDisabled && 1 < i.colCnt ? Ii(this.context, s) : {}, u = e.toDate(s);
            e.namedTimeZoneImpl && (u = p(u, 36e5));
            var h = Object.assign(Object.assign(Object.assign({
                date: u,
                view: n
            }, i.extraRenderProps), {
                text: c
            }), a);
            return b(g, {
                elTag: "th",
                elClasses: l,
                elAttrs: Object.assign({
                    role: "columnheader",
                    colSpan: i.colSpan,
                    "data-date": a.isDisabled ? void 0 : Zt(s)
                }, i.extraDataAttrs),
                renderProps: h,
                generatorName: "dayHeaderContent",
                customGenerator: t.dayHeaderContent,
                defaultGenerator: ss,
                classNameGenerator: t.dayHeaderClassNames,
                didMount: t.dayHeaderDidMount,
                willUnmount: t.dayHeaderWillUnmount
            }, e => b("div", {
                className: "fc-scrollgrid-sync-inner"
            }, !a.isDisabled && b(e, {
                elTag: "a",
                elAttrs: d,
                elClasses: ["fc-col-header-cell-cushion", i.isSticky && "fc-sticky"]
            })))
        }
    }
    let as = I({
        weekday: "long"
    });
    class ls extends s {
        render() {
            let t = this.props,
                {
                    dateEnv: r,
                    theme: e,
                    viewApi: n,
                    options: i
                } = this.context,
                s = _(new Date(2592e5), t.dow),
                o = {
                    dow: t.dow,
                    isDisabled: !1,
                    isFuture: !1,
                    isPast: !1,
                    isToday: !1,
                    isOther: !1
                },
                a = r.format(s, t.dayHeaderFormat),
                l = Object.assign(Object.assign(Object.assign(Object.assign({
                    date: s
                }, o), {
                    view: n
                }), t.extraRenderProps), {
                    text: a
                });
            return b(g, {
                elTag: "th",
                elClasses: [is, ...Ti(o, e), ...t.extraClassNames || []],
                elAttrs: Object.assign({
                    role: "columnheader",
                    colSpan: t.colSpan
                }, t.extraDataAttrs),
                renderProps: l,
                generatorName: "dayHeaderContent",
                customGenerator: i.dayHeaderContent,
                defaultGenerator: ss,
                classNameGenerator: i.dayHeaderClassNames,
                didMount: i.dayHeaderDidMount,
                willUnmount: i.dayHeaderWillUnmount
            }, e => b("div", {
                className: "fc-scrollgrid-sync-inner"
            }, b(e, {
                elTag: "a",
                elClasses: ["fc-col-header-cell-cushion", t.isSticky && "fc-sticky"],
                elAttrs: {
                    "aria-label": r.format(s, as)
                }
            })))
        }
    }
    class cs extends s {
        constructor() {
            super(...arguments), this.createDayHeaderFormatter = f(ds)
        }
        render() {
            let e = this.context,
                {
                    dates: r,
                    dateProfile: n,
                    datesRepDistinctDays: i,
                    renderIntro: s
                } = this.props,
                o = this.createDayHeaderFormatter(e.options.dayHeaderFormat, i, r.length);
            return b(m, {
                unit: "day"
            }, (e, t) => b("tr", {
                role: "row"
            }, s && s("day"), r.map(e => i ? b(os, {
                key: e.toISOString(),
                date: e,
                dateProfile: n,
                todayRange: t,
                colCnt: r.length,
                dayHeaderFormat: o
            }) : b(ls, {
                key: e.getUTCDay(),
                dow: e.getUTCDay(),
                dayHeaderFormat: o
            }))))
        }
    }

    function ds(e, t, r) {
        return e || ns(t, r)
    }
    class us {
        constructor(e, t) {
            let r = e.start,
                n = e.end,
                i = [],
                s = [],
                o = -1;
            for (; r < n;) t.isHiddenDay(r) ? i.push(o + .5) : (o += 1, i.push(o), s.push(r)), r = _(r, 1);
            this.dates = s, this.indices = i, this.cnt = s.length
        }
        sliceRange(e) {
            var t = this.getDateDayIndex(e.start),
                e = this.getDateDayIndex(_(e.end, -1)),
                r = Math.max(0, t),
                n = Math.min(this.cnt - 1, e);
            return (r = Math.ceil(r)) <= (n = Math.floor(n)) ? {
                firstIndex: r,
                lastIndex: n,
                isStart: t === r,
                isEnd: e === n
            } : null
        }
        getDateDayIndex(e) {
            var t = this.indices,
                e = Math.floor(Bt(this.dates[0], e));
            return e < 0 ? t[0] - 1 : e >= t.length ? t[t.length - 1] + 1 : t[e]
        }
    }
    class hs {
        constructor(e, t) {
            let r, n, i, s = e.dates;
            if (t) {
                for (n = s[0].getUTCDay(), r = 1; r < s.length && s[r].getUTCDay() !== n; r += 1);
                i = Math.ceil(s.length / r)
            } else i = 1, r = s.length;
            this.rowCnt = i, this.colCnt = r, this.daySeries = e, this.cells = this.buildCells(), this.headerDates = this.buildHeaderDates()
        }
        buildCells() {
            var e = [];
            for (let t = 0; t < this.rowCnt; t += 1) {
                var r = [];
                for (let e = 0; e < this.colCnt; e += 1) r.push(this.buildCell(t, e));
                e.push(r)
            }
            return e
        }
        buildCell(e, t) {
            e = this.daySeries.dates[e * this.colCnt + t];
            return {
                key: e.toISOString(),
                date: e
            }
        }
        buildHeaderDates() {
            var t = [];
            for (let e = 0; e < this.colCnt; e += 1) t.push(this.cells[0][e].date);
            return t
        }
        sliceRange(e) {
            var n = this.colCnt,
                i = this.daySeries.sliceRange(e),
                s = [];
            if (i) {
                let {
                    firstIndex: e,
                    lastIndex: t
                } = i, r = e;
                for (; r <= t;) {
                    var o = Math.floor(r / n),
                        a = Math.min((o + 1) * n, t + 1);
                    s.push({
                        row: o,
                        firstCol: r % n,
                        lastCol: (a - 1) % n,
                        isStart: i.isStart && r === e,
                        isEnd: i.isEnd && a - 1 === t
                    }), r = a
                }
            }
            return s
        }
    }
    class fs {
        constructor() {
            this.sliceBusinessHours = f(this._sliceBusinessHours), this.sliceDateSelection = f(this._sliceDateSpan), this.sliceEventStore = f(this._sliceEventStore), this.sliceEventDrag = f(this._sliceInteraction), this.sliceEventResize = f(this._sliceInteraction), this.forceDayIfListItem = !1
        }
        sliceProps(e, t, r, n, ...i) {
            var s = e.eventUiBases,
                o = this.sliceEventStore(e.eventStore, s, t, r, ...i);
            return {
                dateSelectionSegs: this.sliceDateSelection(e.dateSelection, t, r, s, n, ...i),
                businessHourSegs: this.sliceBusinessHours(e.businessHours, t, r, n, ...i),
                fgEventSegs: o.fg,
                bgEventSegs: o.bg,
                eventDrag: this.sliceEventDrag(e.eventDrag, s, t, r, ...i),
                eventResize: this.sliceEventResize(e.eventResize, s, t, r, ...i),
                eventSelection: e.eventSelection
            }
        }
        sliceNowDate(e, t, r, n, ...i) {
            return this._sliceDateSpan({
                range: {
                    start: e,
                    end: p(e, 1)
                },
                allDay: !1
            }, t, r, {}, n, ...i)
        }
        _sliceBusinessHours(e, t, r, n, ...i) {
            return e ? this._sliceEventStore(cn(e, gs(t, Boolean(r)), n), {}, t, r, ...i).bg : []
        }
        _sliceEventStore(e, t, r, n, ...i) {
            return e ? (e = qn(e, t, gs(r, Boolean(n)), n), {
                bg: this.sliceEventRanges(e.bg, i),
                fg: this.sliceEventRanges(e.fg, i)
            }) : {
                bg: [],
                fg: []
            }
        }
        _sliceInteraction(e, t, r, n, ...i) {
            return e ? (t = qn(e.mutatedEvents, t, gs(r, Boolean(n)), n), {
                segs: this.sliceEventRanges(t.fg, i),
                affectedInstances: e.affectedEvents.instances,
                isEvent: e.isEvent
            }) : null
        }
        _sliceDateSpan(e, t, r, n, i, ...s) {
            if (e) {
                var t = gs(t, Boolean(r)),
                    r = D(e.range, t);
                if (r) {
                    t = e = Object.assign(Object.assign({}, e), {
                        range: r
                    }), r = n;
                    var o, a = {
                            def: i = mn((i = gn({
                                editable: !1
                            }, n = i)).refined, i.extra, "", t.allDay, !0, n),
                            ui: Jn(i, r),
                            instance: ln(i.defId, t.range),
                            range: t.range,
                            isStart: !0,
                            isEnd: !0
                        },
                        n = this.sliceRange(e.range, ...s);
                    for (o of n) o.eventRange = a;
                    return n
                }
            }
            return []
        }
        sliceEventRanges(e, t) {
            var r, n = [];
            for (r of e) n.push(...this.sliceEventRange(r, t));
            return n
        }
        sliceEventRange(e, t) {
            let r = e.range;
            this.forceDayIfListItem && "list-item" === e.ui.display && (r = {
                start: r.start,
                end: _(r.start, 1)
            });
            var n, t = this.sliceRange(r, ...t);
            for (n of t) n.eventRange = e, n.isStart = e.isStart && n.isStart, n.isEnd = e.isEnd && n.isEnd;
            return t
        }
    }

    function gs(e, t) {
        var r = e.activeRange;
        return t ? r : {
            start: p(r.start, e.slotMinTime.milliseconds),
            end: p(r.end, e.slotMaxTime.milliseconds - 864e5)
        }
    }

    function ps(e, t, r) {
        var n, i = e.mutatedEvents.instances;
        for (n in i)
            if (!tn(t.validRange, i[n].range)) return !1;
        return vs({
            eventDrag: e
        }, r)
    }

    function ms(e, t, r) {
        return !!tn(t.validRange, e.range) && vs({
            dateSelection: e
        }, r)
    }

    function vs(e, t) {
        var r = t.getCurrentData(),
            r = Object.assign({
                businessHours: r.businessHours,
                dateSelection: "",
                eventStore: r.eventStore,
                eventUiBases: r.eventUiBases,
                eventSelection: "",
                eventDrag: null,
                eventResize: null
            }, e);
        return (t.pluginHooks.isPropsValid || ys)(r, t)
    }

    function ys(e, t, r = {}, n) {
        return !(e.eventDrag && !((e, t, r, n) => {
            let i = t.getCurrentData(),
                s = e.eventDrag,
                o = s.mutatedEvents,
                a = o.defs,
                l = o.instances,
                c = Xn(a, s.isEvent ? e.eventUiBases : {
                    "": i.selectionConfig
                });
            n && (c = O(c, n)), d = s.affectedEvents.instances;
            var d, u, h = {
                    defs: (n = e.eventStore).defs,
                    instances: xr(n.instances, e => !d[e.instanceId])
                },
                f = h.defs,
                g = h.instances,
                p = Xn(f, e.eventUiBases);
            for (u in l) {
                var m = l[u],
                    v = m.range,
                    y = c[m.defId],
                    b = a[m.defId];
                if (!bs(y.constraints, v, h, e.businessHours, t)) return;
                var S, E = t.options.eventOverlap,
                    C = "function" == typeof E ? E : null;
                for (S in g) {
                    var w = g[S];
                    if (en(v, w.range)) {
                        if (!1 === p[w.defId].overlap && s.isEvent) return;
                        if (!1 === y.overlap) return;
                        if (C && !C(new P(t, f[w.defId], w), new P(t, b, m))) return
                    }
                }
                var D, R = i.eventStore;
                for (D of y.allows) {
                    var A = Object.assign(Object.assign({}, r), {
                            range: m.range,
                            allDay: b.allDay
                        }),
                        x = R.defs[b.defId],
                        T = R.instances[u],
                        x = x ? new P(t, x, T) : new P(t, b);
                    if (!D(Ln(A, t), x)) return
                }
            }
            return 1
        })(e, t, r, n) || e.dateSelection && !((e, t, r, n) => {
            let i = e.eventStore,
                s = i.defs,
                o = i.instances,
                a = e.dateSelection,
                l = a.range,
                c = t.getCurrentData().selectionConfig;
            if (bs((c = n ? n(c) : c).constraints, l, i, e.businessHours, t)) {
                var d, u, n = t.options.selectOverlap,
                    h = "function" == typeof n ? n : null;
                for (d in o) {
                    var f = o[d];
                    if (en(l, f.range)) {
                        if (!1 === c.overlap) return;
                        if (h && !h(new P(t, s[f.defId], f), null)) return
                    }
                }
                for (u of c.allows) {
                    var g = Object.assign(Object.assign({}, r), a);
                    if (!u(Ln(g, t), null)) return
                }
                return 1
            }
        })(e, t, r, n))
    }

    function bs(e, t, r, n, i) {
        for (var s of e)
            if (!((e, t) => {
                    for (var r of e)
                        if (tn(r, t)) return 1
                })(((t, e, r, n, i) => "businessHours" === t ? Ss(cn(n, e, i)) : "string" == typeof t ? Ss(En(r, e => e.groupId === t)) : "object" == typeof t && t ? Ss(cn(t, e, i)) : [])(s, t, r, n, i), t)) return;
        return 1
    }

    function Ss(e) {
        var t, r = e.instances,
            n = [];
        for (t in r) n.push(r[t].range);
        return n
    }
    let Es = /^(visible|hidden)$/;
    class Cs extends s {
        constructor() {
            super(...arguments), this.handleEl = e => {
                this.el = e, o(this.props.elRef, e)
            }
        }
        render() {
            var e = this.props,
                {
                    liquid: t,
                    liquidIsAbsolute: r
                } = e,
                n = t && r,
                i = ["fc-scroller"];
            return t && i.push(r ? "fc-scroller-liquid-absolute" : "fc-scroller-liquid"), b("div", {
                ref: this.handleEl,
                className: i.join(" "),
                style: {
                    overflowX: e.overflowX,
                    overflowY: e.overflowY,
                    left: n && -(e.overcomeLeft || 0) || "",
                    right: n && -(e.overcomeRight || 0) || "",
                    bottom: n && -(e.overcomeBottom || 0) || "",
                    marginLeft: !n && -(e.overcomeLeft || 0) || "",
                    marginRight: !n && -(e.overcomeRight || 0) || "",
                    marginBottom: !n && -(e.overcomeBottom || 0) || "",
                    maxHeight: e.maxHeight || ""
                }
            }, e.children)
        }
        needsXScrolling() {
            if (!Es.test(this.props.overflowX)) {
                var e = this.el,
                    t = this.el.getBoundingClientRect().width - this.getYScrollbarWidth(),
                    r = e.children;
                for (let e = 0; e < r.length; e += 1)
                    if (r[e].getBoundingClientRect().width > t) return !0
            }
            return !1
        }
        needsYScrolling() {
            if (!Es.test(this.props.overflowY)) {
                var e = this.el,
                    t = this.el.getBoundingClientRect().height - this.getXScrollbarWidth(),
                    r = e.children;
                for (let e = 0; e < r.length; e += 1)
                    if (r[e].getBoundingClientRect().height > t) return !0
            }
            return !1
        }
        getXScrollbarWidth() {
            return Es.test(this.props.overflowX) ? 0 : this.el.offsetHeight - this.el.clientHeight
        }
        getYScrollbarWidth() {
            return Es.test(this.props.overflowY) ? 0 : this.el.offsetWidth - this.el.clientWidth
        }
    }
    class y {
        constructor(e) {
            this.masterCallback = e, this.currentMap = {}, this.depths = {}, this.callbackMap = {}, this.handleValue = (e, t) => {
                let {
                    depths: r,
                    currentMap: n
                } = this, i = !1, s = !1;
                null !== e ? (i = t in n, n[t] = e, r[t] = (r[t] || 0) + 1, s = !0) : (--r[t], r[t] || (delete n[t], delete this.callbackMap[t], i = !0)), this.masterCallback && (i && this.masterCallback(null, String(t)), s) && this.masterCallback(e, String(t))
            }
        }
        createRef(t) {
            let e = this.callbackMap[t];
            return e = e || (this.callbackMap[t] = e => {
                this.handleValue(e, String(t))
            })
        }
        collect(e, t, r) {
            return Ir(this.currentMap, e, t, r)
        }
        getAll() {
            return Mr(this.currentMap)
        }
    }

    function ws(e) {
        let t = Je(e, ".fc-scrollgrid-shrink"),
            r = 0;
        for (var n of t) r = Math.max(r, (e => {
            var t = e.querySelector(".fc-scrollgrid-shrink-frame"),
                r = e.querySelector(".fc-scrollgrid-shrink-cushion");
            if (!t) throw new Error("needs fc-scrollgrid-shrink-frame className");
            if (r) return e.getBoundingClientRect().width - t.getBoundingClientRect().width + r.getBoundingClientRect().width;
            throw new Error("needs fc-scrollgrid-shrink-cushion className")
        })(n));
        return Math.ceil(r)
    }

    function Ds(e, t) {
        return e.liquid && t.liquid
    }

    function Rs(e, t) {
        return null != t.maxHeight || Ds(e, t)
    }

    function As(e, t, r, n) {
        var i = r.expandRows;
        return "function" == typeof t.content ? t.content(r) : b("table", {
            role: "presentation",
            className: [t.tableClassName, e.syncRowHeights ? "fc-scrollgrid-sync-table" : ""].join(" "),
            style: {
                minWidth: r.tableMinWidth,
                width: r.clientWidth,
                height: i ? r.clientHeight : ""
            }
        }, r.tableColGroupNode, b(n ? "thead" : "tbody", {
            role: "presentation"
        }, "function" == typeof t.rowContent ? t.rowContent(r) : t.rowContent))
    }

    function xs(e, t) {
        return d(e, t, h)
    }

    function Ts(e, t) {
        var r, n = [];
        for (r of e) {
            var i = r.span || 1;
            for (let e = 0; e < i; e += 1) n.push(b("col", {
                style: {
                    width: "shrink" === r.width ? Ms(t) : r.width || "",
                    minWidth: r.minWidth || ""
                }
            }))
        }
        return b("colgroup", {}, ...n)
    }

    function Ms(e) {
        return null == e ? 4 : e
    }

    function ks(e) {
        for (var t of e)
            if ("shrink" === t.width) return !0;
        return !1
    }

    function _s(e, t) {
        t = ["fc-scrollgrid", t.theme.getClass("table")];
        return e && t.push("fc-scrollgrid-liquid"), t
    }

    function Is(e, t) {
        var r = ["fc-scrollgrid-section", "fc-scrollgrid-section-" + e.type, e.className];
        return t && e.liquid && null == e.maxHeight && r.push("fc-scrollgrid-section-liquid"), e.isSticky && r.push("fc-scrollgrid-section-sticky"), r
    }

    function Os(e) {
        return b("div", {
            className: "fc-scrollgrid-sticky-shim",
            style: {
                width: e.clientWidth,
                minWidth: e.tableMinWidth
            }
        })
    }

    function Ps(e) {
        let t = e.stickyHeaderDates;
        return t = null != t && "auto" !== t ? t : "auto" === e.height || "auto" === e.viewHeight
    }

    function Ns(e) {
        let t = e.stickyFooterScrollbar;
        return t = null != t && "auto" !== t ? t : "auto" === e.height || "auto" === e.viewHeight
    }
    class Hs extends s {
        constructor() {
            super(...arguments), this.processCols = f(e => e, xs), this.renderMicroColGroup = f(Ts), this.scrollerRefs = new y, this.scrollerElRefs = new y(this._handleScrollerEl.bind(this)), this.state = {
                shrinkWidth: null,
                forceYScrollbars: !1,
                scrollerClientWidths: {},
                scrollerClientHeights: {}
            }, this.handleSizing = () => {
                this.safeSetState(Object.assign({
                    shrinkWidth: this.computeShrinkWidth()
                }, this.computeScrollerDims()))
            }
        }
        render() {
            var {
                props: e,
                state: t,
                context: r
            } = this, n = e.sections || [], i = this.processCols(e.cols), s = this.renderMicroColGroup(i, t.shrinkWidth), i = _s(e.liquid, r);
            e.collapsibleWidth && i.push("fc-scrollgrid-collapsible");
            let o, a = n.length,
                l = 0,
                c = [],
                d = [],
                u = [];
            for (; l < a && "header" === (o = n[l]).type;) c.push(this.renderSection(o, s, !0)), l += 1;
            for (; l < a && "body" === (o = n[l]).type;) d.push(this.renderSection(o, s, !1)), l += 1;
            for (; l < a && "footer" === (o = n[l]).type;) u.push(this.renderSection(o, s, !0)), l += 1;
            t = !hi(), r = {
                role: "rowgroup"
            };
            return b("table", {
                role: "grid",
                className: i.join(" "),
                style: {
                    height: e.height
                }
            }, Boolean(!t && c.length) && b("thead", r, ...c), Boolean(!t && d.length) && b("tbody", r, ...d), Boolean(!t && u.length) && b("tfoot", r, ...u), t && b("tbody", r, ...c, ...d, ...u))
        }
        renderSection(e, t, r) {
            return "outerContent" in e ? b(A, {
                key: e.key
            }, e.outerContent) : b("tr", {
                key: e.key,
                role: "presentation",
                className: Is(e, this.props.liquid).join(" ")
            }, this.renderChunkTd(e, t, e.chunk, r))
        }
        renderChunkTd(e, t, r, n) {
            var i, s, o, a, l, c;
            return "outerContent" in r ? r.outerContent : (i = this.props, {
                forceYScrollbars: l,
                scrollerClientWidths: s,
                scrollerClientHeights: o
            } = this.state, c = Rs(i, e), a = Ds(i, e), l = i.liquid ? l ? "scroll" : c ? "auto" : "hidden" : "visible", c = e.key, t = As(e, r, {
                tableColGroupNode: t,
                tableMinWidth: "",
                clientWidth: i.collapsibleWidth || void 0 === s[c] ? null : s[c],
                clientHeight: void 0 !== o[c] ? o[c] : null,
                expandRows: e.expandRows,
                syncRowHeights: !1,
                rowSyncHeights: [],
                reportRowHeightChange: () => {}
            }, n), b(n ? "th" : "td", {
                ref: r.elRef,
                role: "presentation"
            }, b("div", {
                className: "fc-scroller-harness" + (a ? " fc-scroller-harness-liquid" : "")
            }, b(Cs, {
                ref: this.scrollerRefs.createRef(c),
                elRef: this.scrollerElRefs.createRef(c),
                overflowY: l,
                overflowX: i.liquid ? "hidden" : "visible",
                maxHeight: e.maxHeight,
                liquid: a,
                liquidIsAbsolute: !0
            }, t))))
        }
        _handleScrollerEl(e, t) {
            t = ((e, t) => {
                for (var r of e)
                    if (r.key === t) return r;
                return null
            })(this.props.sections, t);
            t && o(t.chunk.scrollerElRef, e)
        }
        componentDidMount() {
            this.handleSizing(), this.context.addResizeHandler(this.handleSizing)
        }
        componentDidUpdate() {
            this.handleSizing()
        }
        componentWillUnmount() {
            this.context.removeResizeHandler(this.handleSizing)
        }
        computeShrinkWidth() {
            return ks(this.props.cols) ? ws(this.scrollerElRefs.getAll()) : 0
        }
        computeScrollerDims() {
            let e = Hi(),
                {
                    scrollerRefs: t,
                    scrollerElRefs: r
                } = this,
                n = !1,
                i = {},
                s = {};
            for (var o in t.currentMap) {
                o = t.currentMap[o];
                if (o && o.needsYScrolling()) {
                    n = !0;
                    break
                }
            }
            for (var a of this.props.sections) {
                var a = a.key,
                    l = r.currentMap[a];
                l && (l = l.parentNode, i[a] = Math.floor(l.getBoundingClientRect().width - (n ? e.y : 0)), s[a] = Math.floor(l.getBoundingClientRect().height))
            }
            return {
                forceYScrollbars: n,
                scrollerClientWidths: i,
                scrollerClientHeights: s
            }
        }
    }
    Hs.addStateEquality({
        scrollerClientWidths: h,
        scrollerClientHeights: h
    });
    class Ws extends s {
        constructor() {
            super(...arguments), this.buildPublicEvent = f((e, t, r) => new P(e, t, r)), this.handleEl = e => {
                this.el = e, o(this.props.elRef, e), e && Qn(e, this.props.seg)
            }
        }
        render() {
            var {
                props: e,
                context: t
            } = this, r = t.options, n = e.seg, i = n.eventRange, s = i.ui, s = {
                event: this.buildPublicEvent(t, i.def, i.instance),
                view: t.viewApi,
                timeText: e.timeText,
                textColor: s.textColor,
                backgroundColor: s.backgroundColor,
                borderColor: s.borderColor,
                isDraggable: !e.disableDragging && ((e, t) => {
                    let r = t.pluginHooks,
                        n = r.isDraggableTransformers,
                        {
                            def: i,
                            ui: s
                        } = e.eventRange,
                        o = s.startEditable;
                    for (var a of n) o = a(o, i, s, t);
                    return o
                })(n, t),
                isStartResizable: !e.disableResizing && (i = t, (s = n).isStart) && s.eventRange.ui.durationEditable && i.options.eventResizableFromStart,
                isEndResizable: !e.disableResizing && (t = n).isEnd && t.eventRange.ui.durationEditable,
                isMirror: Boolean(e.isDragging || e.isResizing || e.isDateSelecting),
                isStart: Boolean(n.isStart),
                isEnd: Boolean(n.isEnd),
                isPast: Boolean(e.isPast),
                isFuture: Boolean(e.isFuture),
                isToday: Boolean(e.isToday),
                isSelected: Boolean(e.isSelected),
                isDragging: Boolean(e.isDragging),
                isResizing: Boolean(e.isResizing)
            };
            return b(g, {
                elRef: this.handleEl,
                elTag: e.elTag,
                elAttrs: e.elAttrs,
                elClasses: [...(i = ["fc-event"], (t = s).isMirror && i.push("fc-event-mirror"), t.isDraggable && i.push("fc-event-draggable"), (t.isStartResizable || t.isEndResizable) && i.push("fc-event-resizable"), t.isDragging && i.push("fc-event-dragging"), t.isResizing && i.push("fc-event-resizing"), t.isSelected && i.push("fc-event-selected"), t.isStart && i.push("fc-event-start"), t.isEnd && i.push("fc-event-end"), t.isPast && i.push("fc-event-past"), t.isToday && i.push("fc-event-today"), t.isFuture && i.push("fc-event-future"), i), ...n.eventRange.ui.classNames, ...e.elClasses || []],
                elStyle: e.elStyle,
                renderProps: s,
                generatorName: "eventContent",
                customGenerator: r.eventContent,
                defaultGenerator: e.defaultGenerator,
                classNameGenerator: r.eventClassNames,
                didMount: r.eventDidMount,
                willUnmount: r.eventWillUnmount
            }, e.children)
        }
        componentDidUpdate(e) {
            this.el && this.props.seg !== e.seg && Qn(this.el, this.props.seg)
        }
    }
    class Bs extends s {
        render() {
            var {
                props: e,
                context: t
            } = this, r = t.options, n = e.seg, i = n.eventRange.ui, r = ei(n, r.eventTimeFormat || e.defaultTimeFormat, t, e.defaultDisplayEventTime, e.defaultDisplayEventEnd);
            return b(Ws, Object.assign({}, e, {
                elTag: "a",
                elStyle: {
                    borderColor: i.borderColor,
                    backgroundColor: i.backgroundColor
                },
                elAttrs: ri(n, t),
                defaultGenerator: js,
                timeText: r
            }), (e, t) => b(A, null, b(e, {
                elTag: "div",
                elClasses: ["fc-event-main"],
                elStyle: {
                    color: t.textColor
                }
            }), Boolean(t.isStartResizable) && b("div", {
                className: "fc-event-resizer fc-event-resizer-start"
            }), Boolean(t.isEndResizable) && b("div", {
                className: "fc-event-resizer fc-event-resizer-end"
            })))
        }
    }

    function js(e) {
        return b("div", {
            className: "fc-event-main-frame"
        }, e.timeText && b("div", {
            className: "fc-event-time"
        }, e.timeText), b("div", {
            className: "fc-event-title-container"
        }, b("div", {
            className: "fc-event-title fc-sticky"
        }, e.event.title || b(A, null, ""))))
    }
    Bs.addPropsEquality({
        seg: h
    });
    let Ls = r => b(u.Consumer, null, e => {
            var t = e.options,
                e = {
                    isAxis: r.isAxis,
                    date: e.dateEnv.toDate(r.date),
                    view: e.viewApi
                };
            return b(g, {
                elRef: r.elRef,
                elTag: r.elTag || "div",
                elAttrs: r.elAttrs,
                elClasses: r.elClasses,
                elStyle: r.elStyle,
                renderProps: e,
                generatorName: "nowIndicatorContent",
                customGenerator: t.nowIndicatorContent,
                classNameGenerator: t.nowIndicatorClassNames,
                didMount: t.nowIndicatorDidMount,
                willUnmount: t.nowIndicatorWillUnmount
            }, r.children)
        }),
        zs = I({
            day: "numeric"
        });
    class Us extends s {
        constructor() {
            super(...arguments), this.refineRenderProps = $t(Fs)
        }
        render() {
            var {
                props: e,
                context: t
            } = this, r = t.options, n = this.refineRenderProps({
                date: e.date,
                dateProfile: e.dateProfile,
                todayRange: e.todayRange,
                isMonthStart: e.isMonthStart || !1,
                showDayNumber: e.showDayNumber,
                extraRenderProps: e.extraRenderProps,
                viewApi: t.viewApi,
                dateEnv: t.dateEnv,
                monthStartFormat: r.monthStartFormat
            });
            return b(g, {
                elRef: e.elRef,
                elTag: e.elTag,
                elAttrs: Object.assign(Object.assign({}, e.elAttrs), n.isDisabled ? {} : {
                    "data-date": Zt(e.date)
                }),
                elClasses: [...Ti(n, t.theme), ...e.elClasses || []],
                elStyle: e.elStyle,
                renderProps: n,
                generatorName: "dayCellContent",
                customGenerator: r.dayCellContent,
                defaultGenerator: e.defaultGenerator,
                classNameGenerator: n.isDisabled ? void 0 : r.dayCellClassNames,
                didMount: r.dayCellDidMount,
                willUnmount: r.dayCellWillUnmount
            }, e.children)
        }
    }

    function Gs(e) {
        return Boolean(e.dayCellContent || Vr("dayCellContent", e))
    }

    function Fs(e) {
        var {
            date: t,
            dateEnv: r,
            dateProfile: n,
            isMonthStart: i
        } = e, n = xi(t, e.todayRange, null, n), s = e.showDayNumber ? r.format(t, i ? e.monthStartFormat : zs) : "";
        return Object.assign(Object.assign(Object.assign({
            date: r.toDate(t),
            view: e.viewApi
        }, n), {
            isMonthStart: i,
            dayNumberText: s
        }), e.extraRenderProps)
    }
    class Vs extends s {
        render() {
            var e = this.props,
                t = e.seg;
            return b(Ws, {
                elTag: "div",
                elClasses: ["fc-bg-event"],
                elStyle: {
                    backgroundColor: t.eventRange.ui.backgroundColor
                },
                defaultGenerator: qs,
                seg: t,
                timeText: "",
                isDragging: !1,
                isResizing: !1,
                isDateSelecting: !1,
                isSelected: !1,
                isPast: e.isPast,
                isFuture: e.isFuture,
                isToday: e.isToday,
                disableDragging: !0,
                disableResizing: !0
            })
        }
    }

    function qs(e) {
        var t = e.event.title;
        return t && b("div", {
            className: "fc-event-title"
        }, e.event.title)
    }

    function Ys(e) {
        return b("div", {
            className: "fc-" + e
        })
    }
    let Qs = i => b(u.Consumer, null, e => {
        var {
            dateEnv: e,
            options: t
        } = e, r = i.date, n = t.weekNumberFormat || i.defaultFormat, e = {
            num: e.computeWeekNumber(r),
            text: e.format(r, n),
            date: r
        };
        return b(g, {
            elRef: i.elRef,
            elTag: i.elTag,
            elAttrs: i.elAttrs,
            elClasses: i.elClasses,
            elStyle: i.elStyle,
            renderProps: e,
            generatorName: "weekNumberContent",
            customGenerator: t.weekNumberContent,
            defaultGenerator: Zs,
            classNameGenerator: t.weekNumberClassNames,
            didMount: t.weekNumberDidMount,
            willUnmount: t.weekNumberWillUnmount
        }, i.children)
    });

    function Zs(e) {
        return e.text
    }
    class Xs extends s {
        constructor() {
            super(...arguments), this.state = {
                titleId: t()
            }, this.handleRootEl = e => {
                this.rootEl = e, this.props.elRef && o(this.props.elRef, e)
            }, this.handleDocumentMouseDown = e => {
                e = rt(e);
                this.rootEl.contains(e) || this.handleCloseClick()
            }, this.handleDocumentKeyDown = e => {
                "Escape" === e.key && this.handleCloseClick()
            }, this.handleCloseClick = () => {
                var e = this.props.onClose;
                e && e()
            }
        }
        render() {
            var {
                theme: e,
                options: t
            } = this.context, {
                props: r,
                state: n
            } = this, i = ["fc-popover", e.getClass("popover")].concat(r.extraClassNames || []), i = b("div", Object.assign({}, r.extraAttrs, {
                id: r.id,
                className: i.join(" "),
                "aria-labelledby": n.titleId,
                ref: this.handleRootEl
            }), b("div", {
                className: "fc-popover-header " + e.getClass("popoverHeader")
            }, b("span", {
                className: "fc-popover-title",
                id: n.titleId
            }, r.title), b("span", {
                className: "fc-popover-close " + e.getIconClass("close"),
                title: t.closeHint,
                onClick: this.handleCloseClick
            })), b("div", {
                className: "fc-popover-body " + e.getClass("popoverContent")
            }, r.children)), n = r.parentEl;
            return (i = b(_e, {
                __v: i,
                i: n
            })).containerInfo = n, i
        }
        componentDidMount() {
            document.addEventListener("mousedown", this.handleDocumentMouseDown), document.addEventListener("keydown", this.handleDocumentKeyDown), this.updateSize()
        }
        componentWillUnmount() {
            document.removeEventListener("mousedown", this.handleDocumentMouseDown), document.removeEventListener("keydown", this.handleDocumentKeyDown)
        }
        updateSize() {
            var e, t = this.context.isRtl,
                {
                    alignmentEl: r,
                    alignGridTop: n
                } = this.props,
                i = this.rootEl,
                s = (e => {
                    let t = zi(e),
                        r = e.getBoundingClientRect();
                    for (var n of t) {
                        n = bi(r, n.getBoundingClientRect());
                        if (!n) return null;
                        r = n
                    }
                    return r
                })(r);
            s && (e = i.getBoundingClientRect(), n = (n ? l(r, ".fc-scrollgrid").getBoundingClientRect() : s).top, r = t ? s.right - e.width : s.left, n = Math.max(n, 10), r = Math.min(r, document.documentElement.clientWidth - 10 - e.width), r = Math.max(r, 10), t = i.offsetParent.getBoundingClientRect(), et(i, {
                top: n - t.top,
                left: r - t.left
            }))
        }
    }
    class Js extends a {
        constructor() {
            super(...arguments), this.handleRootEl = e => {
                (this.rootEl = e) ? this.context.registerInteractiveComponent(this, {
                    el: e,
                    useEventCenter: !1
                }): this.context.unregisterInteractiveComponent(this)
            }
        }
        render() {
            let {
                options: n,
                dateEnv: e
            } = this.context, i = this.props, {
                startDate: t,
                todayRange: r,
                dateProfile: s
            } = i, o = e.format(t, n.dayPopoverFormat);
            return b(Us, {
                elRef: this.handleRootEl,
                date: t,
                dateProfile: s,
                todayRange: r
            }, (e, t, r) => b(Xs, {
                elRef: r.ref,
                id: i.id,
                title: o,
                extraClassNames: ["fc-more-popover"].concat(r.className || []),
                extraAttrs: r,
                parentEl: i.parentEl,
                alignmentEl: i.alignmentEl,
                alignGridTop: i.alignGridTop,
                onClose: i.onClose
            }, Gs(n) && b(e, {
                elTag: "div",
                elClasses: ["fc-more-popover-misc"]
            }), i.children))
        }
        queryHit(e, t, r, n) {
            var {
                rootEl: i,
                props: s
            } = this;
            return 0 <= e && e < r && 0 <= t && t < n ? {
                dateProfile: s.dateProfile,
                dateSpan: Object.assign({
                    allDay: !s.forceTimed,
                    range: {
                        start: s.startDate,
                        end: s.endDate
                    }
                }, s.extraDateSpan),
                dayEl: i,
                rect: {
                    left: 0,
                    top: 0,
                    right: r,
                    bottom: n
                },
                layer: 1
            } : null
        }
    }
    class Ks extends s {
        constructor() {
            super(...arguments), this.state = {
                isPopoverOpen: !1,
                popoverId: t()
            }, this.handleLinkEl = e => {
                this.linkEl = e, this.props.elRef && o(this.props.elRef, e)
            }, this.handleClick = e => {
                let {
                    props: t,
                    context: i
                } = this, r = i.options.moreLinkClick, n = eo(t).start;

                function s(e) {
                    var {
                        def: t,
                        instance: r,
                        range: n
                    } = e.eventRange;
                    return {
                        event: new P(i, t, r),
                        start: i.dateEnv.toDate(n.start),
                        end: i.dateEnv.toDate(n.end),
                        isStart: e.isStart,
                        isEnd: e.isEnd
                    }
                }(r = "function" == typeof r ? r({
                    date: n,
                    allDay: Boolean(t.allDayDate),
                    allSegs: t.allSegs.map(s),
                    hiddenSegs: t.hiddenSegs.map(s),
                    jsEvent: e,
                    view: i.viewApi
                }) : r) && "popover" !== r ? "string" == typeof r && i.calendarApi.zoomTo(n, r) : this.setState({
                    isPopoverOpen: !0
                })
            }, this.handlePopoverClose = () => {
                this.setState({
                    isPopoverOpen: !1
                })
            }
        }
        render() {
            let {
                props: o,
                state: a
            } = this;
            return b(u.Consumer, null, e => {
                var {
                    viewApi: e,
                    options: t,
                    calendarApi: r
                } = e, n = t.moreLinkText, i = o.moreCnt, s = eo(o), r = "function" == typeof n ? n.call(r, i) : `+${i} ` + n, n = St(t.moreLinkHint, [i], r), i = {
                    num: i,
                    shortText: "+" + i,
                    text: r,
                    view: e
                };
                return b(A, null, Boolean(o.moreCnt) && b(g, {
                    elTag: o.elTag || "a",
                    elRef: this.handleLinkEl,
                    elClasses: [...o.elClasses || [], "fc-more-link"],
                    elStyle: o.elStyle,
                    elAttrs: Object.assign(Object.assign(Object.assign({}, o.elAttrs), lt(this.handleClick)), {
                        title: n,
                        "aria-expanded": a.isPopoverOpen,
                        "aria-controls": a.isPopoverOpen ? a.popoverId : ""
                    }),
                    renderProps: i,
                    generatorName: "moreLinkContent",
                    customGenerator: t.moreLinkContent,
                    defaultGenerator: o.defaultGenerator || $s,
                    classNameGenerator: t.moreLinkClassNames,
                    didMount: t.moreLinkDidMount,
                    willUnmount: t.moreLinkWillUnmount
                }, o.children), a.isPopoverOpen && b(Js, {
                    id: a.popoverId,
                    startDate: s.start,
                    endDate: s.end,
                    dateProfile: o.dateProfile,
                    todayRange: o.todayRange,
                    extraDateSpan: o.extraDateSpan,
                    parentEl: this.parentEl,
                    alignmentEl: o.alignmentElRef ? o.alignmentElRef.current : this.linkEl,
                    alignGridTop: o.alignGridTop,
                    forceTimed: o.forceTimed,
                    onClose: this.handlePopoverClose
                }, o.popoverContent()))
            })
        }
        componentDidMount() {
            this.updateParentEl()
        }
        componentDidUpdate() {
            this.updateParentEl()
        }
        updateParentEl() {
            this.linkEl && (this.parentEl = l(this.linkEl, ".fc-view-harness"))
        }
    }

    function $s(e) {
        return e.text
    }

    function eo(e) {
        return e.allDayDate ? {
            start: e.allDayDate,
            end: _(e.allDayDate, 1)
        } : (e = e.hiddenSegs, {
            start: to(e),
            end: e.reduce(no).eventRange.range.end
        })
    }

    function to(e) {
        return e.reduce(ro).eventRange.range.start
    }

    function ro(e, t) {
        return e.eventRange.range.start < t.eventRange.range.start ? e : t
    }

    function no(e, t) {
        return e.eventRange.range.end > t.eventRange.range.end ? e : t
    }
    let io = {
            __proto__: null,
            BASE_OPTION_DEFAULTS: mr,
            BaseComponent: s,
            BgEvent: Vs,
            CalendarImpl: vi,
            CalendarRoot: fi,
            ContentContainer: g,
            CustomRenderingStore: class extends class {
                constructor() {
                    this.handlers = []
                }
                set(e) {
                    this.currentValue = e;
                    for (var t of this.handlers) t(e)
                }
                subscribe(e) {
                    this.handlers.push(e), void 0 !== this.currentValue && e(this.currentValue)
                }
            } {
                constructor() {
                    super(...arguments), this.map = new Map
                }
                handle(e) {
                    var t = this.map;
                    let r = !1;
                    e.isActive ? (t.set(e.id, e), r = !0) : t.has(e.id) && (t.delete(e.id), r = !0), r && this.set(t)
                }
            },
            DateComponent: a,
            DateEnv: Hr,
            DateProfileGenerator: an,
            DayCellContainer: Us,
            DayHeader: cs,
            DaySeriesModel: us,
            DayTableModel: hs,
            DelayedRunner: Qe,
            ElementDragging: es,
            ElementScrollController: Vi,
            Emitter: Hn,
            EventContainer: Ws,
            EventImpl: P,
            Interaction: gi,
            MoreLinkContainer: Ks,
            NamedTimeZoneImpl: class {
                constructor(e) {
                    this.timeZoneName = e
                }
            },
            NowIndicatorContainer: Ls,
            NowTimer: m,
            PositionCache: Ui,
            RefMap: y,
            ScrollController: Fi,
            ScrollResponder: zr,
            Scroller: Cs,
            SegHierarchy: Yi,
            SimpleScrollGrid: Hs,
            Slicer: fs,
            Splitter: Ri,
            StandardEvent: Bs,
            TableDateCell: os,
            TableDowCell: ls,
            Theme: Wr,
            ViewContainer: Zr,
            ViewContextType: u,
            WeekNumberContainer: Qs,
            WindowScrollController: qi,
            addDays: _,
            addDurations: xt,
            addMs: p,
            addWeeks: Ht,
            allowContextMenu: mt,
            allowSelection: gt,
            applyMutationToEventStore: Un,
            applyStyle: et,
            asCleanDays: At,
            asRoughMinutes: kt,
            asRoughMs: k,
            asRoughSeconds: _t,
            binarySearch: $i,
            buildElAttrs: qr,
            buildEntryKey: Zi,
            buildEventApis: Vn,
            buildEventRangeKey: ti,
            buildIsoString: Qt,
            buildNavLinkAttrs: Ii,
            buildSegTimeText: ei,
            collectFromHash: Ir,
            combineEventUis: An,
            compareByFieldSpecs: yt,
            compareNumbers: Et,
            compareObjs: _r,
            computeEarliestSegStart: to,
            computeEdges: Bi,
            computeFallbackHeaderFormat: ns,
            computeInnerRect: ji,
            computeRect: Li,
            computeShrinkWidth: ws,
            computeVisibleDayRange: nn,
            config: N,
            constrainPoint: Ei,
            createDuration: M,
            createEmptyEventStore: function() {
                return {
                    defs: {},
                    instances: {}
                }
            },
            createEventInstance: ln,
            createEventUi: Rn,
            createFormatter: I,
            diffDates: on,
            diffDayAndTime: jt,
            diffDays: Bt,
            diffPoints: wi,
            diffWeeks: Wt,
            diffWholeDays: zt,
            diffWholeWeeks: Lt,
            disableCursor: ut,
            elementClosest: l,
            elementMatches: Xe,
            enableCursor: ht,
            eventTupleToStore: yn,
            filterHash: xr,
            findDirectChildren: Ke,
            findElements: Je,
            flexibleCompare: bt,
            formatDayString: Zt,
            formatIsoMonthStr: Xt,
            formatIsoTimeString: Jt,
            getAllowYScrolling: Rs,
            getCanVGrowWithinCell: hi,
            getClippingParents: zi,
            getDateMeta: xi,
            getDayClassNames: Ti,
            getDefaultEventEnd: zn,
            getElSeg: Zn,
            getEntrySpanEnd: Qi,
            getEventTargetViaRoot: rt,
            getIsRtlScrollbarOnLeft: Ni,
            getRectCenter: Ci,
            getRelevantEvents: bn,
            getScrollGridClassNames: _s,
            getScrollbarWidths: Hi,
            getSectionClassNames: Is,
            getSectionHasLiquidHeight: Ds,
            getSegAnchorAttrs: ri,
            getSegMeta: E,
            getSlotClassNames: Mi,
            getStickyFooterScrollbar: Ns,
            getStickyHeaderDates: Ps,
            getUniqueDomId: t,
            greatestDurationDenominator: Ot,
            groupIntersectingEntries: Xi,
            guid: c,
            hasBgRendering: Yn,
            hasCustomDayCellContent: Gs,
            hasShrinkWidth: ks,
            identity: r,
            injectStyles: Fe,
            interactionSettingsStore: mi,
            interactionSettingsToStore: pi,
            intersectRanges: D,
            intersectRects: bi,
            intersectSpans: Ji,
            isArraysEqual: d,
            isColPropsEqual: xs,
            isDateSelectionValid: ms,
            isDateSpansEqual: si,
            isInt: Ct,
            isInteractionValid: ps,
            isMultiDayRange: sn,
            isPropsEqual: h,
            isPropsValid: ys,
            isValidDate: qt,
            mapHash: O,
            memoize: f,
            memoizeArraylike: er,
            memoizeHashlike: tr,
            memoizeObjArg: $t,
            mergeEventStores: Sn,
            multiplyDuration: Tt,
            padStart: T,
            parseBusinessHours: Bn,
            parseClassNames: Cn,
            parseDragMeta: rs,
            parseEventDef: mn,
            parseFieldSpecs: vt,
            parseMarker: Nr,
            pointInsideRect: yi,
            preventContextMenu: pt,
            preventDefault: it,
            preventSelection: ft,
            rangeContainsMarker: S,
            rangeContainsRange: tn,
            rangesEqual: $r,
            rangesIntersect: en,
            refineEventDef: gn,
            refineProps: Dr,
            removeElement: Ze,
            removeExact: Pt,
            renderChunkContent: As,
            renderFill: Ys,
            renderMicroColGroup: Ts,
            renderScrollShim: Os,
            requestJson: di,
            sanitizeShrinkWidth: Ms,
            setRef: o,
            sliceEventStore: qn,
            sortEventSegs: Kn,
            startOfDay: v,
            translateRect: Si,
            triggerDateSelect: jn,
            unpromisify: li,
            whenTransitionDone: at,
            wholeDivideDurations: It
        },
        so = [],
        oo = {
            code: "en",
            week: {
                dow: 0,
                doy: 4
            },
            direction: "ltr",
            buttonText: {
                prev: "prev",
                next: "next",
                prevYear: "prev year",
                nextYear: "next year",
                year: "year",
                today: "today",
                month: "month",
                week: "week",
                day: "day",
                list: "list"
            },
            weekText: "W",
            weekTextLong: "Week",
            closeHint: "Close",
            timeHint: "Time",
            eventHint: "Event",
            allDayText: "all-day",
            moreLinkText: "more",
            noEventsText: "No events to display"
        },
        ao = Object.assign(Object.assign({}, oo), {
            buttonHints: {
                prev: "Previous $0",
                next: "Next $0",
                today: (e, t) => "day" === t ? "Today" : "This " + e
            },
            viewHint: "$0 view",
            navLinkHint: "Go to $0",
            moreLinkHint: e => `Show ${e} more event` + (1 === e ? "" : "s")
        });

    function lo(e) {
        var t, r = 0 < e.length ? e[0].code : "en",
            e = so.concat(e),
            n = {
                en: ao
            };
        for (t of e) n[t.code] = t;
        return {
            map: n,
            defaultCode: r
        }
    }

    function co(e, t) {
        return "object" != typeof e || Array.isArray(e) ? (t = t, n = [].concat((r = e) || []), uo(r, n, ((t, r) => {
            for (let e = 0; e < t.length; e += 1) {
                var n = t[e].toLocaleLowerCase().split("-");
                for (let e = n.length; 0 < e; --e) {
                    var i = n.slice(0, e).join("-");
                    if (r[i]) return r[i]
                }
            }
            return null
        })(n, t) || ao)) : uo(e.code, [e.code], e);
        var r, n
    }

    function uo(e, t, r) {
        var r = Ar([oo, r], ["buttonText"]),
            n = (delete r.code, r).week;
        return delete r.week, {
            codeArg: e,
            codes: t,
            week: n,
            simpleNumberFormat: new Intl.NumberFormat(e),
            options: r
        }
    }

    function C(e) {
        return {
            id: c(),
            name: e.name,
            premiumReleaseDate: e.premiumReleaseDate ? new Date(e.premiumReleaseDate) : void 0,
            deps: e.deps || [],
            reducers: e.reducers || [],
            isLoadingFuncs: e.isLoadingFuncs || [],
            contextInit: [].concat(e.contextInit || []),
            eventRefiners: e.eventRefiners || {},
            eventDefMemberAdders: e.eventDefMemberAdders || [],
            eventSourceRefiners: e.eventSourceRefiners || {},
            isDraggableTransformers: e.isDraggableTransformers || [],
            eventDragMutationMassagers: e.eventDragMutationMassagers || [],
            eventDefMutationAppliers: e.eventDefMutationAppliers || [],
            dateSelectionTransformers: e.dateSelectionTransformers || [],
            datePointTransforms: e.datePointTransforms || [],
            dateSpanTransforms: e.dateSpanTransforms || [],
            views: e.views || {},
            viewPropsTransformers: e.viewPropsTransformers || [],
            isPropsValid: e.isPropsValid || null,
            externalDefTransforms: e.externalDefTransforms || [],
            viewContainerAppends: e.viewContainerAppends || [],
            eventDropTransformers: e.eventDropTransformers || [],
            componentInteractions: e.componentInteractions || [],
            calendarInteractions: e.calendarInteractions || [],
            themeClasses: e.themeClasses || {},
            eventSourceDefs: e.eventSourceDefs || [],
            cmdFormatter: e.cmdFormatter,
            recurringTypes: e.recurringTypes || [],
            namedTimeZonedImpl: e.namedTimeZonedImpl,
            initialView: e.initialView || "",
            elementDraggingImpl: e.elementDraggingImpl,
            optionChangeHandlers: e.optionChangeHandlers || {},
            scrollGridImpl: e.scrollGridImpl || null,
            listenerRefiners: e.listenerRefiners || {},
            optionRefiners: e.optionRefiners || {},
            propSetHandlers: e.propSetHandlers || {}
        }
    }

    function ho() {
        let r, n = [],
            i = [];
        return (t, e) => (r && d(t, n) && d(e, i) || (r = (e => {
            let a = {},
                l = {
                    premiumReleaseDate: void 0,
                    reducers: [],
                    isLoadingFuncs: [],
                    contextInit: [],
                    eventRefiners: {},
                    eventDefMemberAdders: [],
                    eventSourceRefiners: {},
                    isDraggableTransformers: [],
                    eventDragMutationMassagers: [],
                    eventDefMutationAppliers: [],
                    dateSelectionTransformers: [],
                    datePointTransforms: [],
                    dateSpanTransforms: [],
                    views: {},
                    viewPropsTransformers: [],
                    isPropsValid: null,
                    externalDefTransforms: [],
                    viewContainerAppends: [],
                    eventDropTransformers: [],
                    componentInteractions: [],
                    calendarInteractions: [],
                    themeClasses: {},
                    eventSourceDefs: [],
                    cmdFormatter: null,
                    recurringTypes: [],
                    namedTimeZonedImpl: null,
                    initialView: "",
                    elementDraggingImpl: null,
                    optionChangeHandlers: {},
                    scrollGridImpl: null,
                    listenerRefiners: {},
                    optionRefiners: {},
                    propSetHandlers: {}
                };

            function c(e) {
                for (var r of e) {
                    let e = r.name,
                        t = a[e];
                    void 0 === t ? (a[e] = r.id, c(r.deps), o = r, l = {
                        premiumReleaseDate: (n = (s = l).premiumReleaseDate, i = o.premiumReleaseDate, void 0 === n ? i : void 0 === i ? n : new Date(Math.max(n.valueOf(), i.valueOf()))),
                        reducers: s.reducers.concat(o.reducers),
                        isLoadingFuncs: s.isLoadingFuncs.concat(o.isLoadingFuncs),
                        contextInit: s.contextInit.concat(o.contextInit),
                        eventRefiners: Object.assign(Object.assign({}, s.eventRefiners), o.eventRefiners),
                        eventDefMemberAdders: s.eventDefMemberAdders.concat(o.eventDefMemberAdders),
                        eventSourceRefiners: Object.assign(Object.assign({}, s.eventSourceRefiners), o.eventSourceRefiners),
                        isDraggableTransformers: s.isDraggableTransformers.concat(o.isDraggableTransformers),
                        eventDragMutationMassagers: s.eventDragMutationMassagers.concat(o.eventDragMutationMassagers),
                        eventDefMutationAppliers: s.eventDefMutationAppliers.concat(o.eventDefMutationAppliers),
                        dateSelectionTransformers: s.dateSelectionTransformers.concat(o.dateSelectionTransformers),
                        datePointTransforms: s.datePointTransforms.concat(o.datePointTransforms),
                        dateSpanTransforms: s.dateSpanTransforms.concat(o.dateSpanTransforms),
                        views: Object.assign(Object.assign({}, s.views), o.views),
                        viewPropsTransformers: s.viewPropsTransformers.concat(o.viewPropsTransformers),
                        isPropsValid: o.isPropsValid || s.isPropsValid,
                        externalDefTransforms: s.externalDefTransforms.concat(o.externalDefTransforms),
                        viewContainerAppends: s.viewContainerAppends.concat(o.viewContainerAppends),
                        eventDropTransformers: s.eventDropTransformers.concat(o.eventDropTransformers),
                        calendarInteractions: s.calendarInteractions.concat(o.calendarInteractions),
                        componentInteractions: s.componentInteractions.concat(o.componentInteractions),
                        themeClasses: Object.assign(Object.assign({}, s.themeClasses), o.themeClasses),
                        eventSourceDefs: s.eventSourceDefs.concat(o.eventSourceDefs),
                        cmdFormatter: o.cmdFormatter || s.cmdFormatter,
                        recurringTypes: s.recurringTypes.concat(o.recurringTypes),
                        namedTimeZonedImpl: o.namedTimeZonedImpl || s.namedTimeZonedImpl,
                        initialView: s.initialView || o.initialView,
                        elementDraggingImpl: s.elementDraggingImpl || o.elementDraggingImpl,
                        optionChangeHandlers: Object.assign(Object.assign({}, s.optionChangeHandlers), o.optionChangeHandlers),
                        scrollGridImpl: o.scrollGridImpl || s.scrollGridImpl,
                        listenerRefiners: Object.assign(Object.assign({}, s.listenerRefiners), o.listenerRefiners),
                        optionRefiners: Object.assign(Object.assign({}, s.optionRefiners), o.optionRefiners),
                        propSetHandlers: Object.assign(Object.assign({}, s.propSetHandlers), o.propSetHandlers)
                    }) : t !== r.id && console.warn(`Duplicate plugin '${e}'`)
                }
                var n, i, s, o
            }
            return t && c(t), c(e), l
        })(e)), n = t, i = e, r)
    }
    class fo extends Wr {}

    function go(e, t, r, n) {
        return t[e] || ((r = ((e, t, r, n) => {
            let i = r[e],
                s = n[e],
                o = e => i && null !== i[e] ? i[e] : s && null !== s[e] ? s[e] : null,
                a = o("component"),
                l = o("superType"),
                c = null;
            if (l) {
                if (l === e) throw new Error("Can't have a custom view type that references itself");
                c = go(l, t, r, n)
            }
            return (a = !a && c ? c.component : a) ? {
                type: e,
                component: a,
                defaults: Object.assign(Object.assign({}, c ? c.defaults : {}), i ? i.rawOptions : {}),
                overrides: Object.assign(Object.assign({}, c ? c.overrides : {}), s ? s.rawOptions : {})
            } : null
        })(e, t, r, n)) && (t[e] = r), r)
    }

    function po(e) {
        return O(e, mo)
    }

    function mo(e) {
        let t = "function" == typeof e ? {
                component: e
            } : e,
            r = t.component;
        return t.content ? r = vo(t) : !r || r.prototype instanceof s || (r = vo(Object.assign(Object.assign({}, t), {
            content: r
        }))), {
            superType: t.type,
            component: r,
            rawOptions: t
        }
    }

    function vo(r) {
        return t => b(u.Consumer, null, e => b(g, {
            elTag: "div",
            elClasses: Xr(e.viewSpec),
            renderProps: Object.assign(Object.assign({}, t), {
                nextDayThreshold: e.options.nextDayThreshold
            }),
            generatorName: void 0,
            customGenerator: r.content,
            classNameGenerator: r.classNames,
            didMount: r.didMount,
            willUnmount: r.willUnmount
        }))
    }

    function yo(e, u, h, f) {
        let t = po(e),
            g = po(u.views);
        return O(((e, t) => {
            let r, n = {};
            for (r in e) go(r, n, e, t);
            for (r in t) go(r, n, e, t);
            return n
        })(t, g), s => {
            {
                var o = s,
                    a = (s = g, u),
                    l = h,
                    c = f;
                let e = o.overrides.duration || o.defaults.duration || l.duration || a.duration,
                    t = null,
                    r = "",
                    n = "",
                    i = {};
                e && (t = (e => {
                    let t = JSON.stringify(e),
                        r = bo[t];
                    return void 0 === r && (r = M(e), bo[t] = r), r
                })(e)) && (d = Ot(t), r = d.unit, 1 === d.value && (n = r, i = s[r] ? s[r].rawOptions : {}));
                var d = e => {
                        var e = e.buttonText || {},
                            t = o.defaults.buttonTextKey;
                        return null != t && null != e[t] ? e[t] : null != e[o.type] ? e[o.type] : null != e[n] ? e[n] : null
                    },
                    s = e => {
                        var e = e.buttonHints || {},
                            t = o.defaults.buttonTextKey;
                        return null != t && null != e[t] ? e[t] : null != e[o.type] ? e[o.type] : null != e[n] ? e[n] : null
                    };
                return {
                    type: o.type,
                    component: o.component,
                    duration: t,
                    durationUnit: r,
                    singleUnit: n,
                    optionDefaults: o.defaults,
                    optionOverrides: Object.assign(Object.assign({}, i), o.overrides),
                    buttonTextOverride: d(l) || d(a) || o.overrides.buttonText,
                    buttonTextDefault: d(c) || o.defaults.buttonText || d(mr) || o.type,
                    buttonTitleOverride: s(l) || s(a) || o.overrides.buttonHint,
                    buttonTitleDefault: s(c) || o.defaults.buttonHint || s(mr)
                }
            }
        })
    }
    fo.prototype.classes = {
        root: "fc-theme-standard",
        tableCellShaded: "fc-cell-shaded",
        buttonGroup: "fc-button-group",
        button: "fc-button fc-button-primary",
        buttonActive: "fc-button-active"
    }, fo.prototype.baseIconClass = "fc-icon", fo.prototype.iconClasses = {
        close: "fc-icon-x",
        prev: "fc-icon-chevron-left",
        next: "fc-icon-chevron-right",
        prevYear: "fc-icon-chevrons-left",
        nextYear: "fc-icon-chevrons-right"
    }, fo.prototype.rtlIconClasses = {
        prev: "fc-icon-chevron-right",
        next: "fc-icon-chevron-left",
        prevYear: "fc-icon-chevrons-right",
        nextYear: "fc-icon-chevrons-left"
    }, fo.prototype.iconOverrideOption = "buttonIcons", fo.prototype.iconOverrideCustomButtonOption = "icon", fo.prototype.iconOverridePrefix = "fc-icon-";
    let bo = {};

    function So(e, t, r) {
        t = t ? t.activeRange : null;
        return Co({}, ((e, t) => {
            var r, n = kn(t),
                i = [].concat(e.eventSources || []),
                s = [];
            e.initialEvents && i.unshift(e.initialEvents), e.events && i.unshift(e.events);
            for (r of i) {
                var o = Mn(r, t, n);
                o && s.push(o)
            }
            return s
        })(e, r), t, r)
    }

    function Eo(e) {
        for (var t in e)
            if (e[t].isFetching) return !0;
        return !1
    }

    function Co(e, t, r, n) {
        let i = {};
        for (var s of t) i[s.sourceId] = s;
        return r && (i = wo(i, r, n)), Object.assign(Object.assign({}, e), i)
    }

    function wo(e, t, r) {
        return Do(e, xr(e, e => Ao(e, r) ? !r.options.lazyFetching || !e.fetchRange || e.isFetching || t.start < e.fetchRange.start || t.end > e.fetchRange.end : !e.latestFetchId), t, !1, r)
    }

    function Do(e, t, r, n, i) {
        var s, o = {};
        for (s in e) {
            var a = e[s];
            t[s] ? o[s] = ((r, n, e, i) => {
                let {
                    options: s,
                    calendarApi: o
                } = i, t = i.pluginHooks.eventSourceDefs[r.sourceDefId], a = c();
                return t.fetch({
                    eventSource: r,
                    range: n,
                    isRefetch: e,
                    context: i
                }, e => {
                    let t = e.rawEvents;
                    s.eventSourceSuccess && (t = s.eventSourceSuccess.call(o, t, e.response) || t), r.success && (t = r.success.call(o, t, e.response) || t), i.dispatch({
                        type: "RECEIVE_EVENTS",
                        sourceId: r.sourceId,
                        fetchId: a,
                        fetchRange: n,
                        rawEvents: t
                    })
                }, e => {
                    let t = !1;
                    s.eventSourceFailure && (s.eventSourceFailure.call(o, e), t = !0), r.failure && (r.failure(e), t = !0), t || console.warn(e.message, e), i.dispatch({
                        type: "RECEIVE_EVENT_ERROR",
                        sourceId: r.sourceId,
                        fetchId: a,
                        fetchRange: n,
                        error: e
                    })
                }), Object.assign(Object.assign({}, r), {
                    isFetching: !0,
                    latestFetchId: a
                })
            })(a, r, n, i) : o[s] = a
        }
        return o
    }

    function Ro(e, t) {
        return xr(e, e => Ao(e, t))
    }

    function Ao(e, t) {
        return !t.pluginHooks.eventSourceDefs[e.sourceDefId].ignoreRange
    }

    function xo(e, t, r, n, i) {
        return {
            header: e.headerToolbar ? To(e.headerToolbar, e, t, r, n, i) : null,
            footer: e.footerToolbar ? To(e.footerToolbar, e, t, r, n, i) : null
        }
    }

    function To(e, t, r, n, i, s) {
        let o = {},
            a = [],
            l = !1;
        for (var c in e) {
            var d = ((e, l, t, c, d, u) => {
                let h = "rtl" === l.direction,
                    f = l.customButtons || {},
                    g = t.buttonText || {},
                    p = l.buttonText || {},
                    m = t.buttonHints || {},
                    v = l.buttonHints || {},
                    r = e ? e.split(" ") : [],
                    y = [],
                    b = !1;
                return {
                    widgets: r.map(e => e.split(",").map(t => {
                        if ("title" === t) return b = !0, {
                            buttonName: t
                        };
                        let r, e, n, i, s, o;
                        var a;
                        return (r = f[t]) ? (n = e => {
                            r.click && r.click.call(e.target, e, e.target)
                        }, (i = (i = c.getCustomButtonIconClass(r)) || c.getIconClass(t, h)) || (s = r.text), o = r.hint || r.text) : (e = d[t]) ? (y.push(t), n = () => {
                            u.changeView(t)
                        }, (s = e.buttonTextOverride) || (i = c.getIconClass(t, h)) || (s = e.buttonTextDefault), a = e.buttonTextOverride || e.buttonTextDefault, o = St(e.buttonTitleOverride || e.buttonTitleDefault || l.viewHint, [a, t], a)) : u[t] && (n = () => {
                            u[t]()
                        }, (s = g[t]) || (i = c.getIconClass(t, h)) || (s = p[t]), o = "prevYear" === t || "nextYear" === t ? (a = "prevYear" === t ? "prev" : "next", St(m[a] || v[a], [p.year || "year", "year"], p[t])) : e => St(m[t] || v[t], [p[e] || e, e], p[t])), {
                            buttonName: t,
                            buttonClick: n,
                            buttonIcon: i,
                            buttonText: s,
                            buttonHint: o
                        }
                    })),
                    viewsWithButtons: y,
                    hasTitle: b
                }
            })(e[c], t, r, n, i, s);
            o[c] = d.widgets, a.push(...d.viewsWithButtons), l = l || d.hasTitle
        }
        return {
            sectionWidgets: o,
            viewsWithButtons: a,
            hasTitle: l
        }
    }
    class Mo {
        constructor(e, t, r) {
            this.type = e, this.getCurrentData = t, this.dateEnv = r
        }
        get calendar() {
            return this.getCurrentData().calendarApi
        }
        get title() {
            return this.getCurrentData().viewTitle
        }
        get activeStart() {
            return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start)
        }
        get activeEnd() {
            return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end)
        }
        get currentStart() {
            return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start)
        }
        get currentEnd() {
            return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end)
        }
        getOption(e) {
            return this.getCurrentData().options[e]
        }
    }

    function ko(e, t) {
        var r = Mr(t.getCurrentData().eventSources);
        if (1 === r.length && 1 === e.length && Array.isArray(r[0]._raw) && Array.isArray(e[0])) t.dispatch({
            type: "RESET_RAW_EVENTS",
            sourceId: r[0].sourceId,
            rawEvents: e[0]
        });
        else {
            var n, i, s, o = [];
            for (n of e) {
                let t = !1;
                for (let e = 0; e < r.length; e += 1)
                    if (r[e]._raw === n) {
                        r.splice(e, 1), t = !0;
                        break
                    } t || o.push(n)
            }
            for (i of r) t.dispatch({
                type: "REMOVE_EVENT_SOURCE",
                sourceId: i.sourceId
            });
            for (s of o) t.calendarApi.addEventSource(s)
        }
    }
    let _o = [C({
        name: "array-event-source",
        eventSourceDefs: [{
            ignoreRange: !0,
            parseMeta: e => Array.isArray(e.events) ? e.events : null,
            fetch(e, t) {
                t({
                    rawEvents: e.eventSource.meta
                })
            }
        }]
    }), C({
        name: "func-event-source",
        eventSourceDefs: [{
            parseMeta: e => "function" == typeof e.events ? e.events : null,
            fetch(e, t, r) {
                var n = e.context.dateEnv;
                li(e.eventSource.meta.bind(null, oi(e.range, n)), e => t({
                    rawEvents: e
                }), r)
            }
        }]
    }), C({
        name: "json-event-source",
        eventSourceRefiners: {
            method: String,
            extraParams: r,
            startParam: String,
            endParam: String,
            timeZoneParam: String
        },
        eventSourceDefs: [{
            parseMeta: e => !e.url || "json" !== e.format && e.format ? null : {
                url: e.url,
                format: "json",
                method: (e.method || "GET").toUpperCase(),
                extraParams: e.extraParams,
                startParam: e.startParam,
                endParam: e.endParam,
                timeZoneParam: e.timeZoneParam
            },
            fetch(c, r, e) {
                var t = c.eventSource.meta,
                    n = ((e, t) => {
                        let r, n, i, s, {
                                dateEnv: o,
                                options: a
                            } = c.context,
                            l = {};
                        return null == (r = e.startParam) && (r = a.startParam), null == (n = e.endParam) && (n = a.endParam), null == (i = e.timeZoneParam) && (i = a.timeZoneParam), s = "function" == typeof e.extraParams ? e.extraParams() : e.extraParams || {}, Object.assign(l, s), l[r] = o.formatIso(t.start), l[n] = o.formatIso(t.end), "local" !== o.timeZone && (l[i] = o.timeZone), l
                    })(t, c.range);
                di(t.method, t.url, n).then(([e, t]) => {
                    r({
                        rawEvents: e,
                        response: t
                    })
                }, e)
            }
        }]
    }), C({
        name: "simple-recurring-event",
        recurringTypes: [{
            parse(r, n) {
                if (r.daysOfWeek || r.startTime || r.endTime || r.startRecur || r.endRecur) {
                    let e, t = {
                        daysOfWeek: r.daysOfWeek || null,
                        startTime: r.startTime || null,
                        endTime: r.endTime || null,
                        startRecur: r.startRecur ? n.createMarker(r.startRecur) : null,
                        endRecur: r.endRecur ? n.createMarker(r.endRecur) : null,
                        dateEnv: n
                    };
                    return !(e = r.duration ? r.duration : e) && r.startTime && r.endTime && (n = r.endTime, i = r.startTime, e = {
                        years: n.years - i.years,
                        months: n.months - i.months,
                        days: n.days - i.days,
                        milliseconds: n.milliseconds - i.milliseconds
                    }), {
                        allDayGuess: Boolean(!r.startTime && !r.endTime),
                        duration: e,
                        typeData: t
                    }
                }
                var i;
                return null
            },
            expand(i, s, o) {
                var a, s = D(s, {
                    start: i.startRecur,
                    end: i.endRecur
                });
                if (s) {
                    var l = i.daysOfWeek,
                        c = i.startTime,
                        d = i.dateEnv,
                        u = o,
                        i = s;
                    let e = l ? Tr(l) : null,
                        t = v(i.start),
                        r = i.end,
                        n = [];
                    for (; t < r;) e && !e[t.getUTCDay()] || (a = c ? u.add(t, c) : t, n.push(u.createMarker(d.toDate(a)))), t = _(t, 1);
                    return n
                }
                return []
            }
        }],
        eventRefiners: {
            daysOfWeek: r,
            startTime: M,
            endTime: M,
            duration: M,
            startRecur: r,
            endRecur: r
        }
    }), C({
        name: "change-handler",
        optionChangeHandlers: {
            events(e, t) {
                ko([e], t)
            },
            eventSources: ko
        }
    }), C({
        name: "misc",
        isLoadingFuncs: [e => Eo(e.eventSources)],
        propSetHandlers: {
            dateProfile: function(e, t) {
                t.emitter.trigger("datesSet", Object.assign(Object.assign({}, oi(e.activeRange, t.dateEnv)), {
                    view: t.viewApi
                }))
            },
            eventStore: function(e, t) {
                var r = t.emitter;
                r.hasHandlers("eventsSet") && r.trigger("eventsSet", Vn(e, t))
            }
        }
    })];
    class Io {
        constructor(e, t) {
            this.runTaskOption = e, this.drainedOption = t, this.queue = [], this.delayedRunner = new Qe(this.drain.bind(this))
        }
        request(e, t) {
            this.queue.push(e), this.delayedRunner.request(t)
        }
        pause(e) {
            this.delayedRunner.pause(e)
        }
        resume(e, t) {
            this.delayedRunner.resume(e, t)
        }
        drain() {
            for (var e = this.queue; e.length;) {
                for (var t, r = []; t = e.shift();) this.runTask(t), r.push(t);
                this.drained(r)
            }
        }
        runTask(e) {
            this.runTaskOption && this.runTaskOption(e)
        }
        drained(e) {
            this.drainedOption && this.drainedOption(e)
        }
    }

    function Oo(e, t, r) {
        var n = /^(year|month)$/.test(e.currentRangeUnit) ? e.currentRange : e.activeRange;
        return r.formatRange(n.start, n.end, I(t.titleFormat || ("year" === (r = e.currentRangeUnit) ? {
            year: "numeric"
        } : "month" === r ? {
            year: "numeric",
            month: "long"
        } : null !== (r = zt(e.currentRange.start, e.currentRange.end)) && 1 < r ? {
            year: "numeric",
            month: "short",
            day: "numeric"
        } : {
            year: "numeric",
            month: "long",
            day: "numeric"
        })), {
            isEndExclusive: e.isRangeAllDay,
            defaultSeparator: t.titleRangeSeparator
        })
    }
    class Po {
        constructor() {
            this.resetListeners = new Set
        }
        handleInput(e, t) {
            var r = this.dateEnv;
            if (e !== r && ("function" == typeof t ? this.nowFn = t : r || (this.nowAnchorDate = e.toDate(t ? e.createMarker(t) : e.createNowMarker()), this.nowAnchorQueried = Date.now()), this.dateEnv = e, r))
                for (let e of this.resetListeners.values()) e()
        }
        getDateMarker() {
            return this.nowAnchorDate ? this.dateEnv.timestampToMarker(this.nowAnchorDate.valueOf() + (Date.now() - this.nowAnchorQueried)) : this.dateEnv.createMarker(this.nowFn())
        }
        addResetListener(e) {
            this.resetListeners.add(e)
        }
        removeResetListener(e) {
            this.resetListeners.delete(e)
        }
    }
    class No {
        constructor(e) {
            this.computeCurrentViewData = f(this._computeCurrentViewData), this.organizeRawLocales = f(lo), this.buildLocale = f(co), this.buildPluginHooks = ho(), this.buildDateEnv = f(Ho), this.buildTheme = f(Wo), this.parseToolbars = f(xo), this.buildViewSpecs = f(yo), this.buildDateProfileGenerator = $t(Bo), this.buildViewApi = f(jo), this.buildViewUiProps = $t(Uo), this.buildEventUiBySource = f(Lo, h), this.buildEventUiBases = f(zo), this.parseContextBusinessHours = $t(Fo), this.buildTitle = f(Oo), this.nowManager = new Po, this.emitter = new Hn, this.actionRunner = new Io(this._handleAction.bind(this), this.updateData.bind(this)), this.currentCalendarOptionsInput = {}, this.currentCalendarOptionsRefined = {}, this.currentViewOptionsInput = {}, this.currentViewOptionsRefined = {}, this.currentCalendarOptionsRefiners = {}, this.optionsForRefining = [], this.optionsForHandling = [], this.getCurrentData = () => this.data, this.dispatch = e => {
                this.actionRunner.request(e)
            }, this.props = e, this.actionRunner.pause(), this.nowManager = new Po;
            var t, r = {},
                n = this.computeOptionsData(e.optionOverrides, r, e.calendarApi),
                i = n.calendarOptions.initialView || n.pluginHooks.initialView,
                s = this.computeCurrentViewData(i, n, e.optionOverrides, r);
            (e.calendarApi.currentDataManager = this).emitter.setThisContext(e.calendarApi), this.emitter.setOptions(s.options);
            let o = {
                    nowManager: this.nowManager,
                    dateEnv: n.dateEnv,
                    options: n.calendarOptions,
                    pluginHooks: n.pluginHooks,
                    calendarApi: e.calendarApi,
                    dispatch: this.dispatch,
                    emitter: this.emitter,
                    getCurrentData: this.getCurrentData
                },
                a = ((e, t, r) => null != (e = e.initialDate) ? t.createMarker(e) : r.getDateMarker())(n.calendarOptions, n.dateEnv, this.nowManager),
                l = s.dateProfileGenerator.build(a);
            S(l.activeRange, a) || (a = l.currentRange.start);
            for (t of n.pluginHooks.contextInit) t(o);
            var c, e = So(n.calendarOptions, l, o),
                d = {
                    dynamicOptionOverrides: r,
                    currentViewType: i,
                    currentDate: a,
                    dateProfile: l,
                    businessHours: this.parseContextBusinessHours(o),
                    eventSources: e,
                    eventUiBases: {},
                    eventStore: {
                        defs: {},
                        instances: {}
                    },
                    renderableEventStore: {
                        defs: {},
                        instances: {}
                    },
                    dateSelection: null,
                    eventSelection: "",
                    eventDrag: null,
                    eventResize: null,
                    selectionConfig: this.buildViewUiProps(o).selectionConfig
                },
                u = Object.assign(Object.assign({}, o), d);
            for (c of n.pluginHooks.reducers) Object.assign(d, c(null, null, u));
            Go(d, o) && this.emitter.trigger("loading", !0), this.state = d, this.updateData(), this.actionRunner.resume()
        }
        resetOptions(e, t) {
            var r = this.props;
            void 0 === t ? r.optionOverrides = e : (r.optionOverrides = Object.assign(Object.assign({}, r.optionOverrides || {}), e), this.optionsForRefining.push(...t)), void 0 !== t && !t.length || this.actionRunner.request({
                type: "NOTHING"
            })
        }
        _handleAction(e) {
            var {
                props: t,
                state: r,
                emitter: n
            } = this, i = (i = r.dynamicOptionOverrides, "SET_OPTION" !== (s = e).type ? i : Object.assign(Object.assign({}, i), {
                [s.optionName]: s.rawOptionValue
            })), s = this.computeOptionsData(t.optionOverrides, i, t.calendarApi), o = (o = r.currentViewType, o = "CHANGE_VIEW_TYPE" === e.type ? e.viewType : o), a = this.computeCurrentViewData(o, s, t.optionOverrides, i);
            t.calendarApi.currentDataManager = this, n.setThisContext(t.calendarApi), n.setOptions(a.options);
            let l = {
                    nowManager: this.nowManager,
                    dateEnv: s.dateEnv,
                    options: s.calendarOptions,
                    pluginHooks: s.pluginHooks,
                    calendarApi: t.calendarApi,
                    dispatch: this.dispatch,
                    emitter: n,
                    getCurrentData: this.getCurrentData
                },
                {
                    currentDate: c,
                    dateProfile: d
                } = r;
            this.data && this.data.dateProfileGenerator !== a.dateProfileGenerator && (d = a.dateProfileGenerator.build(c)), c = (h = c, "CHANGE_DATE" !== e.type ? h : e.dateMarker), d = ((e, t, r, n) => {
                let i;
                switch (t.type) {
                    case "CHANGE_VIEW_TYPE":
                        return n.build(t.dateMarker || r);
                    case "CHANGE_DATE":
                        return n.build(t.dateMarker);
                    case "PREV":
                        if ((i = n.buildPrev(e, r)).isValid) return i;
                        break;
                    case "NEXT":
                        if ((i = n.buildNext(e, r)).isValid) return i
                }
                return e
            })(d, e, c, a.dateProfileGenerator), "PREV" !== e.type && "NEXT" !== e.type && S(d.currentRange, c) || (c = d.currentRange.start);
            var u, h = ((e, t, r, n) => {
                    var i, s, o, a, l, c = r ? r.activeRange : null;
                    switch (t.type) {
                        case "ADD_EVENT_SOURCES":
                            return Co(e, t.sources, c, n);
                        case "REMOVE_EVENT_SOURCE":
                            return l = t.sourceId, xr(e, e => e.sourceId !== l);
                        case "PREV":
                        case "NEXT":
                        case "CHANGE_DATE":
                        case "CHANGE_VIEW_TYPE":
                            return r ? wo(e, c, n) : e;
                        case "FETCH_EVENT_SOURCES":
                            return Do(e, t.sourceIds ? Tr(t.sourceIds) : Ro(e, n), c, t.isRefetch || !1, n);
                        case "RECEIVE_EVENTS":
                        case "RECEIVE_EVENT_ERROR":
                            return i = e, s = t.sourceId, o = t.fetchRange, (a = i[s]) && t.fetchId === a.latestFetchId ? Object.assign(Object.assign({}, i), {
                                [s]: Object.assign(Object.assign({}, a), {
                                    isFetching: !1,
                                    fetchRange: o
                                })
                            }) : i;
                        case "REMOVE_ALL_EVENT_SOURCES":
                            return {};
                        default:
                            return e
                    }
                })(r.eventSources, e, d, l),
                f = _n(r.eventStore, e, h, d, l),
                a = Eo(h) && !a.options.progressiveEventRendering && r.renderableEventStore || f,
                {
                    eventUiSingleBase: g,
                    selectionConfig: p
                } = this.buildViewUiProps(l),
                m = this.buildEventUiBySource(h),
                v = {
                    dynamicOptionOverrides: i,
                    currentViewType: o,
                    currentDate: c,
                    dateProfile: d,
                    eventSources: h,
                    eventStore: f,
                    renderableEventStore: a,
                    selectionConfig: p,
                    eventUiBases: this.buildEventUiBases(a.defs, g, m),
                    businessHours: this.parseContextBusinessHours(l),
                    dateSelection: ((e, t) => {
                        switch (t.type) {
                            case "UNSELECT_DATES":
                                return null;
                            case "SELECT_DATES":
                                return t.selection;
                            default:
                                return e
                        }
                    })(r.dateSelection, e),
                    eventSelection: ((e, t) => {
                        switch (t.type) {
                            case "UNSELECT_EVENT":
                                return "";
                            case "SELECT_EVENT":
                                return t.eventInstanceId;
                            default:
                                return e
                        }
                    })(r.eventSelection, e),
                    eventDrag: ((e, t) => {
                        var r;
                        switch (t.type) {
                            case "UNSET_EVENT_DRAG":
                                return null;
                            case "SET_EVENT_DRAG":
                                return {
                                    affectedEvents: (r = t.state).affectedEvents, mutatedEvents: r.mutatedEvents, isEvent: r.isEvent
                                };
                            default:
                                return e
                        }
                    })(r.eventDrag, e),
                    eventResize: ((e, t) => {
                        var r;
                        switch (t.type) {
                            case "UNSET_EVENT_RESIZE":
                                return null;
                            case "SET_EVENT_RESIZE":
                                return {
                                    affectedEvents: (r = t.state).affectedEvents, mutatedEvents: r.mutatedEvents, isEvent: r.isEvent
                                };
                            default:
                                return e
                        }
                    })(r.eventResize, e)
                },
                y = Object.assign(Object.assign({}, l), v);
            for (u of s.pluginHooks.reducers) Object.assign(v, u(r, e, y));
            i = Go(r, l), o = Go(v, l);
            !i && o ? n.trigger("loading", !0) : i && !o && n.trigger("loading", !1), this.state = v, t.onAction && t.onAction(e)
        }
        updateData() {
            var {
                props: e,
                state: t
            } = this, r = this.data, n = this.computeOptionsData(e.optionOverrides, t.dynamicOptionOverrides, e.calendarApi), i = this.computeCurrentViewData(t.currentViewType, n, e.optionOverrides, t.dynamicOptionOverrides), s = this.data = Object.assign(Object.assign(Object.assign({
                nowManager: this.nowManager,
                viewTitle: this.buildTitle(t.dateProfile, i.options, n.dateEnv),
                calendarApi: e.calendarApi,
                dispatch: this.dispatch,
                emitter: this.emitter,
                getCurrentData: this.getCurrentData
            }, n), i), t), o = n.pluginHooks.optionChangeHandlers, a = r && r.calendarOptions, l = n.calendarOptions;
            if (a && a !== l)
                for (var c in a.timeZone !== l.timeZone && (t.eventSources = s.eventSources = ((e, t, r) => (t = t ? t.activeRange : null, Do(e, Ro(e, r), t, !0, r)))(s.eventSources, t.dateProfile, s), t.eventStore = s.eventStore = Pn(s.eventStore, r.dateEnv, s.dateEnv), t.renderableEventStore = s.renderableEventStore = Pn(s.renderableEventStore, r.dateEnv, s.dateEnv)), o) - 1 === this.optionsForHandling.indexOf(c) && a[c] === l[c] || o[c](l[c], s);
            this.optionsForHandling = [], e.onData && e.onData(s)
        }
        computeOptionsData(e, t, r) {
            var n, i, s, o, a;
            return this.optionsForRefining.length || e !== this.stableOptionOverrides || t !== this.stableDynamicOptionOverrides ? ({
                refinedOptions: e,
                pluginHooks: t,
                localeDefaults: n,
                availableLocaleData: i,
                extra: s
            } = this.processRawCalendarOptions(e, t), Vo(s), s = this.buildDateEnv(e.timeZone, e.locale, e.weekNumberCalculation, e.firstDay, e.weekText, t, i, e.defaultRangeSeparator), o = this.buildViewSpecs(t.views, this.stableOptionOverrides, this.stableDynamicOptionOverrides, n), a = this.buildTheme(e, t), r = this.parseToolbars(e, this.stableOptionOverrides, a, o, r), this.stableCalendarOptionsData = {
                calendarOptions: e,
                pluginHooks: t,
                dateEnv: s,
                viewSpecs: o,
                theme: a,
                toolbarConfig: r,
                localeDefaults: n,
                availableRawLocales: i.map
            }) : this.stableCalendarOptionsData
        }
        processRawCalendarOptions(e, t) {
            let {
                locales: r,
                locale: n
            } = wr([mr, e, t]), i = this.organizeRawLocales(r), s = i.map, o = this.buildLocale(n || i.defaultCode, s).options, a = this.buildPluginHooks(e.plugins || [], _o), l = this.currentCalendarOptionsRefiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, pr), vr), yr), a.listenerRefiners), a.optionRefiners), c = {}, d = wr([mr, o, e, t]), u = {}, h = this.currentCalendarOptionsInput, f = this.currentCalendarOptionsRefined, g = !1;
            for (var p in d) - 1 === this.optionsForRefining.indexOf(p) && (d[p] === h[p] || br[p] && p in h && br[p](h[p], d[p])) ? u[p] = f[p] : l[p] ? (u[p] = l[p](d[p]), g = !0) : c[p] = h[p];
            return g && (this.currentCalendarOptionsInput = d, this.currentCalendarOptionsRefined = u, this.stableOptionOverrides = e, this.stableDynamicOptionOverrides = t), this.optionsForHandling.push(...this.optionsForRefining), this.optionsForRefining = [], {
                rawOptions: this.currentCalendarOptionsInput,
                refinedOptions: this.currentCalendarOptionsRefined,
                pluginHooks: a,
                availableLocaleData: i,
                localeDefaults: o,
                extra: c
            }
        }
        _computeCurrentViewData(e, t, r, n) {
            var i = t.viewSpecs[e];
            if (i) return {
                refinedOptions: r,
                extra: n
            } = this.processRawViewOptions(i, t.pluginHooks, t.localeDefaults, r, n), Vo(n), this.nowManager.handleInput(t.dateEnv, r.now), {
                viewSpec: i,
                options: r,
                dateProfileGenerator: this.buildDateProfileGenerator({
                    dateProfileGeneratorClass: i.optionDefaults.dateProfileGeneratorClass,
                    nowManager: this.nowManager,
                    duration: i.duration,
                    durationUnit: i.durationUnit,
                    usesMinMaxTime: i.optionDefaults.usesMinMaxTime,
                    dateEnv: t.dateEnv,
                    calendarApi: this.props.calendarApi,
                    slotMinTime: r.slotMinTime,
                    slotMaxTime: r.slotMaxTime,
                    showNonCurrentDates: r.showNonCurrentDates,
                    dayCount: r.dayCount,
                    dateAlignment: r.dateAlignment,
                    dateIncrement: r.dateIncrement,
                    hiddenDays: r.hiddenDays,
                    weekends: r.weekends,
                    validRangeInput: r.validRange,
                    visibleRangeInput: r.visibleRange,
                    fixedWeekCount: r.fixedWeekCount
                }),
                viewApi: this.buildViewApi(e, this.getCurrentData, t.dateEnv)
            };
            throw new Error(`viewType "${e}" is not available. Please make sure you've loaded all neccessary plugins`)
        }
        processRawViewOptions(e, t, r, n, i) {
            let s = wr([mr, e.optionDefaults, r, n, e.optionOverrides, i]),
                o = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, pr), vr), yr), Cr), t.listenerRefiners), t.optionRefiners),
                a = {},
                l = this.currentViewOptionsInput,
                c = this.currentViewOptionsRefined,
                d = !1,
                u = {};
            for (var h in s) s[h] === l[h] || br[h] && br[h](s[h], l[h]) ? a[h] = c[h] : (s[h] === this.currentCalendarOptionsInput[h] || br[h] && br[h](s[h], this.currentCalendarOptionsInput[h]) ? h in this.currentCalendarOptionsRefined && (a[h] = this.currentCalendarOptionsRefined[h]) : o[h] ? a[h] = o[h](s[h]) : u[h] = s[h], d = !0);
            return d && (this.currentViewOptionsInput = s, this.currentViewOptionsRefined = a), {
                rawOptions: this.currentViewOptionsInput,
                refinedOptions: this.currentViewOptionsRefined,
                extra: u
            }
        }
    }

    function Ho(e, t, r, n, i, s, o, a) {
        t = co(t || o.defaultCode, o.map);
        return new Hr({
            calendarSystem: "gregory",
            timeZone: e,
            namedTimeZoneImpl: s.namedTimeZonedImpl,
            locale: t,
            weekNumberCalculation: r,
            firstDay: n,
            weekText: i,
            cmdFormatter: s.cmdFormatter,
            defaultSeparator: a
        })
    }

    function Wo(e, t) {
        return new(t.themeClasses[e.themeSystem] || fo)(e)
    }

    function Bo(e) {
        return new(e.dateProfileGeneratorClass || an)(e)
    }

    function jo(e, t, r) {
        return new Mo(e, t, r)
    }

    function Lo(e) {
        return O(e, e => e.ui)
    }

    function zo(e, t, r) {
        var n, i = {
            "": t
        };
        for (n in e) {
            var s = e[n];
            s.sourceId && r[s.sourceId] && (i[n] = r[s.sourceId])
        }
        return i
    }

    function Uo(e) {
        var t = e.options;
        return {
            eventUiSingleBase: Rn({
                display: t.eventDisplay,
                editable: t.editable,
                startEditable: t.eventStartEditable,
                durationEditable: t.eventDurationEditable,
                constraint: t.eventConstraint,
                overlap: "boolean" == typeof t.eventOverlap ? t.eventOverlap : void 0,
                allow: t.eventAllow,
                backgroundColor: t.eventBackgroundColor,
                borderColor: t.eventBorderColor,
                textColor: t.eventTextColor,
                color: t.eventColor
            }, e),
            selectionConfig: Rn({
                constraint: t.selectConstraint,
                overlap: "boolean" == typeof t.selectOverlap ? t.selectOverlap : void 0,
                allow: t.selectAllow
            }, e)
        }
    }

    function Go(e, t) {
        for (var r of t.pluginHooks.isLoadingFuncs)
            if (r(e)) return !0;
        return !1
    }

    function Fo(e) {
        return Bn(e.options.businessHours, e)
    }

    function Vo(e, t) {
        for (var r in e) console.warn(`Unknown option '${r}'` + (t ? ` for view '${t}'` : ""))
    }
    class qo extends s {
        render() {
            return b("div", {
                className: "fc-toolbar-chunk"
            }, ...this.props.widgetGroups.map(e => this.renderWidgetGroup(e)))
        }
        renderWidgetGroup(e) {
            let t = this.props,
                r = this.context.theme,
                n = [],
                i = !0;
            for (var s of e) {
                var o, a, {
                    buttonName: s,
                    buttonClick: l,
                    buttonText: c,
                    buttonIcon: d,
                    buttonHint: u
                } = s;
                "title" === s ? (i = !1, n.push(b("h2", {
                    className: "fc-toolbar-title",
                    id: t.titleId
                }, t.title))) : (o = s === t.activeButton, a = !t.isTodayEnabled && "today" === s || !t.isPrevEnabled && "prev" === s || !t.isNextEnabled && "next" === s, s = [`fc-${s}-button`, r.getClass("button")], o && s.push(r.getClass("buttonActive")), n.push(b("button", {
                    type: "button",
                    title: "function" == typeof u ? u(t.navUnit) : u,
                    disabled: a,
                    "aria-pressed": o,
                    className: s.join(" "),
                    onClick: l
                }, c || (d ? b("span", {
                    className: d,
                    role: "img"
                }) : ""))))
            }
            return 1 < n.length ? b("div", {
                className: i && r.getClass("buttonGroup") || ""
            }, ...n) : n[0]
        }
    }
    class Yo extends s {
        render() {
            let e, t, {
                    model: r,
                    extraClassName: n
                } = this.props,
                i = !1,
                s = r.sectionWidgets,
                o = s.center;
            return e = s.left ? (i = !0, s.left) : s.start, t = s.right ? (i = !0, s.right) : s.end, b("div", {
                className: [n || "", "fc-toolbar", i ? "fc-toolbar-ltr" : ""].join(" ")
            }, this.renderSection("start", e || []), this.renderSection("center", o || []), this.renderSection("end", t || []))
        }
        renderSection(e, t) {
            var r = this.props;
            return b(qo, {
                key: e,
                widgetGroups: t,
                title: r.title,
                navUnit: r.navUnit,
                activeButton: r.activeButton,
                isTodayEnabled: r.isTodayEnabled,
                isPrevEnabled: r.isPrevEnabled,
                isNextEnabled: r.isNextEnabled,
                titleId: r.titleId
            })
        }
    }
    class Qo extends s {
        constructor() {
            super(...arguments), this.state = {
                availableWidth: null
            }, this.handleEl = e => {
                this.el = e, o(this.props.elRef, e), this.updateAvailableWidth()
            }, this.handleResize = () => {
                this.updateAvailableWidth()
            }
        }
        render() {
            let {
                props: e,
                state: t
            } = this, r = e.aspectRatio, n = ["fc-view-harness", r || e.liquid || e.height ? "fc-view-harness-active" : "fc-view-harness-passive"], i = "", s = "";
            return r ? null !== t.availableWidth ? i = t.availableWidth / r : s = 1 / r * 100 + "%" : i = e.height || "", b("div", {
                "aria-labelledby": e.labeledById,
                ref: this.handleEl,
                className: n.join(" "),
                style: {
                    height: i,
                    paddingBottom: s
                }
            }, e.children)
        }
        componentDidMount() {
            this.context.addResizeHandler(this.handleResize)
        }
        componentWillUnmount() {
            this.context.removeResizeHandler(this.handleResize)
        }
        updateAvailableWidth() {
            this.el && this.props.aspectRatio && this.setState({
                availableWidth: this.el.offsetWidth
            })
        }
    }
    class Zo extends gi {
        constructor(e) {
            super(e), this.handleSegClick = (e, t) => {
                var r, n = this.component,
                    i = n.context,
                    s = Zn(t);
                s && n.isValidSegDownEl(e.target) && (r = (r = l(e.target, ".fc-event-forced-url")) ? r.querySelector("a[href]").href : "", i.emitter.trigger("eventClick", {
                    el: t,
                    event: new P(n.context, s.eventRange.def, s.eventRange.instance),
                    jsEvent: e,
                    view: i.viewApi
                }), r) && !e.defaultPrevented && (window.location.href = r)
            }, this.destroy = st(e.el, "click", ".fc-event", this.handleSegClick)
        }
    }
    class Xo extends gi {
        constructor(e) {
            super(e), this.handleEventElRemove = e => {
                e === this.currentSegEl && this.handleSegLeave(null, this.currentSegEl)
            }, this.handleSegEnter = (e, t) => {
                Zn(t) && (this.currentSegEl = t, this.triggerEvent("eventMouseEnter", e, t))
            }, this.handleSegLeave = (e, t) => {
                this.currentSegEl && (this.currentSegEl = null, this.triggerEvent("eventMouseLeave", e, t))
            }, this.removeHoverListeners = ((e, n, i) => {
                let s;
                return st(e, "mouseover", ".fc-event", (e, r) => {
                    if (r !== s) {
                        s = r, n(e, r);
                        let t = e => {
                            s = null, i(e, r), r.removeEventListener("mouseleave", t)
                        };
                        r.addEventListener("mouseleave", t)
                    }
                })
            })(e.el, this.handleSegEnter, this.handleSegLeave)
        }
        destroy() {
            this.removeHoverListeners()
        }
        triggerEvent(e, t, r) {
            var n = this.component,
                i = n.context,
                s = Zn(r);
            t && !n.isValidSegDownEl(t.target) || i.emitter.trigger(e, {
                el: r,
                event: new P(i, s.eventRange.def, s.eventRange.instance),
                jsEvent: t,
                view: i.viewApi
            })
        }
    }
    class Jo extends Gr {
        constructor() {
            super(...arguments), this.buildViewContext = f(Ur), this.buildViewPropTransformers = f($o), this.buildToolbarProps = f(Ko), this.headerRef = {
                current: null
            }, this.footerRef = {
                current: null
            }, this.interactionsStore = {}, this.state = {
                viewLabelId: t()
            }, this.registerInteractiveComponent = (e, t) => {
                let r = {
                        component: e,
                        el: t.el,
                        useEventCenter: null == t.useEventCenter || t.useEventCenter,
                        isHitComboAllowed: t.isHitComboAllowed || null
                    },
                    n = [Zo, Xo].concat(this.props.pluginHooks.componentInteractions).map(e => new e(r));
                this.interactionsStore[e.uid] = n, mi[e.uid] = r
            }, this.unregisterInteractiveComponent = e => {
                var t = this.interactionsStore[e.uid];
                if (t) {
                    for (var r of t) r.destroy();
                    delete this.interactionsStore[e.uid]
                }
                delete mi[e.uid]
            }, this.resizeRunner = new Qe(() => {
                this.props.emitter.trigger("_resize", !0), this.props.emitter.trigger("windowResize", {
                    view: this.props.viewApi
                })
            }), this.handleWindowResize = e => {
                var t = this.props.options;
                t.handleWindowResize && e.target === window && this.resizeRunner.request(t.windowResizeDelay)
            }
        }
        render() {
            let t, r = this.props,
                {
                    toolbarConfig: n,
                    options: e
                } = r,
                i = !1,
                s = "",
                o = (r.isHeightAuto || r.forPrint ? s = "" : null != e.height ? i = !0 : null != e.contentHeight ? s = e.contentHeight : t = Math.max(e.aspectRatio, .5), this.buildViewContext(r.viewSpec, r.viewApi, r.options, r.dateProfileGenerator, r.dateEnv, r.nowManager, r.theme, r.pluginHooks, r.dispatch, r.getCurrentData, r.emitter, r.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent)),
                a = n.header && n.header.hasTitle ? this.state.viewLabelId : void 0;
            return b(u.Provider, {
                value: o
            }, b(m, {
                unit: "day"
            }, e => {
                e = this.buildToolbarProps(r.viewSpec, r.dateProfile, r.dateProfileGenerator, r.currentDate, e, r.viewTitle);
                return b(A, null, n.header && b(Yo, Object.assign({
                    ref: this.headerRef,
                    extraClassName: "fc-header-toolbar",
                    model: n.header,
                    titleId: a
                }, e)), b(Qo, {
                    liquid: i,
                    height: s,
                    aspectRatio: t,
                    labeledById: a
                }, this.renderView(r), this.buildAppendContent()), n.footer && b(Yo, Object.assign({
                    ref: this.footerRef,
                    extraClassName: "fc-footer-toolbar",
                    model: n.footer,
                    titleId: ""
                }, e)))
            }))
        }
        componentDidMount() {
            let t = this.props;
            this.calendarInteractions = t.pluginHooks.calendarInteractions.map(e => new e(t)), window.addEventListener("resize", this.handleWindowResize);
            var e, r = t.pluginHooks.propSetHandlers;
            for (e in r) r[e](t[e], t)
        }
        componentDidUpdate(e) {
            var t, r = this.props,
                n = r.pluginHooks.propSetHandlers;
            for (t in n) r[t] !== e[t] && n[t](r[t], r)
        }
        componentWillUnmount() {
            window.removeEventListener("resize", this.handleWindowResize), this.resizeRunner.clear();
            for (var e of this.calendarInteractions) e.destroy();
            this.props.emitter.trigger("_unmount")
        }
        buildAppendContent() {
            let t = this.props;
            return b(A, {}, ...t.pluginHooks.viewContainerAppends.map(e => e(t)))
        }
        renderView(e) {
            var t, r = e.pluginHooks,
                n = e.viewSpec,
                i = {
                    dateProfile: e.dateProfile,
                    businessHours: e.businessHours,
                    eventStore: e.renderableEventStore,
                    eventUiBases: e.eventUiBases,
                    dateSelection: e.dateSelection,
                    eventSelection: e.eventSelection,
                    eventDrag: e.eventDrag,
                    eventResize: e.eventResize,
                    isHeightAuto: e.isHeightAuto,
                    forPrint: e.forPrint
                };
            for (t of this.buildViewPropTransformers(r.viewPropsTransformers)) Object.assign(i, t.transform(i, e));
            return b(n.component, Object.assign({}, i))
        }
    }

    function Ko(e, t, r, n, i, s) {
        var o = r.build(i, void 0, !1),
            a = r.buildPrev(t, n, !1),
            r = r.buildNext(t, n, !1);
        return {
            title: s,
            activeButton: e.type,
            navUnit: e.singleUnit,
            isTodayEnabled: o.isValid && !S(t.currentRange, i),
            isPrevEnabled: a.isValid,
            isNextEnabled: r.isValid
        }
    }

    function $o(e) {
        return e.map(e => new e)
    }

    function ea(e) {
        var t = co(e.locale || "en", lo([]).map);
        return new Hr(Object.assign(Object.assign({
            timeZone: mr.timeZone,
            calendarSystem: "gregory"
        }, e), {
            locale: t
        }))
    }
    N.touchMouseIgnoreWait = 500;
    let ta = 0,
        ra = 0,
        na = !1;
    class ia {
        constructor(e) {
            this.subjectEl = null, this.selector = "", this.handleSelector = "", this.shouldIgnoreMove = !1, this.shouldWatchScroll = !0, this.isDragging = !1, this.isTouchDragging = !1, this.wasTouchScroll = !1, this.handleMouseDown = e => {
                this.shouldIgnoreMouse() || 0 !== e.button || e.ctrlKey || !this.tryStart(e) || (e = this.createEventFromMouse(e, !0), this.emitter.trigger("pointerdown", e), this.initScrollWatch(e), this.shouldIgnoreMove || document.addEventListener("mousemove", this.handleMouseMove), document.addEventListener("mouseup", this.handleMouseUp))
            }, this.handleMouseMove = e => {
                e = this.createEventFromMouse(e);
                this.recordCoords(e), this.emitter.trigger("pointermove", e)
            }, this.handleMouseUp = e => {
                document.removeEventListener("mousemove", this.handleMouseMove), document.removeEventListener("mouseup", this.handleMouseUp), this.emitter.trigger("pointerup", this.createEventFromMouse(e)), this.cleanup()
            }, this.handleTouchStart = e => {
                var t;
                this.tryStart(e) && (this.isTouchDragging = !0, t = this.createEventFromTouch(e, !0), this.emitter.trigger("pointerdown", t), this.initScrollWatch(t), t = e.target, this.shouldIgnoreMove || t.addEventListener("touchmove", this.handleTouchMove), t.addEventListener("touchend", this.handleTouchEnd), t.addEventListener("touchcancel", this.handleTouchEnd), window.addEventListener("scroll", this.handleTouchScroll, !0))
            }, this.handleTouchMove = e => {
                e = this.createEventFromTouch(e);
                this.recordCoords(e), this.emitter.trigger("pointermove", e)
            }, this.handleTouchEnd = e => {
                var t;
                this.isDragging && ((t = e.target).removeEventListener("touchmove", this.handleTouchMove), t.removeEventListener("touchend", this.handleTouchEnd), t.removeEventListener("touchcancel", this.handleTouchEnd), window.removeEventListener("scroll", this.handleTouchScroll, !0), this.emitter.trigger("pointerup", this.createEventFromTouch(e)), this.cleanup(), this.isTouchDragging = !1, ta += 1, setTimeout(() => {
                    --ta
                }, N.touchMouseIgnoreWait))
            }, this.handleTouchScroll = () => {
                this.wasTouchScroll = !0
            }, this.handleScroll = e => {
                var t, r;
                this.shouldIgnoreMove || (t = window.scrollX - this.prevScrollX + this.prevPageX, r = window.scrollY - this.prevScrollY + this.prevPageY, this.emitter.trigger("pointermove", {
                    origEvent: e,
                    isTouch: this.isTouchDragging,
                    subjectEl: this.subjectEl,
                    pageX: t,
                    pageY: r,
                    deltaX: t - this.origPageX,
                    deltaY: r - this.origPageY
                }))
            }, this.containerEl = e, this.emitter = new Hn, e.addEventListener("mousedown", this.handleMouseDown), e.addEventListener("touchstart", this.handleTouchStart, {
                passive: !0
            }), 1 === (ra += 1) && window.addEventListener("touchmove", sa, {
                passive: !1
            })
        }
        destroy() {
            this.containerEl.removeEventListener("mousedown", this.handleMouseDown), this.containerEl.removeEventListener("touchstart", this.handleTouchStart, {
                passive: !0
            }), --ra || window.removeEventListener("touchmove", sa, {
                passive: !1
            })
        }
        tryStart(e) {
            var t = this.querySubjectEl(e),
                e = e.target;
            return !(!t || this.handleSelector && !l(e, this.handleSelector) || (this.subjectEl = t, this.isDragging = !0, this.wasTouchScroll = !1))
        }
        cleanup() {
            na = !1, this.isDragging = !1, this.subjectEl = null, this.destroyScrollWatch()
        }
        querySubjectEl(e) {
            return this.selector ? l(e.target, this.selector) : this.containerEl
        }
        shouldIgnoreMouse() {
            return ta || this.isTouchDragging
        }
        cancelTouchScroll() {
            this.isDragging && (na = !0)
        }
        initScrollWatch(e) {
            this.shouldWatchScroll && (this.recordCoords(e), window.addEventListener("scroll", this.handleScroll, !0))
        }
        recordCoords(e) {
            this.shouldWatchScroll && (this.prevPageX = e.pageX, this.prevPageY = e.pageY, this.prevScrollX = window.scrollX, this.prevScrollY = window.scrollY)
        }
        destroyScrollWatch() {
            this.shouldWatchScroll && window.removeEventListener("scroll", this.handleScroll, !0)
        }
        createEventFromMouse(e, t) {
            let r = 0,
                n = 0;
            return t ? (this.origPageX = e.pageX, this.origPageY = e.pageY) : (r = e.pageX - this.origPageX, n = e.pageY - this.origPageY), {
                origEvent: e,
                isTouch: !1,
                subjectEl: this.subjectEl,
                pageX: e.pageX,
                pageY: e.pageY,
                deltaX: r,
                deltaY: n
            }
        }
        createEventFromTouch(e, t) {
            let r, n, i = e.touches,
                s = 0,
                o = 0;
            return n = (i && i.length ? (r = i[0].pageX, i[0]) : (r = e.pageX, e)).pageY, t ? (this.origPageX = r, this.origPageY = n) : (s = r - this.origPageX, o = n - this.origPageY), {
                origEvent: e,
                isTouch: !0,
                subjectEl: this.subjectEl,
                pageX: r,
                pageY: n,
                deltaX: s,
                deltaY: o
            }
        }
    }

    function sa(e) {
        na && e.preventDefault()
    }
    class oa {
        constructor() {
            this.isVisible = !1, this.sourceEl = null, this.mirrorEl = null, this.sourceElRect = null, this.parentNode = document.body, this.zIndex = 9999, this.revertDuration = 0
        }
        start(e, t, r) {
            this.sourceEl = e, this.sourceElRect = this.sourceEl.getBoundingClientRect(), this.origScreenX = t - window.scrollX, this.origScreenY = r - window.scrollY, this.deltaX = 0, this.deltaY = 0, this.updateElPosition()
        }
        handleMove(e, t) {
            this.deltaX = e - window.scrollX - this.origScreenX, this.deltaY = t - window.scrollY - this.origScreenY, this.updateElPosition()
        }
        setIsVisible(e) {
            e ? this.isVisible || (this.mirrorEl && (this.mirrorEl.style.display = ""), this.isVisible = e, this.updateElPosition()) : this.isVisible && (this.mirrorEl && (this.mirrorEl.style.display = "none"), this.isVisible = e)
        }
        stop(e, t) {
            var r = () => {
                this.cleanup(), t()
            };
            e && this.mirrorEl && this.isVisible && this.revertDuration && (this.deltaX || this.deltaY) ? this.doRevertAnimation(r, this.revertDuration) : setTimeout(r, 0)
        }
        doRevertAnimation(e, t) {
            let r = this.mirrorEl,
                n = this.sourceEl.getBoundingClientRect();
            r.style.transition = "top " + t + "ms,left " + t + "ms", et(r, {
                left: n.left,
                top: n.top
            }), at(r, () => {
                r.style.transition = "", e()
            })
        }
        cleanup() {
            this.mirrorEl && (Ze(this.mirrorEl), this.mirrorEl = null), this.sourceEl = null
        }
        updateElPosition() {
            this.sourceEl && this.isVisible && et(this.getMirrorEl(), {
                left: this.sourceElRect.left + this.deltaX,
                top: this.sourceElRect.top + this.deltaY
            })
        }
        getMirrorEl() {
            let e = this.sourceElRect,
                t = this.mirrorEl;
            return t || ((t = this.mirrorEl = this.sourceEl.cloneNode(!0)).style.userSelect = "none", t.style.webkitUserSelect = "none", t.style.pointerEvents = "none", t.classList.add("fc-event-dragging"), et(t, {
                position: "fixed",
                zIndex: this.zIndex,
                visibility: "",
                boxSizing: "border-box",
                width: e.right - e.left,
                height: e.bottom - e.top,
                right: "auto",
                bottom: "auto",
                margin: 0
            }), this.parentNode.appendChild(t)), t
        }
    }
    class aa extends Fi {
        constructor(e, t) {
            super(), this.handleScroll = () => {
                this.scrollTop = this.scrollController.getScrollTop(), this.scrollLeft = this.scrollController.getScrollLeft(), this.handleScrollChange()
            }, this.scrollController = e, this.doesListening = t, this.scrollTop = this.origScrollTop = e.getScrollTop(), this.scrollLeft = this.origScrollLeft = e.getScrollLeft(), this.scrollWidth = e.getScrollWidth(), this.scrollHeight = e.getScrollHeight(), this.clientWidth = e.getClientWidth(), this.clientHeight = e.getClientHeight(), this.clientRect = this.computeClientRect(), this.doesListening && this.getEventTarget().addEventListener("scroll", this.handleScroll)
        }
        destroy() {
            this.doesListening && this.getEventTarget().removeEventListener("scroll", this.handleScroll)
        }
        getScrollTop() {
            return this.scrollTop
        }
        getScrollLeft() {
            return this.scrollLeft
        }
        setScrollTop(e) {
            this.scrollController.setScrollTop(e), this.doesListening || (this.scrollTop = Math.max(Math.min(e, this.getMaxScrollTop()), 0), this.handleScrollChange())
        }
        setScrollLeft(e) {
            this.scrollController.setScrollLeft(e), this.doesListening || (this.scrollLeft = Math.max(Math.min(e, this.getMaxScrollLeft()), 0), this.handleScrollChange())
        }
        getClientWidth() {
            return this.clientWidth
        }
        getClientHeight() {
            return this.clientHeight
        }
        getScrollWidth() {
            return this.scrollWidth
        }
        getScrollHeight() {
            return this.scrollHeight
        }
        handleScrollChange() {}
    }
    class la extends aa {
        constructor(e, t) {
            super(new Vi(e), t)
        }
        getEventTarget() {
            return this.scrollController.el
        }
        computeClientRect() {
            return ji(this.scrollController.el)
        }
    }
    class ca extends aa {
        constructor(e) {
            super(new qi, e)
        }
        getEventTarget() {
            return window
        }
        computeClientRect() {
            return {
                left: this.scrollLeft,
                right: this.scrollLeft + this.clientWidth,
                top: this.scrollTop,
                bottom: this.scrollTop + this.clientHeight
            }
        }
        handleScrollChange() {
            this.clientRect = this.computeClientRect()
        }
    }
    let da = ("function" == typeof performance ? performance : Date).now;
    class ua {
        constructor() {
            this.isEnabled = !0, this.scrollQuery = [window, ".fc-scroller"], this.edgeThreshold = 50, this.maxVelocity = 300, this.pointerScreenX = null, this.pointerScreenY = null, this.isAnimating = !1, this.scrollCaches = null, this.everMovedUp = !1, this.everMovedDown = !1, this.everMovedLeft = !1, this.everMovedRight = !1, this.animate = () => {
                var e, t;
                this.isAnimating && ((e = this.computeBestEdge(this.pointerScreenX + window.scrollX, this.pointerScreenY + window.scrollY)) ? (t = da(), this.handleSide(e, (t - this.msSinceRequest) / 1e3), this.requestAnimation(t)) : this.isAnimating = !1)
            }
        }
        start(e, t, r) {
            this.isEnabled && (this.scrollCaches = this.buildCaches(r), this.pointerScreenX = null, this.pointerScreenY = null, this.everMovedUp = !1, this.everMovedDown = !1, this.everMovedLeft = !1, this.everMovedRight = !1, this.handleMove(e, t))
        }
        handleMove(e, t) {
            var r, n;
            this.isEnabled && (e = e - window.scrollX, t = t - window.scrollY, r = null === this.pointerScreenY ? 0 : t - this.pointerScreenY, n = null === this.pointerScreenX ? 0 : e - this.pointerScreenX, r < 0 ? this.everMovedUp = !0 : 0 < r && (this.everMovedDown = !0), n < 0 ? this.everMovedLeft = !0 : 0 < n && (this.everMovedRight = !0), this.pointerScreenX = e, this.pointerScreenY = t, this.isAnimating || (this.isAnimating = !0, this.requestAnimation(da())))
        }
        stop() {
            if (this.isEnabled) {
                this.isAnimating = !1;
                for (var e of this.scrollCaches) e.destroy();
                this.scrollCaches = null
            }
        }
        requestAnimation(e) {
            this.msSinceRequest = e, requestAnimationFrame(this.animate)
        }
        handleSide(e, t) {
            let r = e.scrollCache,
                n = this.edgeThreshold,
                i = n - e.distance,
                s = i * i / (n * n) * this.maxVelocity * t,
                o = 1;
            switch (e.name) {
                case "left":
                    o = -1;
                case "right":
                    r.setScrollLeft(r.getScrollLeft() + s * o);
                    break;
                case "top":
                    o = -1;
                case "bottom":
                    r.setScrollTop(r.getScrollTop() + s * o)
            }
        }
        computeBestEdge(e, t) {
            let r = this.edgeThreshold,
                n = null,
                i = this.scrollCaches || [];
            for (var s of i) {
                var o = s.clientRect,
                    a = e - o.left,
                    l = o.right - e,
                    c = t - o.top,
                    o = o.bottom - t;
                0 <= a && 0 <= l && 0 <= c && 0 <= o && (c <= r && this.everMovedUp && s.canScrollUp() && (!n || n.distance > c) && (n = {
                    scrollCache: s,
                    name: "top",
                    distance: c
                }), o <= r && this.everMovedDown && s.canScrollDown() && (!n || n.distance > o) && (n = {
                    scrollCache: s,
                    name: "bottom",
                    distance: o
                }), a <= r && this.everMovedLeft && s.canScrollLeft() && (!n || n.distance > a) && (n = {
                    scrollCache: s,
                    name: "left",
                    distance: a
                }), l <= r) && this.everMovedRight && s.canScrollRight() && (!n || n.distance > l) && (n = {
                    scrollCache: s,
                    name: "right",
                    distance: l
                })
            }
            return n
        }
        buildCaches(e) {
            return this.queryScrollEls(e).map(e => e === window ? new ca(!1) : new la(e, !1))
        }
        queryScrollEls(e) {
            var t, r = [];
            for (t of this.scrollQuery) "object" == typeof t ? r.push(t) : r.push(...Array.prototype.slice.call(e.getRootNode().querySelectorAll(t)));
            return r
        }
    }
    class ha extends es {
        constructor(e, t) {
            super(e), this.containerEl = e, this.delay = null, this.minDistance = 0, this.touchScrollAllowed = !0, this.mirrorNeedsRevert = !1, this.isInteracting = !1, this.isDragging = !1, this.isDelayEnded = !1, this.isDistanceSurpassed = !1, this.delayTimeoutId = null, this.onPointerDown = e => {
                this.isDragging || (this.isInteracting = !0, this.isDelayEnded = !1, this.isDistanceSurpassed = !1, ft(document.body), pt(document.body), e.isTouch || e.origEvent.preventDefault(), this.emitter.trigger("pointerdown", e), this.isInteracting && !this.pointer.shouldIgnoreMove && (this.mirror.setIsVisible(!1), this.mirror.start(e.subjectEl, e.pageX, e.pageY), this.startDelay(e), this.minDistance || this.handleDistanceSurpassed(e)))
            }, this.onPointerMove = e => {
                var t, r, n;
                this.isInteracting && (this.emitter.trigger("pointermove", e), this.isDistanceSurpassed || ({
                    deltaX: r,
                    deltaY: n
                } = e, (t = this.minDistance) * t <= r * r + n * n && this.handleDistanceSurpassed(e)), this.isDragging) && ("scroll" !== e.origEvent.type && (this.mirror.handleMove(e.pageX, e.pageY), this.autoScroller.handleMove(e.pageX, e.pageY)), this.emitter.trigger("dragmove", e))
            }, this.onPointerUp = e => {
                this.isInteracting && (this.isInteracting = !1, gt(document.body), mt(document.body), this.emitter.trigger("pointerup", e), this.isDragging && (this.autoScroller.stop(), this.tryStopDrag(e)), this.delayTimeoutId) && (clearTimeout(this.delayTimeoutId), this.delayTimeoutId = null)
            };
            e = this.pointer = new ia(e);
            e.emitter.on("pointerdown", this.onPointerDown), e.emitter.on("pointermove", this.onPointerMove), e.emitter.on("pointerup", this.onPointerUp), t && (e.selector = t), this.mirror = new oa, this.autoScroller = new ua
        }
        destroy() {
            this.pointer.destroy(), this.onPointerUp({})
        }
        startDelay(e) {
            "number" == typeof this.delay ? this.delayTimeoutId = setTimeout(() => {
                this.delayTimeoutId = null, this.handleDelayEnd(e)
            }, this.delay) : this.handleDelayEnd(e)
        }
        handleDelayEnd(e) {
            this.isDelayEnded = !0, this.tryStartDrag(e)
        }
        handleDistanceSurpassed(e) {
            this.isDistanceSurpassed = !0, this.tryStartDrag(e)
        }
        tryStartDrag(e) {
            this.isDelayEnded && this.isDistanceSurpassed && (this.pointer.wasTouchScroll && !this.touchScrollAllowed || (this.isDragging = !0, this.mirrorNeedsRevert = !1, this.autoScroller.start(e.pageX, e.pageY, this.containerEl), this.emitter.trigger("dragstart", e), !1 === this.touchScrollAllowed && this.pointer.cancelTouchScroll()))
        }
        tryStopDrag(e) {
            this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, e))
        }
        stopDrag(e) {
            this.isDragging = !1, this.emitter.trigger("dragend", e)
        }
        setIgnoreMove(e) {
            this.pointer.shouldIgnoreMove = e
        }
        setMirrorIsVisible(e) {
            this.mirror.setIsVisible(e)
        }
        setMirrorNeedsRevert(e) {
            this.mirrorNeedsRevert = e
        }
        setAutoScrollEnabled(e) {
            this.autoScroller.isEnabled = e
        }
    }
    class fa {
        constructor(e) {
            this.el = e, this.origRect = Li(e), this.scrollCaches = zi(e).map(e => new la(e, !0))
        }
        destroy() {
            for (var e of this.scrollCaches) e.destroy()
        }
        computeLeft() {
            let e = this.origRect.left;
            for (var t of this.scrollCaches) e += t.origScrollLeft - t.getScrollLeft();
            return e
        }
        computeTop() {
            let e = this.origRect.top;
            for (var t of this.scrollCaches) e += t.origScrollTop - t.getScrollTop();
            return e
        }
        isWithinClipping(e, t) {
            var r, n = {
                left: e,
                top: t
            };
            for (r of this.scrollCaches)
                if (!(e => "HTML" === (e = e.tagName) || "BODY" === e)(r.getEventTarget()) && !yi(n, r.clientRect)) return !1;
            return !0
        }
    }
    class ga {
        constructor(e, t) {
            this.useSubjectCenter = !1, this.requireInitial = !0, this.disablePointCheck = !1, this.initialHit = null, this.movingHit = null, this.finalHit = null, this.handlePointerDown = e => {
                var t = this.dragging;
                this.initialHit = null, this.movingHit = null, this.finalHit = null, this.prepareHits(), this.processFirstCoord(e), this.initialHit || !this.requireInitial ? (t.setIgnoreMove(!1), this.emitter.trigger("pointerdown", e)) : t.setIgnoreMove(!0)
            }, this.handleDragStart = e => {
                this.emitter.trigger("dragstart", e), this.handleMove(e, !0)
            }, this.handleDragMove = e => {
                this.emitter.trigger("dragmove", e), this.handleMove(e)
            }, this.handlePointerUp = e => {
                this.releaseHits(), this.emitter.trigger("pointerup", e)
            }, this.handleDragEnd = e => {
                this.movingHit && this.emitter.trigger("hitupdate", null, !0, e), this.finalHit = this.movingHit, this.movingHit = null, this.emitter.trigger("dragend", e)
            }, this.droppableStore = t, e.emitter.on("pointerdown", this.handlePointerDown), e.emitter.on("dragstart", this.handleDragStart), e.emitter.on("dragmove", this.handleDragMove), e.emitter.on("pointerup", this.handlePointerUp), e.emitter.on("dragend", this.handleDragEnd), this.dragging = e, this.emitter = new Hn
        }
        processFirstCoord(e) {
            let t, r = {
                    left: e.pageX,
                    top: e.pageY
                },
                n = r,
                i = e.subjectEl;
            i instanceof HTMLElement && (t = Li(i), n = Ei(n, t));
            var e = this.initialHit = this.queryHitForOffset(n.left, n.top);
            e ? (this.useSubjectCenter && t && (e = bi(t, e.rect)) && (n = Ci(e)), this.coordAdjust = wi(n, r)) : this.coordAdjust = {
                left: 0,
                top: 0
            }
        }
        handleMove(e, t) {
            var r = this.queryHitForOffset(e.pageX + this.coordAdjust.left, e.pageY + this.coordAdjust.top);
            !t && pa(this.movingHit, r) || (this.movingHit = r, this.emitter.trigger("hitupdate", r, !1, e))
        }
        prepareHits() {
            this.offsetTrackers = O(this.droppableStore, e => (e.component.prepareHits(), new fa(e.el)))
        }
        releaseHits() {
            var e, t = this.offsetTrackers;
            for (e in t) t[e].destroy();
            this.offsetTrackers = {}
        }
        queryHitForOffset(e, t) {
            let {
                droppableStore: r,
                offsetTrackers: n
            } = this, i = null;
            for (var s in r) {
                var o, a, l, c, d, u, h = r[s].component,
                    f = n[s];
                f && f.isWithinClipping(e, t) && (o = f.computeLeft(), c = t - (a = f.computeTop()), d = f.origRect, u = d.right - d.left, d = d.bottom - d.top, 0 <= (l = e - o)) && l < u && 0 <= c && c < d && (u = h.queryHit(l, c, u, d)) && tn(u.dateProfile.activeRange, u.dateSpan.range) && (this.disablePointCheck || f.el.contains(f.el.getRootNode().elementFromPoint(l + o - window.scrollX, c + a - window.scrollY))) && (!i || u.layer > i.layer) && (u.componentId = s, u.context = h.context, u.rect.left += o, u.rect.right += o, u.rect.top += a, u.rect.bottom += a, i = u)
            }
            return i
        }
    }

    function pa(e, t) {
        return !e && !t || Boolean(e) === Boolean(t) && si(e.dateSpan, t.dateSpan)
    }

    function ma(e, t) {
        var r, n, i, s = {};
        for (r of t.pluginHooks.datePointTransforms) Object.assign(s, r(e, t));
        return Object.assign(s, {
            date: (i = t.dateEnv).toDate((n = e).range.start),
            dateStr: i.formatIso(n.range.start, {
                omitTime: n.allDay
            }),
            allDay: n.allDay
        }), s
    }
    class va extends gi {
        constructor(e) {
            super(e), this.subjectEl = null, this.subjectSeg = null, this.isDragging = !1, this.eventRange = null, this.relevantEvents = null, this.receivingContext = null, this.validMutation = null, this.mutatedRelevantEvents = null, this.handlePointerDown = e => {
                var t = e.origEvent.target,
                    {
                        component: r,
                        dragging: n
                    } = this,
                    i = n.mirror,
                    s = r.context.options,
                    o = r.context,
                    a = (this.subjectEl = e.subjectEl, this.subjectSeg = Zn(e.subjectEl)),
                    a = (this.eventRange = a.eventRange).instance.instanceId,
                    o = (this.relevantEvents = bn(o.getCurrentData().eventStore, a), n.minDistance = e.isTouch ? 0 : s.eventDragMinDistance, n.delay = e.isTouch && a !== r.props.eventSelection ? (() => {
                        let e = r.context.options,
                            t = e.eventLongPressDelay;
                        return t = null == t ? e.longPressDelay : t
                    })() : null, s.fixedMirrorParent ? i.parentNode = s.fixedMirrorParent : i.parentNode = l(t, ".fc"), i.revertDuration = s.dragRevertDuration, r.isValidSegDownEl(t) && !l(t, ".fc-event-resizer"));
                n.setIgnoreMove(!o), this.isDragging = o && e.subjectEl.classList.contains("fc-event-draggable")
            }, this.handleDragStart = e => {
                var t = this.component.context,
                    r = this.eventRange,
                    n = r.instance.instanceId;
                e.isTouch ? n !== this.component.props.eventSelection && t.dispatch({
                    type: "SELECT_EVENT",
                    eventInstanceId: n
                }) : t.dispatch({
                    type: "UNSELECT_EVENT"
                }), this.isDragging && (t.calendarApi.unselect(e), t.emitter.trigger("eventDragStart", {
                    el: this.subjectEl,
                    event: new P(t, r.def, r.instance),
                    jsEvent: e.origEvent,
                    view: t.viewApi
                }))
            }, this.handleHitUpdate = (l, c) => {
                if (this.isDragging) {
                    let e = this.relevantEvents,
                        t = this.hitDragging.initialHit,
                        r = this.component.context,
                        n = null,
                        i = null,
                        s = null,
                        o = !1,
                        a = {
                            affectedEvents: e,
                            mutatedEvents: {
                                defs: {},
                                instances: {}
                            },
                            isEvent: !0
                        };
                    var d;
                    l && (d = (n = l.context).options, r === n || d.editable && d.droppable ? (i = ((e, t, r, n) => {
                        let i = e.dateSpan,
                            s = t.dateSpan,
                            o = i.range.start,
                            a = s.range.start,
                            l = {};
                        i.allDay !== s.allDay && (l.allDay = s.allDay, l.hasEnd = t.context.options.allDayMaintainDuration, o = s.allDay ? v(r) : r);
                        (r = on(o, a, e.context.dateEnv, e.componentId === t.componentId ? e.largeUnit : null)).milliseconds && (l.allDay = !1);
                        var c, d = {
                            datesDelta: r,
                            standardProps: l
                        };
                        for (c of n) c(d, e, t);
                        return d
                    })(t, l, this.eventRange.instance.range.start, n.getCurrentData().pluginHooks.eventDragMutationMassagers)) && (s = Un(e, n.getCurrentData().eventUiBases, i, n), a.mutatedEvents = s, ps(a, l.dateProfile, n) || (o = !0, i = null, s = null, a.mutatedEvents = {
                        defs: {},
                        instances: {}
                    })) : n = null), this.displayDrag(n, a), (o ? ut : ht)(), c || (r === n && pa(t, l) && (i = null), this.dragging.setMirrorNeedsRevert(!i), this.dragging.setMirrorIsVisible(!l || !this.subjectEl.getRootNode().querySelector(".fc-event-mirror")), this.receivingContext = n, this.validMutation = i, this.mutatedRelevantEvents = s)
                }
            }, this.handlePointerUp = () => {
                this.isDragging || this.cleanup()
            }, this.handleDragEnd = d => {
                if (this.isDragging) {
                    let e = this.component.context,
                        t = e.viewApi,
                        {
                            receivingContext: r,
                            validMutation: n
                        } = this,
                        i = this.eventRange.def,
                        s = this.eventRange.instance,
                        o = new P(e, i, s),
                        a = this.relevantEvents,
                        l = this.mutatedRelevantEvents,
                        c = this.hitDragging.finalHit;
                    if (this.clearDrag(), e.emitter.trigger("eventDragStop", {
                            el: this.subjectEl,
                            event: o,
                            jsEvent: d.origEvent,
                            view: t
                        }), n)
                        if (r === e) {
                            var u, h = new P(e, l.defs[i.defId], s ? l.instances[s.instanceId] : null),
                                h = (e.dispatch({
                                    type: "MERGE_EVENTS",
                                    eventStore: l
                                }), {
                                    oldEvent: o,
                                    event: h,
                                    relatedEvents: Vn(l, e, s),
                                    revert() {
                                        e.dispatch({
                                            type: "MERGE_EVENTS",
                                            eventStore: a
                                        })
                                    }
                                }),
                                f = {};
                            for (u of e.getCurrentData().pluginHooks.eventDropTransformers) Object.assign(f, u(n, e));
                            e.emitter.trigger("eventDrop", Object.assign(Object.assign(Object.assign({}, h), f), {
                                el: d.subjectEl,
                                delta: n.datesDelta,
                                jsEvent: d.origEvent,
                                view: t
                            })), e.emitter.trigger("eventChange", h)
                        } else {
                            var g;
                            r && (h = {
                                event: o,
                                relatedEvents: Vn(a, e, s),
                                revert() {
                                    e.dispatch({
                                        type: "MERGE_EVENTS",
                                        eventStore: a
                                    })
                                }
                            }, e.emitter.trigger("eventLeave", Object.assign(Object.assign({}, h), {
                                draggedEl: d.subjectEl,
                                view: t
                            })), e.dispatch({
                                type: "REMOVE_EVENTS",
                                eventStore: a
                            }), e.emitter.trigger("eventRemove", h), h = l.defs[i.defId], g = l.instances[s.instanceId], h = new P(r, h, g), r.dispatch({
                                type: "MERGE_EVENTS",
                                eventStore: l
                            }), h = {
                                event: h,
                                relatedEvents: Vn(l, r, g),
                                revert() {
                                    r.dispatch({
                                        type: "REMOVE_EVENTS",
                                        eventStore: l
                                    })
                                }
                            }, r.emitter.trigger("eventAdd", h), d.isTouch && r.dispatch({
                                type: "SELECT_EVENT",
                                eventInstanceId: s.instanceId
                            }), r.emitter.trigger("drop", Object.assign(Object.assign({}, ma(c.dateSpan, r)), {
                                draggedEl: d.subjectEl,
                                jsEvent: d.origEvent,
                                view: c.context.viewApi
                            })), r.emitter.trigger("eventReceive", Object.assign(Object.assign({}, h), {
                                draggedEl: d.subjectEl,
                                view: c.context.viewApi
                            })))
                        }
                    else e.emitter.trigger("_noEventDrop")
                }
                this.cleanup()
            };
            var t = this.component,
                t = t.context.options,
                r = this.dragging = new ha(e.el),
                r = (r.pointer.selector = va.SELECTOR, r.touchScrollAllowed = !1, r.autoScroller.isEnabled = t.dragScroll, this.hitDragging = new ga(this.dragging, mi));
            r.useSubjectCenter = e.useEventCenter, r.emitter.on("pointerdown", this.handlePointerDown), r.emitter.on("dragstart", this.handleDragStart), r.emitter.on("hitupdate", this.handleHitUpdate), r.emitter.on("pointerup", this.handlePointerUp), r.emitter.on("dragend", this.handleDragEnd)
        }
        destroy() {
            this.dragging.destroy()
        }
        displayDrag(e, t) {
            var r = this.component.context,
                n = this.receivingContext;
            n && n !== e && (n === r ? n.dispatch({
                type: "SET_EVENT_DRAG",
                state: {
                    affectedEvents: t.affectedEvents,
                    mutatedEvents: {
                        defs: {},
                        instances: {}
                    },
                    isEvent: !0
                }
            }) : n.dispatch({
                type: "UNSET_EVENT_DRAG"
            })), e && e.dispatch({
                type: "SET_EVENT_DRAG",
                state: t
            })
        }
        clearDrag() {
            var e = this.component.context,
                t = this.receivingContext;
            t && t.dispatch({
                type: "UNSET_EVENT_DRAG"
            }), e !== t && e.dispatch({
                type: "UNSET_EVENT_DRAG"
            })
        }
        cleanup() {
            this.subjectSeg = null, this.isDragging = !1, this.eventRange = null, this.relevantEvents = null, this.receivingContext = null, this.validMutation = null, this.mutatedRelevantEvents = null
        }
    }
    va.SELECTOR = ".fc-event-draggable, .fc-event-resizable";
    var ya = {
            fixedMirrorParent: r
        },
        ba = {
            dateClick: r,
            eventDragStart: r,
            eventDragStop: r,
            eventDrop: r,
            eventResizeStart: r,
            eventResizeStop: r,
            eventResize: r,
            drop: r,
            eventReceive: r,
            eventLeave: r
        };
    class Sa {
        constructor(e, t) {
            this.receivingContext = null, this.droppableEvent = null, this.suppliedDragMeta = null, this.dragMeta = null, this.handleDragStart = e => {
                this.dragMeta = this.buildDragMeta(e.subjectEl)
            }, this.handleHitUpdate = (e, t, r) => {
                let n = this.hitDragging.dragging,
                    i = null,
                    s = null,
                    o = !1,
                    a = {
                        affectedEvents: {
                            defs: {},
                            instances: {}
                        },
                        mutatedEvents: {
                            defs: {},
                            instances: {}
                        },
                        isEvent: this.dragMeta.create
                    };
                e && (i = e.context, this.canDropElOnCalendar(r.subjectEl, i)) && (s = ((e, t, r) => {
                    var n, i = Object.assign({}, t.leftoverProps);
                    for (n of r.pluginHooks.externalDefTransforms) Object.assign(i, n(e, t));
                    let {
                        refined: s,
                        extra: o
                    } = gn(i, r), a = mn(s, o, t.sourceId, e.allDay, r.options.forceEventDuration || Boolean(t.duration), r), l = e.range.start;
                    return e.allDay && t.startTime && (l = r.dateEnv.add(l, t.startTime)), r = t.duration ? r.dateEnv.add(l, t.duration) : zn(e.allDay, l, r), {
                        def: a,
                        instance: ln(a.defId, {
                            start: l,
                            end: r
                        })
                    }
                })(e.dateSpan, this.dragMeta, i), a.mutatedEvents = yn(s), o = !ps(a, e.dateProfile, i)) && (a.mutatedEvents = {
                    defs: {},
                    instances: {}
                }, s = null), this.displayDrag(i, a), n.setMirrorIsVisible(t || !s || !document.querySelector(".fc-event-mirror")), (o ? ut : ht)(), t || (n.setMirrorNeedsRevert(!s), this.receivingContext = i, this.droppableEvent = s)
            }, this.handleDragEnd = t => {
                let {
                    receivingContext: r,
                    droppableEvent: n
                } = this;
                if (this.clearDrag(), r && n) {
                    var e = this.hitDragging.finalHit,
                        i = e.context.viewApi,
                        s = this.dragMeta;
                    if (r.emitter.trigger("drop", Object.assign(Object.assign({}, ma(e.dateSpan, r)), {
                            draggedEl: t.subjectEl,
                            jsEvent: t.origEvent,
                            view: i
                        })), s.create) {
                        let e = yn(n);
                        r.dispatch({
                            type: "MERGE_EVENTS",
                            eventStore: e
                        }), t.isTouch && r.dispatch({
                            type: "SELECT_EVENT",
                            eventInstanceId: n.instance.instanceId
                        }), r.emitter.trigger("eventReceive", {
                            event: new P(r, n.def, n.instance),
                            relatedEvents: [],
                            revert() {
                                r.dispatch({
                                    type: "REMOVE_EVENTS",
                                    eventStore: e
                                })
                            },
                            draggedEl: t.subjectEl,
                            view: i
                        })
                    }
                }
                this.receivingContext = null, this.droppableEvent = null
            };
            e = this.hitDragging = new ga(e, mi);
            e.requireInitial = !1, e.emitter.on("dragstart", this.handleDragStart), e.emitter.on("hitupdate", this.handleHitUpdate), e.emitter.on("dragend", this.handleDragEnd), this.suppliedDragMeta = t
        }
        buildDragMeta(e) {
            return "object" == typeof this.suppliedDragMeta ? rs(this.suppliedDragMeta) : "function" == typeof this.suppliedDragMeta ? rs(this.suppliedDragMeta(e)) : (e = e, t = N.dataAttrPrefix, rs((e = e.getAttribute("data-" + ((t ? t + "-" : "") + "event")) || "") ? JSON.parse(e) : {
                create: !1
            }));
            var t
        }
        displayDrag(e, t) {
            var r = this.receivingContext;
            r && r !== e && r.dispatch({
                type: "UNSET_EVENT_DRAG"
            }), e && e.dispatch({
                type: "SET_EVENT_DRAG",
                state: t
            })
        }
        clearDrag() {
            this.receivingContext && this.receivingContext.dispatch({
                type: "UNSET_EVENT_DRAG"
            })
        }
        canDropElOnCalendar(e, t) {
            var r = t.options.dropAccept;
            return "function" == typeof r ? r.call(t.calendarApi, e) : "string" != typeof r || !r || Boolean(Xe(e, r))
        }
    }
    N.dataAttrPrefix = "";
    class Ea extends es {
        constructor(e) {
            super(e), this.shouldIgnoreMove = !1, this.mirrorSelector = "", this.currentMirrorEl = null, this.handlePointerDown = e => {
                this.emitter.trigger("pointerdown", e), this.shouldIgnoreMove || this.emitter.trigger("dragstart", e)
            }, this.handlePointerMove = e => {
                this.shouldIgnoreMove || this.emitter.trigger("dragmove", e)
            }, this.handlePointerUp = e => {
                this.emitter.trigger("pointerup", e), this.shouldIgnoreMove || this.emitter.trigger("dragend", e)
            };
            e = this.pointer = new ia(e);
            e.emitter.on("pointerdown", this.handlePointerDown), e.emitter.on("pointermove", this.handlePointerMove), e.emitter.on("pointerup", this.handlePointerUp)
        }
        destroy() {
            this.pointer.destroy()
        }
        setIgnoreMove(e) {
            this.shouldIgnoreMove = e
        }
        setMirrorIsVisible(e) {
            e ? this.currentMirrorEl && (this.currentMirrorEl.style.visibility = "", this.currentMirrorEl = null) : (e = this.mirrorSelector ? document.querySelector(this.mirrorSelector) : null) && ((this.currentMirrorEl = e).style.visibility = "hidden")
        }
    }
    ya = C({
        name: "@fullcalendar/interaction",
        componentInteractions: [class extends gi {
            constructor(e) {
                super(e), this.handlePointerDown = e => {
                    var t = this.dragging,
                        e = e.origEvent.target;
                    t.setIgnoreMove(!this.component.isValidDateDownEl(e))
                }, this.handleDragEnd = e => {
                    var t, r = this.component,
                        n = this.dragging.pointer;
                    n.wasTouchScroll || ({
                        initialHit: n,
                        finalHit: t
                    } = this.hitDragging, n && t && pa(n, t) && (t = r.context, r = Object.assign(Object.assign({}, ma(n.dateSpan, t)), {
                        dayEl: n.dayEl,
                        jsEvent: e.origEvent,
                        view: t.viewApi || t.calendarApi.view
                    }), t.emitter.trigger("dateClick", r)))
                }, this.dragging = new ha(e.el), this.dragging.autoScroller.isEnabled = !1;
                e = this.hitDragging = new ga(this.dragging, pi(e));
                e.emitter.on("pointerdown", this.handlePointerDown), e.emitter.on("dragend", this.handleDragEnd)
            }
            destroy() {
                this.dragging.destroy()
            }
        }, class extends gi {
            constructor(e) {
                super(e), this.dragSelection = null, this.handlePointerDown = e => {
                    var {
                        component: r,
                        dragging: t
                    } = this, n = r.context.options, n = n.selectable && r.isValidDateDownEl(e.origEvent.target);
                    t.setIgnoreMove(!n), t.delay = e.isTouch ? (() => {
                        let e = r.context.options,
                            t = e.selectLongPressDelay;
                        return t = null == t ? e.longPressDelay : t
                    })() : null
                }, this.handleDragStart = e => {
                    this.component.context.calendarApi.unselect(e)
                }, this.handleHitUpdate = (e, t) => {
                    let r = this.component.context,
                        n = null,
                        i = !1;
                    var s;
                    e && (s = this.hitDragging.initialHit, (n = e.componentId === s.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(s, e) ? n : ((e, t, r) => {
                        var n, i = e.dateSpan,
                            s = t.dateSpan,
                            o = ((s = [i.range.start, i.range.end, s.range.start, s.range.end]).sort(Et), {});
                        for (n of r) {
                            var a = n(e, t);
                            if (!1 === a) return null;
                            a && Object.assign(o, a)
                        }
                        return o.range = {
                            start: s[0],
                            end: s[3]
                        }, o.allDay = i.allDay, o
                    })(s, e, r.pluginHooks.dateSelectionTransformers)) && ms(n, e.dateProfile, r) || (i = !0, n = null)), n ? r.dispatch({
                        type: "SELECT_DATES",
                        selection: n
                    }) : t || r.dispatch({
                        type: "UNSELECT_DATES"
                    }), (i ? ut : ht)(), t || (this.dragSelection = n)
                }, this.handlePointerUp = e => {
                    this.dragSelection && (jn(this.dragSelection, e, this.component.context), this.dragSelection = null)
                };
                var t = e.component,
                    t = t.context.options,
                    r = this.dragging = new ha(e.el),
                    r = (r.touchScrollAllowed = !1, r.minDistance = t.selectMinDistance || 0, r.autoScroller.isEnabled = t.dragScroll, this.hitDragging = new ga(this.dragging, pi(e)));
                r.emitter.on("pointerdown", this.handlePointerDown), r.emitter.on("dragstart", this.handleDragStart), r.emitter.on("hitupdate", this.handleHitUpdate), r.emitter.on("pointerup", this.handlePointerUp)
            }
            destroy() {
                this.dragging.destroy()
            }
        }, va, class extends gi {
            constructor(e) {
                super(e), this.draggingSegEl = null, this.draggingSeg = null, this.eventRange = null, this.relevantEvents = null, this.validMutation = null, this.mutatedRelevantEvents = null, this.handlePointerDown = e => {
                    var t = this.component,
                        r = Zn(this.querySegEl(e)),
                        r = this.eventRange = r.eventRange;
                    this.dragging.minDistance = t.context.options.eventDragMinDistance, this.dragging.setIgnoreMove(!this.component.isValidSegDownEl(e.origEvent.target) || e.isTouch && this.component.props.eventSelection !== r.instance.instanceId)
                }, this.handleDragStart = e => {
                    var t = this.component.context,
                        r = this.eventRange,
                        n = (this.relevantEvents = bn(t.getCurrentData().eventStore, this.eventRange.instance.instanceId), this.querySegEl(e));
                    this.draggingSegEl = n, this.draggingSeg = Zn(n), t.calendarApi.unselect(), t.emitter.trigger("eventResizeStart", {
                        el: n,
                        event: new P(t, r.def, r.instance),
                        jsEvent: e.origEvent,
                        view: t.viewApi
                    })
                }, this.handleHitUpdate = (e, t, r) => {
                    let n = this.component.context,
                        i = this.relevantEvents,
                        s = this.hitDragging.initialHit,
                        o = this.eventRange.instance,
                        a = null,
                        l = null,
                        c = !1,
                        d = {
                            affectedEvents: i,
                            mutatedEvents: {
                                defs: {},
                                instances: {}
                            },
                            isEvent: !0
                        };
                    (a = !e || e.componentId === s.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(s, e) ? a : ((e, t, r, n) => {
                        var i = e.context.dateEnv,
                            t = on(e.dateSpan.range.start, t.dateSpan.range.start, i, e.largeUnit);
                        if (r) {
                            if (i.add(n.start, t) < n.end) return {
                                startDelta: t
                            }
                        } else if (i.add(n.end, t) > n.start) return {
                            endDelta: t
                        };
                        return null
                    })(s, e, r.subjectEl.classList.contains("fc-event-resizer-start"), o.range)) && (l = Un(i, n.getCurrentData().eventUiBases, a, n), d.mutatedEvents = l, ps(d, e.dateProfile, n) || (c = !0, a = null, l = null, d.mutatedEvents = null)), l ? n.dispatch({
                        type: "SET_EVENT_RESIZE",
                        state: d
                    }) : n.dispatch({
                        type: "UNSET_EVENT_RESIZE"
                    }), (c ? ut : ht)(), t || (a && pa(s, e) && (a = null), this.validMutation = a, this.mutatedRelevantEvents = l)
                }, this.handleDragEnd = e => {
                    let t = this.component.context,
                        r = this.eventRange.def,
                        n = this.eventRange.instance,
                        i = new P(t, r, n),
                        s = this.relevantEvents,
                        o = this.mutatedRelevantEvents;
                    var a;
                    t.emitter.trigger("eventResizeStop", {
                        el: this.draggingSegEl,
                        event: i,
                        jsEvent: e.origEvent,
                        view: t.viewApi
                    }), this.validMutation ? (a = new P(t, o.defs[r.defId], n ? o.instances[n.instanceId] : null), t.dispatch({
                        type: "MERGE_EVENTS",
                        eventStore: o
                    }), a = {
                        oldEvent: i,
                        event: a,
                        relatedEvents: Vn(o, t, n),
                        revert() {
                            t.dispatch({
                                type: "MERGE_EVENTS",
                                eventStore: s
                            })
                        }
                    }, t.emitter.trigger("eventResize", Object.assign(Object.assign({}, a), {
                        el: this.draggingSegEl,
                        startDelta: this.validMutation.startDelta || M(0),
                        endDelta: this.validMutation.endDelta || M(0),
                        jsEvent: e.origEvent,
                        view: t.viewApi
                    })), t.emitter.trigger("eventChange", a)) : t.emitter.trigger("_noEventResize"), this.draggingSeg = null, this.relevantEvents = null, this.validMutation = null
                };
                var t = e.component,
                    r = this.dragging = new ha(e.el),
                    r = (r.pointer.selector = ".fc-event-resizer", r.touchScrollAllowed = !1, r.autoScroller.isEnabled = t.context.options.dragScroll, this.hitDragging = new ga(this.dragging, pi(e)));
                r.emitter.on("pointerdown", this.handlePointerDown), r.emitter.on("dragstart", this.handleDragStart), r.emitter.on("hitupdate", this.handleHitUpdate), r.emitter.on("dragend", this.handleDragEnd)
            }
            destroy() {
                this.dragging.destroy()
            }
            querySegEl(e) {
                return l(e.subjectEl, ".fc-event")
            }
        }],
        calendarInteractions: [class {
            constructor(e) {
                this.context = e, this.isRecentPointerDateSelect = !1, this.matchesCancel = !1, this.matchesEvent = !1, this.onSelect = e => {
                    e.jsEvent && (this.isRecentPointerDateSelect = !0)
                }, this.onDocumentPointerDown = e => {
                    var t = this.context.options.unselectCancel,
                        e = rt(e.origEvent);
                    this.matchesCancel = !!l(e, t), this.matchesEvent = !!l(e, va.SELECTOR)
                }, this.onDocumentPointerUp = e => {
                    var t = this.context,
                        r = this.documentPointer,
                        n = t.getCurrentData();
                    r.wasTouchScroll || (n.dateSelection && !this.isRecentPointerDateSelect && t.options.unselectAuto && !this.matchesCancel && t.calendarApi.unselect(e), n.eventSelection && !this.matchesEvent && t.dispatch({
                        type: "UNSELECT_EVENT"
                    })), this.isRecentPointerDateSelect = !1
                };
                var t = this.documentPointer = new ia(document);
                t.shouldIgnoreMove = !0, t.shouldWatchScroll = !1, t.emitter.on("pointerdown", this.onDocumentPointerDown), t.emitter.on("pointerup", this.onDocumentPointerUp), e.emitter.on("select", this.onSelect)
            }
            destroy() {
                this.context.emitter.off("select", this.onSelect), this.documentPointer.destroy()
            }
        }],
        elementDraggingImpl: ha,
        optionRefiners: ya,
        listenerRefiners: ba
    });
    class Ca extends a {
        constructor() {
            super(...arguments), this.headerElRef = {
                current: null
            }
        }
        renderSimpleLayout(e, t) {
            var {
                props: r,
                context: n
            } = this, i = [], s = Ps(n.options);
            return e && i.push({
                type: "header",
                key: "header",
                isSticky: s,
                chunk: {
                    elRef: this.headerElRef,
                    tableClassName: "fc-col-header",
                    rowContent: e
                }
            }), i.push({
                type: "body",
                key: "body",
                liquid: !0,
                chunk: {
                    content: t
                }
            }), b(Zr, {
                elClasses: ["fc-daygrid"],
                viewSpec: n.viewSpec
            }, b(Hs, {
                liquid: !r.isHeightAuto && !r.forPrint,
                collapsibleWidth: r.forPrint,
                cols: [],
                sections: i
            }))
        }
        renderHScrollLayout(e, t, r, n) {
            var i, s, o, a, l, c = this.context.pluginHooks.scrollGridImpl;
            if (c) return {
                props: i,
                context: s
            } = this, o = !i.forPrint && Ps(s.options), a = !i.forPrint && Ns(s.options), l = [], e && l.push({
                type: "header",
                key: "header",
                isSticky: o,
                chunks: [{
                    key: "main",
                    elRef: this.headerElRef,
                    tableClassName: "fc-col-header",
                    rowContent: e
                }]
            }), l.push({
                type: "body",
                key: "body",
                liquid: !0,
                chunks: [{
                    key: "main",
                    content: t
                }]
            }), a && l.push({
                type: "footer",
                key: "footer",
                isSticky: !0,
                chunks: [{
                    key: "main",
                    content: Os
                }]
            }), b(Zr, {
                elClasses: ["fc-daygrid"],
                viewSpec: s.viewSpec
            }, b(c, {
                liquid: !i.isHeightAuto && !i.forPrint,
                forPrint: i.forPrint,
                collapsibleWidth: i.forPrint,
                colGroups: [{
                    cols: [{
                        span: r,
                        minWidth: n
                    }]
                }],
                sections: l
            }));
            throw new Error("No ScrollGrid implementation")
        }
    }

    function wa(e, t) {
        var r, n = [];
        for (let e = 0; e < t; e += 1) n[e] = [];
        for (r of e) n[r.row].push(r);
        return n
    }

    function Da(e, t) {
        var r, n = [];
        for (let e = 0; e < t; e += 1) n[e] = [];
        for (r of e) n[r.firstCol].push(r);
        return n
    }

    function Ra(t, r) {
        var n = [];
        if (t) {
            for (let e = 0; e < r; e += 1) n[e] = {
                affectedInstances: t.affectedInstances,
                isEvent: t.isEvent,
                segs: []
            };
            for (var e of t.segs) n[e.row].segs.push(e)
        } else
            for (let e = 0; e < r; e += 1) n[e] = null;
        return n
    }
    let Aa = I({
        hour: "numeric",
        minute: "2-digit",
        omitZeroMinute: !0,
        meridiem: "narrow"
    });

    function xa(e) {
        var t = e.eventRange.ui.display;
        return "list-item" === t || "auto" === t && !e.eventRange.def.allDay && e.firstCol === e.lastCol && e.isStart && e.isEnd
    }
    class Ta extends s {
        render() {
            var e = this.props;
            return b(Bs, Object.assign({}, e, {
                elClasses: ["fc-daygrid-event", "fc-daygrid-block-event", "fc-h-event"],
                defaultTimeFormat: Aa,
                defaultDisplayEventEnd: e.defaultDisplayEventEnd,
                disableResizing: !e.seg.eventRange.def.allDay
            }))
        }
    }
    class Ma extends s {
        render() {
            var {
                props: e,
                context: t
            } = this, r = t.options, n = e.seg, n = ei(n, r.eventTimeFormat || Aa, t, !0, e.defaultDisplayEventEnd);
            return b(Ws, Object.assign({}, e, {
                elTag: "a",
                elClasses: ["fc-daygrid-event", "fc-daygrid-dot-event"],
                elAttrs: ri(e.seg, t),
                defaultGenerator: ka,
                timeText: n,
                isResizing: !1,
                isDateSelecting: !1
            }))
        }
    }

    function ka(e) {
        return b(A, null, b("div", {
            className: "fc-daygrid-event-dot",
            style: {
                borderColor: e.borderColor || e.backgroundColor
            }
        }), e.timeText && b("div", {
            className: "fc-event-time"
        }, e.timeText), b("div", {
            className: "fc-event-title"
        }, e.event.title || b(A, null, "")))
    }
    class _a extends s {
        constructor() {
            super(...arguments), this.compileSegs = f(Ia)
        }
        render() {
            let n = this.props,
                {
                    allSegs: e,
                    invisibleSegs: t
                } = this.compileSegs(n.singlePlacements);
            return b(Ks, {
                elClasses: ["fc-daygrid-more-link"],
                dateProfile: n.dateProfile,
                todayRange: n.todayRange,
                allDayDate: n.allDayDate,
                moreCnt: n.moreCnt,
                allSegs: e,
                hiddenSegs: t,
                alignmentElRef: n.alignmentElRef,
                alignGridTop: n.alignGridTop,
                extraDateSpan: n.extraDateSpan,
                popoverContent: () => {
                    let r = (n.eventDrag ? n.eventDrag.affectedInstances : null) || (n.eventResize ? n.eventResize.affectedInstances : null) || {};
                    return b(A, null, e.map(e => {
                        var t = e.eventRange.instance.instanceId;
                        return b("div", {
                            className: "fc-daygrid-event-harness",
                            key: t,
                            style: {
                                visibility: r[t] ? "hidden" : ""
                            }
                        }, xa(e) ? b(Ma, Object.assign({
                            seg: e,
                            isDragging: !1,
                            isSelected: t === n.eventSelection,
                            defaultDisplayEventEnd: !1
                        }, E(e, n.todayRange))) : b(Ta, Object.assign({
                            seg: e,
                            isDragging: !1,
                            isResizing: !1,
                            isDateSelecting: !1,
                            isSelected: t === n.eventSelection,
                            defaultDisplayEventEnd: !1
                        }, E(e, n.todayRange))))
                    }))
                }
            })
        }
    }

    function Ia(e) {
        var t, r = [],
            n = [];
        for (t of e) r.push(t.seg), t.isVisible || n.push(t.seg);
        return {
            allSegs: r,
            invisibleSegs: n
        }
    }
    let Oa = I({
        week: "narrow"
    });
    class Pa extends a {
        constructor() {
            super(...arguments), this.rootElRef = {
                current: null
            }, this.state = {
                dayNumberId: t()
            }, this.handleRootEl = e => {
                o(this.rootElRef, e), o(this.props.elRef, e)
            }
        }
        render() {
            let {
                context: r,
                props: n,
                state: i,
                rootElRef: s
            } = this, {
                options: o,
                dateEnv: e
            } = r, {
                date: a,
                dateProfile: t
            } = n, l = n.showDayNumber && ((e, t, r) => {
                var {
                    start: t,
                    end: n
                } = t, i = p(n, -1), s = r.getYear(t), o = r.getMonth(t), a = r.getYear(i), i = r.getMonth(i);
                return !(s === a && o === i) && Boolean(e.valueOf() === t.valueOf() || 1 === r.getDay(e) && e.valueOf() < n.valueOf())
            })(a, t.currentRange, e);
            return b(Us, {
                elTag: "td",
                elRef: this.handleRootEl,
                elClasses: ["fc-daygrid-day", ...n.extraClassNames || []],
                elAttrs: Object.assign(Object.assign(Object.assign({}, n.extraDataAttrs), n.showDayNumber ? {
                    "aria-labelledby": i.dayNumberId
                } : {}), {
                    role: "gridcell"
                }),
                defaultGenerator: Na,
                date: a,
                dateProfile: t,
                todayRange: n.todayRange,
                showDayNumber: n.showDayNumber,
                isMonthStart: l,
                extraRenderProps: n.extraRenderProps
            }, (e, t) => b("div", {
                ref: n.innerElRef,
                className: "fc-daygrid-day-frame fc-scrollgrid-sync-inner",
                style: {
                    minHeight: n.minHeight
                }
            }, n.showWeekNumber && b(Qs, {
                elTag: "a",
                elClasses: ["fc-daygrid-week-number"],
                elAttrs: Ii(r, a, "week"),
                date: a,
                defaultFormat: Oa
            }), !t.isDisabled && (n.showDayNumber || Gs(o) || n.forceDayTop) ? b("div", {
                className: "fc-daygrid-day-top"
            }, b(e, {
                elTag: "a",
                elClasses: ["fc-daygrid-day-number", l && "fc-daygrid-month-start"],
                elAttrs: Object.assign(Object.assign({}, Ii(r, a)), {
                    id: i.dayNumberId
                })
            })) : n.showDayNumber ? b("div", {
                className: "fc-daygrid-day-top",
                style: {
                    visibility: "hidden"
                }
            }, b("a", {
                className: "fc-daygrid-day-number"
            }, "")) : void 0, b("div", {
                className: "fc-daygrid-day-events",
                ref: n.fgContentElRef
            }, n.fgContent, b("div", {
                className: "fc-daygrid-day-bottom",
                style: {
                    marginTop: n.moreMarginTop
                }
            }, b(_a, {
                allDayDate: a,
                singlePlacements: n.singlePlacements,
                moreCnt: n.moreCnt,
                alignmentElRef: s,
                alignGridTop: !n.showDayNumber,
                extraDateSpan: n.extraDateSpan,
                dateProfile: n.dateProfile,
                eventSelection: n.eventSelection,
                eventDrag: n.eventDrag,
                eventResize: n.eventResize,
                todayRange: n.todayRange
            }))), b("div", {
                className: "fc-daygrid-day-bg"
            }, n.bgContent)))
        }
    }

    function Na(e) {
        return e.dayNumberText || b(A, null, "")
    }

    function Ha(e) {
        return e.eventRange.instance.instanceId + ":" + e.firstCol
    }

    function Wa(e) {
        return Ha(e) + ":" + e.lastCol
    }

    function Ba(t, e, r, n, i, s, o) {
        var a, l, c = new La(e => {
                e = t[e.index].eventRange.instance.instanceId + ":" + e.span.start + ":" + (e.span.end - 1);
                return i[e] || 1
            }),
            d = (c.allowReslicing = !0, c.strictOrder = n, !0 === e || !0 === r ? (c.maxCoord = s, c.hiddenConsumes = !0) : "number" == typeof e ? c.maxStackCnt = e : "number" == typeof r && (c.maxStackCnt = r, c.hiddenConsumes = !0), []),
            u = [];
        for (let e = 0; e < t.length; e += 1) {
            var h = t[e],
                f = Wa(h);
            null != i[f] ? d.push({
                index: e,
                span: {
                    start: h.firstCol,
                    end: h.lastCol + 1
                }
            }) : u.push(h)
        }
        let g = c.addSegs(d),
            y = c.toRects(),
            {
                singleColPlacements: p,
                multiColPlacements: m,
                leftoverMargins: v
            } = ((s, o) => {
                var a = ((e, t) => {
                        var r, n = [];
                        for (let e = 0; e < t; e += 1) n.push([]);
                        for (r of e)
                            for (let e = r.span.start; e < r.span.end; e += 1) n[e].push(r);
                        return n
                    })(y, o.length),
                    l = [],
                    c = [],
                    d = [];
                for (let i = 0; i < o.length; i += 1) {
                    let e = a[i],
                        t = [],
                        r = 0,
                        n = 0;
                    for (var u of e) {
                        var h = s[u.index];
                        t.push({
                            seg: ja(h, i, i + 1, o),
                            isVisible: !0,
                            isAbsolute: !1,
                            absoluteTop: u.levelCoord,
                            marginTop: u.levelCoord - r
                        }), r = u.levelCoord + u.thickness
                    }
                    var f, g = [];
                    r = 0, n = 0;
                    for (f of e) {
                        var p = s[f.index],
                            m = 1 < f.span.end - f.span.start,
                            v = f.span.start === i;
                        n += f.levelCoord - r, r = f.levelCoord + f.thickness, m ? (n += f.thickness, v && g.push({
                            seg: ja(p, f.span.start, f.span.end, o),
                            isVisible: !0,
                            isAbsolute: !0,
                            absoluteTop: f.levelCoord,
                            marginTop: 0
                        })) : v && (g.push({
                            seg: ja(p, f.span.start, f.span.end, o),
                            isVisible: !0,
                            isAbsolute: !1,
                            absoluteTop: f.levelCoord,
                            marginTop: n
                        }), n = 0)
                    }
                    l.push(t), c.push(g), d.push(n)
                }
                return {
                    singleColPlacements: l,
                    multiColPlacements: c,
                    leftoverMargins: d
                }
            })(t, o),
            b = [],
            S = [];
        for (a of u) {
            m[a.firstCol].push({
                seg: a,
                isVisible: !1,
                isAbsolute: !0,
                absoluteTop: 0,
                marginTop: 0
            });
            for (let e = a.firstCol; e <= a.lastCol; e += 1) p[e].push({
                seg: ja(a, e, e + 1, o),
                isVisible: !1,
                isAbsolute: !1,
                absoluteTop: 0,
                marginTop: 0
            })
        }
        for (let e = 0; e < o.length; e += 1) b.push(0);
        for (l of g) {
            var E = t[l.index],
                C = l.span;
            m[C.start].push({
                seg: ja(E, C.start, C.end, o),
                isVisible: !1,
                isAbsolute: !0,
                absoluteTop: 0,
                marginTop: 0
            });
            for (let e = C.start; e < C.end; e += 1) b[e] += 1, p[e].push({
                seg: ja(E, e, e + 1, o),
                isVisible: !1,
                isAbsolute: !1,
                absoluteTop: 0,
                marginTop: 0
            })
        }
        for (let e = 0; e < o.length; e += 1) S.push(v[e]);
        return {
            singleColPlacements: p,
            multiColPlacements: m,
            moreCnts: b,
            moreMarginTops: S
        }
    }

    function ja(e, t, r, n) {
        var i, s;
        return e.firstCol === t && e.lastCol === r - 1 ? e : (n = D(s = (i = e.eventRange).range, {
            start: n[t].date,
            end: _(n[r - 1].date, 1)
        }), Object.assign(Object.assign({}, e), {
            firstCol: t,
            lastCol: r - 1,
            eventRange: {
                def: i.def,
                ui: Object.assign(Object.assign({}, i.ui), {
                    durationEditable: !1
                }),
                instance: i.instance,
                range: n
            },
            isStart: e.isStart && n.start.valueOf() === s.start.valueOf(),
            isEnd: e.isEnd && n.end.valueOf() === s.end.valueOf()
        }))
    }
    class La extends Yi {
        constructor() {
            super(...arguments), this.hiddenConsumes = !1, this.forceHidden = {}
        }
        addSegs(e) {
            var e = super.addSegs(e),
                t = this.entriesByLevel,
                r = e => !this.forceHidden[Zi(e)];
            for (let e = 0; e < t.length; e += 1) t[e] = t[e].filter(r);
            return e
        }
        handleInvalidInsertion(e, t, r) {
            var {
                entriesByLevel: n,
                forceHidden: i
            } = this, {
                touchingEntry: s,
                touchingLevel: o,
                touchingLateral: a
            } = e;
            if (this.hiddenConsumes && s) {
                let e = Zi(s);
                if (!i[e])
                    if (this.allowReslicing) {
                        let e = Object.assign(Object.assign({}, s), {
                            span: Ji(s.span, t.span)
                        });
                        i[Zi(e)] = !0, n[o][a] = e, r.push(e), this.splitEntry(s, t, r)
                    } else i[e] = !0, r.push(s)
            }
            super.handleInvalidInsertion(e, t, r)
        }
    }
    class za extends a {
        constructor() {
            super(...arguments), this.cellElRefs = new y, this.frameElRefs = new y, this.fgElRefs = new y, this.segHarnessRefs = new y, this.rootElRef = {
                current: null
            }, this.state = {
                framePositions: null,
                maxContentHeight: null,
                segHeights: {}
            }, this.handleResize = e => {
                e && this.updateSizing(!0)
            }
        }
        render() {
            let {
                props: i,
                state: e,
                context: t
            } = this, r = t.options, n = i.cells.length, s = Da(i.businessHourSegs, n), o = Da(i.bgEventSegs, n), a = Da(this.getHighlightSegs(), n), l = Da(this.getMirrorSegs(), n), {
                singleColPlacements: c,
                multiColPlacements: d,
                moreCnts: u,
                moreMarginTops: h
            } = Ba(Kn(i.fgEventSegs, r.eventOrder), i.dayMaxEvents, i.dayMaxEventRows, r.eventOrderStrict, e.segHeights, e.maxContentHeight, i.cells), f = i.eventDrag && i.eventDrag.affectedInstances || i.eventResize && i.eventResize.affectedInstances || {};
            return b("tr", {
                ref: this.rootElRef,
                role: "row"
            }, i.renderIntro && i.renderIntro(), i.cells.map((e, t) => {
                var r = this.renderFgSegs(t, (i.forPrint ? c : d)[t], i.todayRange, f),
                    n = this.renderFgSegs(t, ((e, n) => {
                        if (!e.length) return [];
                        let t = (() => {
                            var e, t = {};
                            for (e of n)
                                for (var r of e) t[r.seg.eventRange.instance.instanceId] = r.absoluteTop;
                            return t
                        })();
                        return e.map(e => ({
                            seg: e,
                            isVisible: !0,
                            isAbsolute: !0,
                            absoluteTop: t[e.eventRange.instance.instanceId],
                            marginTop: 0
                        }))
                    })(l[t], d), i.todayRange, {}, Boolean(i.eventDrag), Boolean(i.eventResize), !1);
                return b(Pa, {
                    key: e.key,
                    elRef: this.cellElRefs.createRef(e.key),
                    innerElRef: this.frameElRefs.createRef(e.key),
                    dateProfile: i.dateProfile,
                    date: e.date,
                    showDayNumber: i.showDayNumbers,
                    showWeekNumber: i.showWeekNumbers && 0 === t,
                    forceDayTop: i.showWeekNumbers,
                    todayRange: i.todayRange,
                    eventSelection: i.eventSelection,
                    eventDrag: i.eventDrag,
                    eventResize: i.eventResize,
                    extraRenderProps: e.extraRenderProps,
                    extraDataAttrs: e.extraDataAttrs,
                    extraClassNames: e.extraClassNames,
                    extraDateSpan: e.extraDateSpan,
                    moreCnt: u[t],
                    moreMarginTop: h[t],
                    singlePlacements: c[t],
                    fgContentElRef: this.fgElRefs.createRef(e.key),
                    fgContent: b(A, null, b(A, null, r), b(A, null, n)),
                    bgContent: b(A, null, this.renderFillSegs(a[t], "highlight"), this.renderFillSegs(s[t], "non-business"), this.renderFillSegs(o[t], "bg-event")),
                    minHeight: i.cellMinHeight
                })
            }))
        }
        componentDidMount() {
            this.updateSizing(!0), this.context.addResizeHandler(this.handleResize)
        }
        componentDidUpdate(e, t) {
            var r = this.props;
            this.updateSizing(!h(e, r))
        }
        componentWillUnmount() {
            this.context.removeResizeHandler(this.handleResize)
        }
        getHighlightSegs() {
            var e = this.props;
            return e.eventDrag && e.eventDrag.segs.length ? e.eventDrag.segs : e.eventResize && e.eventResize.segs.length ? e.eventResize.segs : e.dateSelectionSegs
        }
        getMirrorSegs() {
            var e = this.props;
            return e.eventResize && e.eventResize.segs.length ? e.eventResize.segs : []
        }
        renderFgSegs(e, t, o, a, l, c, d) {
            var u = this.context,
                h = this.props.eventSelection,
                f = this.state.framePositions,
                g = 1 === this.props.cells.length,
                p = l || c || d,
                m = [];
            if (f)
                for (var v of t) {
                    let e = v.seg,
                        t = e.eventRange.instance.instanceId,
                        r = v.isVisible && !a[t],
                        n = v.isAbsolute,
                        i = "",
                        s = "";
                    n && (u.isRtl ? (s = 0, i = f.lefts[e.lastCol] - f.lefts[e.firstCol]) : (i = 0, s = f.rights[e.firstCol] - f.rights[e.lastCol])), m.push(b("div", {
                        className: "fc-daygrid-event-harness" + (n ? " fc-daygrid-event-harness-abs" : ""),
                        key: Ha(e),
                        ref: p ? null : this.segHarnessRefs.createRef(Wa(e)),
                        style: {
                            visibility: r ? "" : "hidden",
                            marginTop: n ? "" : v.marginTop,
                            top: n ? v.absoluteTop : "",
                            left: i,
                            right: s
                        }
                    }, xa(e) ? b(Ma, Object.assign({
                        seg: e,
                        isDragging: l,
                        isSelected: t === h,
                        defaultDisplayEventEnd: g
                    }, E(e, o))) : b(Ta, Object.assign({
                        seg: e,
                        isDragging: l,
                        isResizing: c,
                        isDateSelecting: d,
                        isSelected: t === h,
                        defaultDisplayEventEnd: g
                    }, E(e, o)))))
                }
            return m
        }
        renderFillSegs(e, t) {
            var r = this.context.isRtl,
                n = this.props.todayRange,
                i = this.state.framePositions,
                s = [];
            if (i)
                for (var o of e) {
                    var a = r ? {
                        right: 0,
                        left: i.lefts[o.lastCol] - i.lefts[o.firstCol]
                    } : {
                        left: 0,
                        right: i.rights[o.firstCol] - i.rights[o.lastCol]
                    };
                    s.push(b("div", {
                        key: ti(o.eventRange),
                        className: "fc-daygrid-bg-harness",
                        style: a
                    }, "bg-event" === t ? b(Vs, Object.assign({
                        seg: o
                    }, E(o, n))) : Ys(t)))
                }
            return b(A, {}, ...s)
        }
        updateSizing(e) {
            let {
                props: t,
                state: r,
                frameElRefs: n
            } = this;
            var i, s;
            t.forPrint || null === t.clientWidth || (e && (e = t.cells.map(e => n.currentMap[e.key])).length && (s = this.rootElRef.current, i = new Ui(s, e, !0, !1), r.framePositions && r.framePositions.similarTo(i) || this.setState({
                framePositions: new Ui(s, e, !0, !1)
            })), i = this.state.segHeights, s = this.querySegHeights(), e = !0 === t.dayMaxEvents || !0 === t.dayMaxEventRows, this.safeSetState({
                segHeights: Object.assign(Object.assign({}, i), s),
                maxContentHeight: e ? this.computeMaxContentHeight() : null
            }))
        }
        querySegHeights() {
            var e, t = this.segHarnessRefs.currentMap,
                r = {};
            for (e in t) {
                var n = Math.round(t[e].getBoundingClientRect().height);
                r[e] = Math.max(r[e] || 0, n)
            }
            return r
        }
        computeMaxContentHeight() {
            var e = this.props.cells[0].key,
                t = this.cellElRefs.currentMap[e],
                e = this.fgElRefs.currentMap[e];
            return t.getBoundingClientRect().bottom - e.getBoundingClientRect().top
        }
        getCellEls() {
            let t = this.cellElRefs.currentMap;
            return this.props.cells.map(e => t[e.key])
        }
    }
    za.addStateEquality({
        segHeights: h
    });
    class Ua extends a {
        constructor() {
            super(...arguments), this.splitBusinessHourSegs = f(wa), this.splitBgEventSegs = f(Ga), this.splitFgEventSegs = f(wa), this.splitDateSelectionSegs = f(wa), this.splitEventDrag = f(Ra), this.splitEventResize = f(Ra), this.rowRefs = new y
        }
        render() {
            let {
                props: n,
                context: e
            } = this, i = n.cells.length, s = this.splitBusinessHourSegs(n.businessHourSegs, i), o = this.splitBgEventSegs(n.bgEventSegs, i), a = this.splitFgEventSegs(n.fgEventSegs, i), l = this.splitDateSelectionSegs(n.dateSelectionSegs, i), c = this.splitEventDrag(n.eventDrag, i), d = this.splitEventResize(n.eventResize, i), u = 7 <= i && n.clientWidth ? n.clientWidth / e.options.aspectRatio / 6 : null;
            return b(m, {
                unit: "day"
            }, (e, r) => b(A, null, n.cells.map((e, t) => b(za, {
                ref: this.rowRefs.createRef(t),
                key: e.length ? e[0].date.toISOString() : t,
                showDayNumbers: 1 < i,
                showWeekNumbers: n.showWeekNumbers,
                todayRange: r,
                dateProfile: n.dateProfile,
                cells: e,
                renderIntro: n.renderRowIntro,
                businessHourSegs: s[t],
                eventSelection: n.eventSelection,
                bgEventSegs: o[t],
                fgEventSegs: a[t],
                dateSelectionSegs: l[t],
                eventDrag: c[t],
                eventResize: d[t],
                dayMaxEvents: n.dayMaxEvents,
                dayMaxEventRows: n.dayMaxEventRows,
                clientWidth: n.clientWidth,
                clientHeight: n.clientHeight,
                cellMinHeight: u,
                forPrint: n.forPrint
            }))))
        }
        componentDidMount() {
            this.registerInteractiveComponent()
        }
        componentDidUpdate() {
            this.registerInteractiveComponent()
        }
        registerInteractiveComponent() {
            var e;
            this.rootEl || (e = (e = this.rowRefs.currentMap[0].getCellEls()[0]) ? e.closest(".fc-daygrid-body") : null) && (this.rootEl = e, this.context.registerInteractiveComponent(this, {
                el: e,
                isHitComboAllowed: this.props.isHitComboAllowed
            }))
        }
        componentWillUnmount() {
            this.rootEl && (this.context.unregisterInteractiveComponent(this), this.rootEl = null)
        }
        prepareHits() {
            this.rowPositions = new Ui(this.rootEl, this.rowRefs.collect().map(e => e.getCellEls()[0]), !1, !0), this.colPositions = new Ui(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), !0, !1)
        }
        queryHit(e, t) {
            var r, {
                    colPositions: n,
                    rowPositions: i
                } = this,
                e = n.leftToIndex(e),
                t = i.topToIndex(t);
            return null != t && null != e ? (r = this.props.cells[t][e], {
                dateProfile: this.props.dateProfile,
                dateSpan: Object.assign({
                    range: this.getCellRange(t, e),
                    allDay: !0
                }, r.extraDateSpan),
                dayEl: this.getCellEl(t, e),
                rect: {
                    left: n.lefts[e],
                    right: n.rights[e],
                    top: i.tops[t],
                    bottom: i.bottoms[t]
                },
                layer: 0
            }) : null
        }
        getCellEl(e, t) {
            return this.rowRefs.currentMap[e].getCellEls()[t]
        }
        getCellRange(e, t) {
            e = this.props.cells[e][t].date;
            return {
                start: e,
                end: _(e, 1)
            }
        }
    }

    function Ga(e, t) {
        return wa(e.filter(Fa), t)
    }

    function Fa(e) {
        return e.eventRange.def.allDay
    }
    class Va extends a {
        constructor() {
            super(...arguments), this.elRef = {
                current: null
            }, this.needsScrollReset = !1
        }
        render() {
            let e = this.props,
                {
                    dayMaxEventRows: t,
                    dayMaxEvents: r,
                    expandRows: n
                } = e,
                i = !0 === r || !0 === t;
            i && !n && (i = !1, t = null, r = null);
            var s = ["fc-daygrid-body", i ? "fc-daygrid-body-balanced" : "fc-daygrid-body-unbalanced", n ? "" : "fc-daygrid-body-natural"];
            return b("div", {
                ref: this.elRef,
                className: s.join(" "),
                style: {
                    width: e.clientWidth,
                    minWidth: e.tableMinWidth
                }
            }, b("table", {
                role: "presentation",
                className: "fc-scrollgrid-sync-table",
                style: {
                    width: e.clientWidth,
                    minWidth: e.tableMinWidth,
                    height: n ? e.clientHeight : ""
                }
            }, e.colGroupNode, b("tbody", {
                role: "presentation"
            }, b(Ua, {
                dateProfile: e.dateProfile,
                cells: e.cells,
                renderRowIntro: e.renderRowIntro,
                showWeekNumbers: e.showWeekNumbers,
                clientWidth: e.clientWidth,
                clientHeight: e.clientHeight,
                businessHourSegs: e.businessHourSegs,
                bgEventSegs: e.bgEventSegs,
                fgEventSegs: e.fgEventSegs,
                dateSelectionSegs: e.dateSelectionSegs,
                eventSelection: e.eventSelection,
                eventDrag: e.eventDrag,
                eventResize: e.eventResize,
                dayMaxEvents: r,
                dayMaxEventRows: t,
                forPrint: e.forPrint,
                isHitComboAllowed: e.isHitComboAllowed
            }))))
        }
        componentDidMount() {
            this.requestScrollReset()
        }
        componentDidUpdate(e) {
            e.dateProfile !== this.props.dateProfile ? this.requestScrollReset() : this.flushScrollReset()
        }
        requestScrollReset() {
            this.needsScrollReset = !0, this.flushScrollReset()
        }
        flushScrollReset() {
            var e, t, r;
            this.needsScrollReset && this.props.clientWidth && ((r = ((e, t) => {
                let r;
                return r = (r = t.currentRangeUnit.match(/year|month/) ? e.querySelector(`[data-date="${Xt(t.currentDate)}-01"]`) : r) || e.querySelector(`[data-date="${Zt(t.currentDate)}"]`)
            })(this.elRef.current, this.props.dateProfile)) && (t = (e = r.closest(".fc-daygrid-body")).closest(".fc-scroller"), r = r.getBoundingClientRect().top - e.getBoundingClientRect().top, t.scrollTop = r ? 1 + r : 0), this.needsScrollReset = !1)
        }
    }
    class qa extends fs {
        constructor() {
            super(...arguments), this.forceDayIfListItem = !0
        }
        sliceRange(e, t) {
            return t.sliceRange(e)
        }
    }
    class Ya extends a {
        constructor() {
            super(...arguments), this.slicer = new qa, this.tableRef = {
                current: null
            }
        }
        render() {
            var {
                props: e,
                context: t
            } = this;
            return b(Va, Object.assign({
                ref: this.tableRef
            }, this.slicer.sliceProps(e, e.dateProfile, e.nextDayThreshold, t, e.dayTableModel), {
                dateProfile: e.dateProfile,
                cells: e.dayTableModel.cells,
                colGroupNode: e.colGroupNode,
                tableMinWidth: e.tableMinWidth,
                renderRowIntro: e.renderRowIntro,
                dayMaxEvents: e.dayMaxEvents,
                dayMaxEventRows: e.dayMaxEventRows,
                showWeekNumbers: e.showWeekNumbers,
                expandRows: e.expandRows,
                headerAlignElRef: e.headerAlignElRef,
                clientWidth: e.clientWidth,
                clientHeight: e.clientHeight,
                forPrint: e.forPrint
            }))
        }
    }

    function Qa(e, t) {
        t = new us(e.renderRange, t);
        return new hs(t, /year|month|week/.test(e.currentRangeUnit))
    }
    class Za extends an {
        buildRenderRange(e, t, r) {
            var n = this.props;
            return Xa({
                currentRange: super.buildRenderRange(e, t, r),
                snapToWeek: /^(year|month)$/.test(t),
                fixedWeekCount: n.fixedWeekCount,
                dateEnv: n.dateEnv
            })
        }
    }

    function Xa(e) {
        let t, {
                dateEnv: r,
                currentRange: n
            } = e,
            {
                start: i,
                end: s
            } = n;
        return e.snapToWeek && (i = r.startOfWeek(i), (t = r.startOfWeek(s)).valueOf() !== s.valueOf()) && (s = Ht(t, 1)), e.fixedWeekCount && (e = r.startOfWeek(r.startOfMonth(_(n.end, -1))), s = Ht(s, 6 - Math.ceil(Wt(e, s)))), {
            start: i,
            end: s
        }
    }
    Fe(':root{--fc-daygrid-event-dot-width:8px}.fc-daygrid-day-events:after,.fc-daygrid-day-events:before,.fc-daygrid-day-frame:after,.fc-daygrid-day-frame:before,.fc-daygrid-event-harness:after,.fc-daygrid-event-harness:before{clear:both;content:"";display:table}.fc .fc-daygrid-body{position:relative;z-index:1}.fc .fc-daygrid-day.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-daygrid-day-frame{min-height:100%;position:relative}.fc .fc-daygrid-day-top{display:flex;flex-direction:row-reverse}.fc .fc-day-other .fc-daygrid-day-top{opacity:.3}.fc .fc-daygrid-day-number{padding:4px;position:relative;z-index:4}.fc .fc-daygrid-month-start{font-size:1.1em;font-weight:700}.fc .fc-daygrid-day-events{margin-top:1px}.fc .fc-daygrid-body-balanced .fc-daygrid-day-events{left:0;position:absolute;right:0}.fc .fc-daygrid-body-unbalanced .fc-daygrid-day-events{min-height:2em;position:relative}.fc .fc-daygrid-body-natural .fc-daygrid-day-events{margin-bottom:1em}.fc .fc-daygrid-event-harness{position:relative}.fc .fc-daygrid-event-harness-abs{left:0;position:absolute;right:0;top:0}.fc .fc-daygrid-bg-harness{bottom:0;position:absolute;top:0}.fc .fc-daygrid-day-bg .fc-non-business{z-index:1}.fc .fc-daygrid-day-bg .fc-bg-event{z-index:2}.fc .fc-daygrid-day-bg .fc-highlight{z-index:3}.fc .fc-daygrid-event{margin-top:1px;z-index:6}.fc .fc-daygrid-event.fc-event-mirror{z-index:7}.fc .fc-daygrid-day-bottom{font-size:.85em;margin:0 2px}.fc .fc-daygrid-day-bottom:after,.fc .fc-daygrid-day-bottom:before{clear:both;content:"";display:table}.fc .fc-daygrid-more-link{border-radius:3px;cursor:pointer;line-height:1;margin-top:1px;max-width:100%;overflow:hidden;padding:2px;position:relative;white-space:nowrap;z-index:4}.fc .fc-daygrid-more-link:hover{background-color:rgba(0,0,0,.1)}.fc .fc-daygrid-week-number{background-color:var(--fc-neutral-bg-color);color:var(--fc-neutral-text-color);min-width:1.5em;padding:2px;position:absolute;text-align:center;top:0;z-index:5}.fc .fc-more-popover .fc-popover-body{min-width:220px;padding:10px}.fc-direction-ltr .fc-daygrid-event.fc-event-start,.fc-direction-rtl .fc-daygrid-event.fc-event-end{margin-left:2px}.fc-direction-ltr .fc-daygrid-event.fc-event-end,.fc-direction-rtl .fc-daygrid-event.fc-event-start{margin-right:2px}.fc-direction-ltr .fc-daygrid-more-link{float:left}.fc-direction-ltr .fc-daygrid-week-number{border-radius:0 0 3px 0;left:0}.fc-direction-rtl .fc-daygrid-more-link{float:right}.fc-direction-rtl .fc-daygrid-week-number{border-radius:0 0 0 3px;right:0}.fc-liquid-hack .fc-daygrid-day-frame{position:static}.fc-daygrid-event{border-radius:3px;font-size:var(--fc-small-font-size);position:relative;white-space:nowrap}.fc-daygrid-block-event .fc-event-time{font-weight:700}.fc-daygrid-block-event .fc-event-time,.fc-daygrid-block-event .fc-event-title{padding:1px}.fc-daygrid-dot-event{align-items:center;display:flex;padding:2px 0}.fc-daygrid-dot-event .fc-event-title{flex-grow:1;flex-shrink:1;font-weight:700;min-width:0;overflow:hidden}.fc-daygrid-dot-event.fc-event-mirror,.fc-daygrid-dot-event:hover{background:rgba(0,0,0,.1)}.fc-daygrid-dot-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-daygrid-event-dot{border:calc(var(--fc-daygrid-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-daygrid-event-dot-width)/2);box-sizing:content-box;height:0;margin:0 4px;width:0}.fc-direction-ltr .fc-daygrid-event .fc-event-time{margin-right:3px}.fc-direction-rtl .fc-daygrid-event .fc-event-time{margin-left:3px}'), ba = C({
        name: "@fullcalendar/daygrid",
        initialView: "dayGridMonth",
        views: {
            dayGrid: {
                component: class extends Ca {
                    constructor() {
                        super(...arguments), this.buildDayTableModel = f(Qa), this.headerRef = {
                            current: null
                        }, this.tableRef = {
                            current: null
                        }
                    }
                    render() {
                        let {
                            options: t,
                            dateProfileGenerator: e
                        } = this.context, r = this.props, n = this.buildDayTableModel(r.dateProfile, e), i = t.dayHeaders && b(cs, {
                            ref: this.headerRef,
                            dateProfile: r.dateProfile,
                            dates: n.headerDates,
                            datesRepDistinctDays: 1 === n.rowCnt
                        }), s = e => b(Ya, {
                            ref: this.tableRef,
                            dateProfile: r.dateProfile,
                            dayTableModel: n,
                            businessHours: r.businessHours,
                            dateSelection: r.dateSelection,
                            eventStore: r.eventStore,
                            eventUiBases: r.eventUiBases,
                            eventSelection: r.eventSelection,
                            eventDrag: r.eventDrag,
                            eventResize: r.eventResize,
                            nextDayThreshold: t.nextDayThreshold,
                            colGroupNode: e.tableColGroupNode,
                            tableMinWidth: e.tableMinWidth,
                            dayMaxEvents: t.dayMaxEvents,
                            dayMaxEventRows: t.dayMaxEventRows,
                            showWeekNumbers: t.weekNumbers,
                            expandRows: !r.isHeightAuto,
                            headerAlignElRef: this.headerElRef,
                            clientWidth: e.clientWidth,
                            clientHeight: e.clientHeight,
                            forPrint: r.forPrint
                        });
                        return t.dayMinWidth ? this.renderHScrollLayout(i, s, n.colCnt, t.dayMinWidth) : this.renderSimpleLayout(i, s)
                    }
                },
                dateProfileGeneratorClass: Za
            },
            dayGridDay: {
                type: "dayGrid",
                duration: {
                    days: 1
                }
            },
            dayGridWeek: {
                type: "dayGrid",
                duration: {
                    weeks: 1
                }
            },
            dayGridMonth: {
                type: "dayGrid",
                duration: {
                    months: 1
                },
                fixedWeekCount: !0
            },
            dayGridYear: {
                type: "dayGrid",
                duration: {
                    years: 1
                }
            }
        }
    });
    class Ja extends Ri {
        getKeyInfo() {
            return {
                allDay: {},
                timed: {}
            }
        }
        getKeysForDateSpan(e) {
            return e.allDay ? ["allDay"] : ["timed"]
        }
        getKeysForEventDef(e) {
            return e.allDay ? Yn(e) ? ["timed", "allDay"] : ["allDay"] : ["timed"]
        }
    }
    let Ka = I({
        hour: "numeric",
        minute: "2-digit",
        omitZeroMinute: !0,
        meridiem: "short"
    });

    function $a(i) {
        let s = ["fc-timegrid-slot", "fc-timegrid-slot-label", i.isLabeled ? "fc-scrollgrid-shrink" : "fc-timegrid-slot-minor"];
        return b(u.Consumer, null, e => {
            var t, r, n;
            return i.isLabeled ? ({
                dateEnv: e,
                options: t,
                viewApi: n
            } = e, r = null == t.slotLabelFormat ? Ka : Array.isArray(t.slotLabelFormat) ? I(t.slotLabelFormat[0]) : I(t.slotLabelFormat), n = {
                level: 0,
                time: i.time,
                date: e.toDate(i.date),
                view: n,
                text: e.format(i.date, r)
            }, b(g, {
                elTag: "td",
                elClasses: s,
                elAttrs: {
                    "data-time": i.isoTimeStr
                },
                renderProps: n,
                generatorName: "slotLabelContent",
                customGenerator: t.slotLabelContent,
                defaultGenerator: el,
                classNameGenerator: t.slotLabelClassNames,
                didMount: t.slotLabelDidMount,
                willUnmount: t.slotLabelWillUnmount
            }, e => b("div", {
                className: "fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame"
            }, b(e, {
                elTag: "div",
                elClasses: ["fc-timegrid-slot-label-cushion", "fc-scrollgrid-shrink-cushion"]
            })))) : b("td", {
                className: s.join(" "),
                "data-time": i.isoTimeStr
            })
        })
    }

    function el(e) {
        return e.text
    }
    class tl extends s {
        render() {
            return this.props.slatMetas.map(e => b("tr", {
                key: e.key
            }, b($a, Object.assign({}, e))))
        }
    }
    let rl = I({
        week: "short"
    });
    class nl extends a {
        constructor() {
            super(...arguments), this.allDaySplitter = new Ja, this.headerElRef = {
                current: null
            }, this.rootElRef = {
                current: null
            }, this.scrollerElRef = {
                current: null
            }, this.state = {
                slatCoords: null
            }, this.handleScrollTopRequest = e => {
                var t = this.scrollerElRef.current;
                t && (t.scrollTop = e)
            }, this.renderHeadAxis = (e, t = "") => {
                let r = this.context.options,
                    n = this.props.dateProfile,
                    i = n.renderRange,
                    s = 1 === Bt(i.start, i.end) ? Ii(this.context, i.start, "week") : {};
                return r.weekNumbers && "day" === e ? b(Qs, {
                    elTag: "th",
                    elClasses: ["fc-timegrid-axis", "fc-scrollgrid-shrink"],
                    elAttrs: {
                        "aria-hidden": !0
                    },
                    date: i.start,
                    defaultFormat: rl
                }, e => b("div", {
                    className: ["fc-timegrid-axis-frame", "fc-scrollgrid-shrink-frame", "fc-timegrid-axis-frame-liquid"].join(" "),
                    style: {
                        height: t
                    }
                }, b(e, {
                    elTag: "a",
                    elClasses: ["fc-timegrid-axis-cushion", "fc-scrollgrid-shrink-cushion", "fc-scrollgrid-sync-inner"],
                    elAttrs: s
                }))) : b("th", {
                    "aria-hidden": !0,
                    className: "fc-timegrid-axis"
                }, b("div", {
                    className: "fc-timegrid-axis-frame",
                    style: {
                        height: t
                    }
                }))
            }, this.renderTableRowAxis = t => {
                var {
                    options: e,
                    viewApi: r
                } = this.context, r = {
                    text: e.allDayText,
                    view: r
                };
                return b(g, {
                    elTag: "td",
                    elClasses: ["fc-timegrid-axis", "fc-scrollgrid-shrink"],
                    elAttrs: {
                        "aria-hidden": !0
                    },
                    renderProps: r,
                    generatorName: "allDayContent",
                    customGenerator: e.allDayContent,
                    defaultGenerator: il,
                    classNameGenerator: e.allDayClassNames,
                    didMount: e.allDayDidMount,
                    willUnmount: e.allDayWillUnmount
                }, e => b("div", {
                    className: ["fc-timegrid-axis-frame", "fc-scrollgrid-shrink-frame", null == t ? " fc-timegrid-axis-frame-liquid" : ""].join(" "),
                    style: {
                        height: t
                    }
                }, b(e, {
                    elTag: "span",
                    elClasses: ["fc-timegrid-axis-cushion", "fc-scrollgrid-shrink-cushion", "fc-scrollgrid-sync-inner"]
                })))
            }, this.handleSlatCoords = e => {
                this.setState({
                    slatCoords: e
                })
            }
        }
        renderSimpleLayout(e, t, r) {
            var {
                context: n,
                props: i
            } = this, s = [], o = Ps(n.options);
            return e && s.push({
                type: "header",
                key: "header",
                isSticky: o,
                chunk: {
                    elRef: this.headerElRef,
                    tableClassName: "fc-col-header",
                    rowContent: e
                }
            }), t && (s.push({
                type: "body",
                key: "all-day",
                chunk: {
                    content: t
                }
            }), s.push({
                type: "body",
                key: "all-day-divider",
                outerContent: b("tr", {
                    role: "presentation",
                    className: "fc-scrollgrid-section"
                }, b("td", {
                    className: "fc-timegrid-divider " + n.theme.getClass("tableCellShaded")
                }))
            })), s.push({
                type: "body",
                key: "body",
                liquid: !0,
                expandRows: Boolean(n.options.expandRows),
                chunk: {
                    scrollerElRef: this.scrollerElRef,
                    content: r
                }
            }), b(Zr, {
                elRef: this.rootElRef,
                elClasses: ["fc-timegrid"],
                viewSpec: n.viewSpec
            }, b(Hs, {
                liquid: !i.isHeightAuto && !i.forPrint,
                collapsibleWidth: i.forPrint,
                cols: [{
                    width: "shrink"
                }],
                sections: s
            }))
        }
        renderHScrollLayout(e, t, r, n, i, s, o) {
            var a = this.context.pluginHooks.scrollGridImpl;
            if (!a) throw new Error("No ScrollGrid implementation");
            var {
                context: l,
                props: c
            } = this, d = !c.forPrint && Ps(l.options), u = !c.forPrint && Ns(l.options), h = [];
            e && h.push({
                type: "header",
                key: "header",
                isSticky: d,
                syncRowHeights: !0,
                chunks: [{
                    key: "axis",
                    rowContent: e => b("tr", {
                        role: "presentation"
                    }, this.renderHeadAxis("day", e.rowSyncHeights[0]))
                }, {
                    key: "cols",
                    elRef: this.headerElRef,
                    tableClassName: "fc-col-header",
                    rowContent: e
                }]
            }), t && (h.push({
                type: "body",
                key: "all-day",
                syncRowHeights: !0,
                chunks: [{
                    key: "axis",
                    rowContent: e => b("tr", {
                        role: "presentation"
                    }, this.renderTableRowAxis(e.rowSyncHeights[0]))
                }, {
                    key: "cols",
                    content: t
                }]
            }), h.push({
                key: "all-day-divider",
                type: "body",
                outerContent: b("tr", {
                    role: "presentation",
                    className: "fc-scrollgrid-section"
                }, b("td", {
                    colSpan: 2,
                    className: "fc-timegrid-divider " + l.theme.getClass("tableCellShaded")
                }))
            }));
            let f = l.options.nowIndicator;
            return h.push({
                type: "body",
                key: "body",
                liquid: !0,
                expandRows: Boolean(l.options.expandRows),
                chunks: [{
                    key: "axis",
                    content: e => b("div", {
                        className: "fc-timegrid-axis-chunk"
                    }, b("table", {
                        "aria-hidden": !0,
                        style: {
                            height: e.expandRows ? e.clientHeight : ""
                        }
                    }, e.tableColGroupNode, b("tbody", null, b(tl, {
                        slatMetas: s
                    }))), b("div", {
                        className: "fc-timegrid-now-indicator-container"
                    }, b(m, {
                        unit: f ? "minute" : "day"
                    }, e => {
                        var t = f && o && o.safeComputeTop(e);
                        return "number" == typeof t ? b(Ls, {
                            elClasses: ["fc-timegrid-now-indicator-arrow"],
                            elStyle: {
                                top: t
                            },
                            isAxis: !0,
                            date: e
                        }) : null
                    })))
                }, {
                    key: "cols",
                    scrollerElRef: this.scrollerElRef,
                    content: r
                }]
            }), u && h.push({
                key: "footer",
                type: "footer",
                isSticky: !0,
                chunks: [{
                    key: "axis",
                    content: Os
                }, {
                    key: "cols",
                    content: Os
                }]
            }), b(Zr, {
                elRef: this.rootElRef,
                elClasses: ["fc-timegrid"],
                viewSpec: l.viewSpec
            }, b(a, {
                liquid: !c.isHeightAuto && !c.forPrint,
                forPrint: c.forPrint,
                collapsibleWidth: !1,
                colGroups: [{
                    width: "shrink",
                    cols: [{
                        width: "shrink"
                    }]
                }, {
                    cols: [{
                        span: n,
                        minWidth: i
                    }]
                }],
                sections: h
            }))
        }
        getAllDayMaxEventProps() {
            let {
                dayMaxEvents: e,
                dayMaxEventRows: t
            } = this.context.options;
            return !0 !== e && !0 !== t || (e = void 0, t = 5), {
                dayMaxEvents: e,
                dayMaxEventRows: t
            }
        }
    }

    function il(e) {
        return e.text
    }
    class sl {
        constructor(e, t, r) {
            this.positions = e, this.dateProfile = t, this.slotDuration = r
        }
        safeComputeTop(e) {
            var t = this.dateProfile;
            if (S(t.currentRange, e)) {
                var r = v(e),
                    e = e.valueOf() - r.valueOf();
                if (e >= k(t.slotMinTime) && e < k(t.slotMaxTime)) return this.computeTimeTop(M(e))
            }
            return null
        }
        computeDateTop(e, t) {
            return t = t || v(e), this.computeTimeTop(M(e.valueOf() - t.valueOf()))
        }
        computeTimeTop(e) {
            var {
                positions: t,
                dateProfile: r
            } = this, n = t.els.length, e = (e.milliseconds - k(r.slotMinTime)) / k(this.slotDuration), e = Math.max(0, e);
            return e = Math.min(n, e), r = Math.floor(e), e = e - (r = Math.min(r, n - 1)), t.tops[r] + t.getHeight(r) * e
        }
    }
    class ol extends s {
        render() {
            let {
                props: n,
                context: i
            } = this, s = i.options, o = n.slatElRefs;
            return b("tbody", null, n.slatMetas.map((e, t) => {
                var r = {
                    time: e.time,
                    date: i.dateEnv.toDate(e.date),
                    view: i.viewApi
                };
                return b("tr", {
                    key: e.key,
                    ref: o.createRef(e.key)
                }, n.axis && b($a, Object.assign({}, e)), b(g, {
                    elTag: "td",
                    elClasses: ["fc-timegrid-slot", "fc-timegrid-slot-lane", !e.isLabeled && "fc-timegrid-slot-minor"],
                    elAttrs: {
                        "data-time": e.isoTimeStr
                    },
                    renderProps: r,
                    generatorName: "slotLaneContent",
                    customGenerator: s.slotLaneContent,
                    classNameGenerator: s.slotLaneClassNames,
                    didMount: s.slotLaneDidMount,
                    willUnmount: s.slotLaneWillUnmount
                }))
            }))
        }
    }
    class al extends s {
        constructor() {
            super(...arguments), this.rootElRef = {
                current: null
            }, this.slatElRefs = new y
        }
        render() {
            var {
                props: e,
                context: t
            } = this;
            return b("div", {
                ref: this.rootElRef,
                className: "fc-timegrid-slots"
            }, b("table", {
                "aria-hidden": !0,
                className: t.theme.getClass("table"),
                style: {
                    minWidth: e.tableMinWidth,
                    width: e.clientWidth,
                    height: e.minHeight
                }
            }, e.tableColGroupNode, b(ol, {
                slatElRefs: this.slatElRefs,
                axis: e.axis,
                slatMetas: e.slatMetas
            })))
        }
        componentDidMount() {
            this.updateSizing()
        }
        componentDidUpdate() {
            this.updateSizing()
        }
        componentWillUnmount() {
            this.props.onCoords && this.props.onCoords(null)
        }
        updateSizing() {
            var t, {
                context: e,
                props: r
            } = this;
            r.onCoords && null !== r.clientWidth && this.rootElRef.current.offsetHeight && r.onCoords(new sl(new Ui(this.rootElRef.current, (t = this.slatElRefs.currentMap, r.slatMetas.map(e => t[e.key])), !1, !0), this.props.dateProfile, e.options.slotDuration))
        }
    }

    function ll(e, t) {
        let r, n = [];
        for (r = 0; r < t; r += 1) n.push([]);
        if (e)
            for (r = 0; r < e.length; r += 1) n[e[r].col].push(e[r]);
        return n
    }

    function cl(t, r) {
        var n = [];
        if (t) {
            for (let e = 0; e < r; e += 1) n[e] = {
                affectedInstances: t.affectedInstances,
                isEvent: t.isEvent,
                segs: []
            };
            for (var e of t.segs) n[e.col].segs.push(e)
        } else
            for (let e = 0; e < r; e += 1) n[e] = null;
        return n
    }
    class dl extends s {
        render() {
            let e = this.props;
            return b(Ks, {
                elClasses: ["fc-timegrid-more-link"],
                elStyle: {
                    top: e.top,
                    bottom: e.bottom
                },
                allDayDate: null,
                moreCnt: e.hiddenSegs.length,
                allSegs: e.hiddenSegs,
                hiddenSegs: e.hiddenSegs,
                extraDateSpan: e.extraDateSpan,
                dateProfile: e.dateProfile,
                todayRange: e.todayRange,
                popoverContent: () => El(e.hiddenSegs, e),
                defaultGenerator: ul,
                forceTimed: !0
            }, e => b(e, {
                elTag: "div",
                elClasses: ["fc-timegrid-more-link-inner", "fc-sticky"]
            }))
        }
    }

    function ul(e) {
        return e.shortText
    }

    function hl(e, t, r) {
        var n = new Yi,
            t = (null != t && (n.strictOrder = t), null != r && (n.maxStackCnt = r), Xi(n.addSegs(e))),
            a = (l => {
                let r = l.entriesByLevel,
                    s = ml((e, t) => e + ":" + t, (n, i) => {
                        var e = fl((() => {
                                let {
                                    levelCoords: e,
                                    entriesByLevel: s
                                } = l, o = s[n][i], t = e[n] + o.thickness, r = e.length, a = n;
                                for (; a < r && e[a] < t; a += 1);
                                for (; a < r; a += 1) {
                                    let e, t = s[a],
                                        r = $i(t, o.span.start, Qi),
                                        n = r[0] + r[1],
                                        i = n;
                                    for (;
                                        (e = t[i]) && e.span.start < o.span.end;) i += 1;
                                    if (n < i) return {
                                        level: a,
                                        lateralStart: n,
                                        lateralEnd: i
                                    }
                                }
                                return null
                            })(), s),
                            t = r[n][i];
                        return [Object.assign(Object.assign({}, t), {
                            nextLevelNodes: e[0]
                        }), t.thickness + e[1]]
                    });
                return fl(r.length ? {
                    level: 0,
                    lateralStart: 0,
                    lateralEnd: r[0].length
                } : null, s)[0]
            })(n),
            a = (() => {
                let u = ml((e, t, r) => Zi(e), (e, t, r) => {
                    let n, {
                            nextLevelNodes: i,
                            thickness: s
                        } = e,
                        o = s + r,
                        a = s / o,
                        l = [];
                    if (i.length)
                        for (var c of i) {
                            var d;
                            void 0 === n ? (d = u(c, t, o), n = d[0], l.push(d[1])) : (d = u(c, n, 0), l.push(d[1]))
                        } else n = 1;
                    r = (n - t) * a;
                    return [n - r, Object.assign(Object.assign({}, e), {
                        thickness: r,
                        nextLevelNodes: l
                    })]
                });
                return a.map(e => u(e, 0, 0)[1])
            })();
        return {
            segRects: (() => {
                let i = [],
                    s = ml((e, t, r) => Zi(e), (e, t, r) => {
                        var n = Object.assign(Object.assign({}, e), {
                            levelCoord: t,
                            stackDepth: r,
                            stackForward: 0
                        });
                        return i.push(n), n.stackForward = o(e.nextLevelNodes, t + e.thickness, r + 1) + 1
                    });

                function o(e, t, r) {
                    let n = 0;
                    for (var i of e) n = Math.max(s(i, t, r), n);
                    return n
                }
                return o(a, 0, 0), i
            })(),
            hiddenGroups: t
        }
    }

    function fl(e, t) {
        if (!e) return [
            [], 0
        ];
        let {
            level: r,
            lateralStart: n,
            lateralEnd: i
        } = e, s = n, o = [];
        for (; s < i;) o.push(t(r, s)), s += 1;
        return o.sort(gl), [o.map(pl), o[0][1]]
    }

    function gl(e, t) {
        return t[1] - e[1]
    }

    function pl(e) {
        return e[0]
    }

    function ml(r, n) {
        let i = {};
        return (...e) => {
            var t = r(...e);
            return t in i ? i[t] : i[t] = n(...e)
        }
    }

    function vl(t, r, n = null, i = 0) {
        var s = [];
        if (n)
            for (let e = 0; e < t.length; e += 1) {
                var o = t[e],
                    a = n.computeDateTop(o.start, r),
                    o = Math.max(a + (i || 0), n.computeDateTop(o.end, r));
                s.push({
                    start: Math.round(a),
                    end: Math.round(o)
                })
            }
        return s
    }
    let yl = I({
        hour: "numeric",
        minute: "2-digit",
        meridiem: !1
    });
    class bl extends s {
        render() {
            return b(Bs, Object.assign({}, this.props, {
                elClasses: ["fc-timegrid-event", "fc-v-event", this.props.isShort && "fc-timegrid-event-short"],
                defaultTimeFormat: yl
            }))
        }
    }
    class Sl extends s {
        constructor() {
            super(...arguments), this.sortEventSegs = f(Kn)
        }
        render() {
            let {
                props: t,
                context: e
            } = this, r = e.options, n = r.selectMirror, i = t.eventDrag && t.eventDrag.segs || t.eventResize && t.eventResize.segs || n && t.dateSelectionSegs || [], s = t.eventDrag && t.eventDrag.affectedInstances || t.eventResize && t.eventResize.affectedInstances || {}, o = this.sortEventSegs(t.fgEventSegs, r.eventOrder);
            return b(Us, {
                elTag: "td",
                elRef: t.elRef,
                elClasses: ["fc-timegrid-col", ...t.extraClassNames || []],
                elAttrs: Object.assign({
                    role: "gridcell"
                }, t.extraDataAttrs),
                date: t.date,
                dateProfile: t.dateProfile,
                todayRange: t.todayRange,
                extraRenderProps: t.extraRenderProps
            }, e => b("div", {
                className: "fc-timegrid-col-frame"
            }, b("div", {
                className: "fc-timegrid-col-bg"
            }, this.renderFillSegs(t.businessHourSegs, "non-business"), this.renderFillSegs(t.bgEventSegs, "bg-event"), this.renderFillSegs(t.dateSelectionSegs, "highlight")), b("div", {
                className: "fc-timegrid-col-events"
            }, this.renderFgSegs(o, s, !1, !1, !1)), b("div", {
                className: "fc-timegrid-col-events"
            }, this.renderFgSegs(i, {}, Boolean(t.eventDrag), Boolean(t.eventResize), Boolean(n), "mirror")), b("div", {
                className: "fc-timegrid-now-indicator-container"
            }, this.renderNowIndicator(t.nowIndicatorSegs)), Gs(r) && b(e, {
                elTag: "div",
                elClasses: ["fc-timegrid-col-misc"]
            })))
        }
        renderFgSegs(e, t, r, n, i, s) {
            var o = this.props;
            return o.forPrint ? El(e, o) : this.renderPositionedFgSegs(e, t, r, n, i, s)
        }
        renderPositionedFgSegs(e, a, l, c, d, u) {
            let {
                eventMaxStack: t,
                eventShortHeight: h,
                eventOrderStrict: r,
                eventMinHeight: n
            } = this.context.options, {
                date: i,
                slatCoords: s,
                eventSelection: f,
                todayRange: g,
                nowDate: p
            } = this.props, m = l || c || d, o = vl(e, i, s, n), {
                segPlacements: v,
                hiddenGroups: y
            } = ((t, r, e, n) => {
                var i = [],
                    s = [];
                for (let e = 0; e < t.length; e += 1) {
                    var o = r[e];
                    o ? i.push({
                        index: e,
                        thickness: 1,
                        span: o
                    }) : s.push(t[e])
                }
                var a, l, {
                        segRects: e,
                        hiddenGroups: n
                    } = hl(i, e, n),
                    c = [];
                for (a of e) c.push({
                    seg: t[a.index],
                    rect: a
                });
                for (l of s) c.push({
                    seg: l,
                    rect: null
                });
                return {
                    segPlacements: c,
                    hiddenGroups: n
                }
            })(e, o, r, t);
            return b(A, null, this.renderHiddenGroups(y, e), v.map(e => {
                var {
                    seg: e,
                    rect: t
                } = e, r = e.eventRange.instance.instanceId, n = m || Boolean(!a[r] && t), i = Cl(t && t.span), s = !m && t ? this.computeSegHStyle(t) : {
                    left: 0,
                    right: 0
                }, o = Boolean(t) && 0 < t.stackForward, t = Boolean(t) && t.span.end - t.span.start < h;
                return b("div", {
                    className: "fc-timegrid-event-harness" + (o ? " fc-timegrid-event-harness-inset" : ""),
                    key: u || r,
                    style: Object.assign(Object.assign({
                        visibility: n ? "" : "hidden"
                    }, i), s)
                }, b(bl, Object.assign({
                    seg: e,
                    isDragging: l,
                    isResizing: c,
                    isDateSelecting: d,
                    isSelected: r === f,
                    isShort: t
                }, E(e, g, p))))
            }))
        }
        renderHiddenGroups(e, n) {
            let {
                extraDateSpan: i,
                dateProfile: s,
                todayRange: o,
                nowDate: a,
                eventSelection: l,
                eventDrag: c,
                eventResize: d
            } = this.props;
            return b(A, null, e.map(e => {
                var t, r = Cl(e.span),
                    e = (t = n, e.entries.map(e => t[e.index]));
                return b(dl, {
                    key: Qt(to(e)),
                    hiddenSegs: e,
                    top: r.top,
                    bottom: r.bottom,
                    extraDateSpan: i,
                    dateProfile: s,
                    todayRange: o,
                    nowDate: a,
                    eventSelection: l,
                    eventDrag: c,
                    eventResize: d
                })
            }))
        }
        renderFillSegs(r, n) {
            let {
                props: i,
                context: e
            } = this, t = vl(r, i.date, i.slatCoords, e.options.eventMinHeight).map((e, t) => {
                t = r[t];
                return b("div", {
                    key: ti(t.eventRange),
                    className: "fc-timegrid-bg-harness",
                    style: Cl(e)
                }, "bg-event" === n ? b(Vs, Object.assign({
                    seg: t
                }, E(t, i.todayRange, i.nowDate))) : Ys(n))
            });
            return b(A, null, t)
        }
        renderNowIndicator(e) {
            let {
                slatCoords: r,
                date: n
            } = this.props;
            return r ? e.map((e, t) => b(Ls, {
                key: t,
                elClasses: ["fc-timegrid-now-indicator-line"],
                elStyle: {
                    top: r.computeDateTop(e.start, n)
                },
                isAxis: !1,
                date: n
            })) : null
        }
        computeSegHStyle(e) {
            let t, r, {
                    isRtl: n,
                    options: i
                } = this.context,
                s = i.slotEventOverlap,
                o = e.levelCoord,
                a = e.levelCoord + e.thickness;
            s && (a = Math.min(1, o + 2 * (a - o))), r = n ? (t = 1 - a, o) : (t = o, 1 - a);
            var l = {
                zIndex: e.stackDepth + 1,
                left: 100 * t + "%",
                right: 100 * r + "%"
            };
            return s && !e.stackForward && (l[n ? "marginLeft" : "marginRight"] = 20), l
        }
    }

    function El(e, {
        todayRange: r,
        nowDate: n,
        eventSelection: i,
        eventDrag: t,
        eventResize: s
    }) {
        let o = (t ? t.affectedInstances : null) || (s ? s.affectedInstances : null) || {};
        return b(A, null, e.map(e => {
            var t = e.eventRange.instance.instanceId;
            return b("div", {
                key: t,
                style: {
                    visibility: o[t] ? "hidden" : ""
                }
            }, b(bl, Object.assign({
                seg: e,
                isDragging: !1,
                isResizing: !1,
                isDateSelecting: !1,
                isSelected: t === i,
                isShort: !1
            }, E(e, r, n))))
        }))
    }

    function Cl(e) {
        return e ? {
            top: e.start,
            bottom: -e.end
        } : {
            top: "",
            bottom: ""
        }
    }
    class wl extends s {
        constructor() {
            super(...arguments), this.splitFgEventSegs = f(ll), this.splitBgEventSegs = f(ll), this.splitBusinessHourSegs = f(ll), this.splitNowIndicatorSegs = f(ll), this.splitDateSelectionSegs = f(ll), this.splitEventDrag = f(cl), this.splitEventResize = f(cl), this.rootElRef = {
                current: null
            }, this.cellElRefs = new y
        }
        render() {
            let {
                props: r,
                context: e
            } = this, t = e.options.nowIndicator && r.slatCoords && r.slatCoords.safeComputeTop(r.nowDate), n = r.cells.length, i = this.splitFgEventSegs(r.fgEventSegs, n), s = this.splitBgEventSegs(r.bgEventSegs, n), o = this.splitBusinessHourSegs(r.businessHourSegs, n), a = this.splitNowIndicatorSegs(r.nowIndicatorSegs, n), l = this.splitDateSelectionSegs(r.dateSelectionSegs, n), c = this.splitEventDrag(r.eventDrag, n), d = this.splitEventResize(r.eventResize, n);
            return b("div", {
                className: "fc-timegrid-cols",
                ref: this.rootElRef
            }, b("table", {
                role: "presentation",
                style: {
                    minWidth: r.tableMinWidth,
                    width: r.clientWidth
                }
            }, r.tableColGroupNode, b("tbody", {
                role: "presentation"
            }, b("tr", {
                role: "row"
            }, r.axis && b("td", {
                "aria-hidden": !0,
                className: "fc-timegrid-col fc-timegrid-axis"
            }, b("div", {
                className: "fc-timegrid-col-frame"
            }, b("div", {
                className: "fc-timegrid-now-indicator-container"
            }, "number" == typeof t && b(Ls, {
                elClasses: ["fc-timegrid-now-indicator-arrow"],
                elStyle: {
                    top: t
                },
                isAxis: !0,
                date: r.nowDate
            })))), r.cells.map((e, t) => b(Sl, {
                key: e.key,
                elRef: this.cellElRefs.createRef(e.key),
                dateProfile: r.dateProfile,
                date: e.date,
                nowDate: r.nowDate,
                todayRange: r.todayRange,
                extraRenderProps: e.extraRenderProps,
                extraDataAttrs: e.extraDataAttrs,
                extraClassNames: e.extraClassNames,
                extraDateSpan: e.extraDateSpan,
                fgEventSegs: i[t],
                bgEventSegs: s[t],
                businessHourSegs: o[t],
                nowIndicatorSegs: a[t],
                dateSelectionSegs: l[t],
                eventDrag: c[t],
                eventResize: d[t],
                slatCoords: r.slatCoords,
                eventSelection: r.eventSelection,
                forPrint: r.forPrint
            }))))))
        }
        componentDidMount() {
            this.updateCoords()
        }
        componentDidUpdate() {
            this.updateCoords()
        }
        updateCoords() {
            var t, e = this.props;
            e.onColCoords && null !== e.clientWidth && e.onColCoords(new Ui(this.rootElRef.current, (t = this.cellElRefs.currentMap, e.cells.map(e => t[e.key])), !0, !1))
        }
    }
    class Dl extends a {
        constructor() {
            super(...arguments), this.processSlotOptions = f(Rl), this.state = {
                slatCoords: null
            }, this.handleRootEl = e => {
                e ? this.context.registerInteractiveComponent(this, {
                    el: e,
                    isHitComboAllowed: this.props.isHitComboAllowed
                }) : this.context.unregisterInteractiveComponent(this)
            }, this.handleScrollRequest = t => {
                var r = this.props.onScrollTopRequest,
                    n = this.state.slatCoords;
                if (r && n) {
                    if (t.time) {
                        let e = n.computeTimeTop(t.time);
                        (e = Math.ceil(e)) && (e += 1), r(e)
                    }
                    return !0
                }
                return !1
            }, this.handleColCoords = e => {
                this.colCoords = e
            }, this.handleSlatCoords = e => {
                this.setState({
                    slatCoords: e
                }), this.props.onSlatCoords && this.props.onSlatCoords(e)
            }
        }
        render() {
            var {
                props: e,
                state: t
            } = this;
            return b("div", {
                className: "fc-timegrid-body",
                ref: this.handleRootEl,
                style: {
                    width: e.clientWidth,
                    minWidth: e.tableMinWidth
                }
            }, b(al, {
                axis: e.axis,
                dateProfile: e.dateProfile,
                slatMetas: e.slatMetas,
                clientWidth: e.clientWidth,
                minHeight: e.expandRows ? e.clientHeight : "",
                tableMinWidth: e.tableMinWidth,
                tableColGroupNode: e.axis ? e.tableColGroupNode : null,
                onCoords: this.handleSlatCoords
            }), b(wl, {
                cells: e.cells,
                axis: e.axis,
                dateProfile: e.dateProfile,
                businessHourSegs: e.businessHourSegs,
                bgEventSegs: e.bgEventSegs,
                fgEventSegs: e.fgEventSegs,
                dateSelectionSegs: e.dateSelectionSegs,
                eventSelection: e.eventSelection,
                eventDrag: e.eventDrag,
                eventResize: e.eventResize,
                todayRange: e.todayRange,
                nowDate: e.nowDate,
                nowIndicatorSegs: e.nowIndicatorSegs,
                clientWidth: e.clientWidth,
                tableMinWidth: e.tableMinWidth,
                tableColGroupNode: e.tableColGroupNode,
                slatCoords: t.slatCoords,
                onColCoords: this.handleColCoords,
                forPrint: e.forPrint
            }))
        }
        componentDidMount() {
            this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest)
        }
        componentDidUpdate(e) {
            this.scrollResponder.update(e.dateProfile !== this.props.dateProfile)
        }
        componentWillUnmount() {
            this.scrollResponder.detach()
        }
        queryHit(e, t) {
            var r, n, {
                    dateEnv: i,
                    options: s
                } = this.context,
                o = this.colCoords,
                a = this.props.dateProfile,
                l = this.state.slatCoords,
                {
                    snapDuration: s,
                    snapsPerSlot: c
                } = this.processSlotOptions(this.props.slotDuration, s.snapDuration),
                e = o.leftToIndex(e),
                d = l.positions.topToIndex(t);
            return null != e && null != d ? (r = this.props.cells[e], n = l.positions.tops[d], l = l.positions.getHeight(d), d = d * c + Math.floor((t - n) / l * c), t = this.props.cells[e].date, c = xt(a.slotMinTime, Tt(s, d)), d = i.add(t, c), t = i.add(d, s), {
                dateProfile: a,
                dateSpan: Object.assign({
                    range: {
                        start: d,
                        end: t
                    },
                    allDay: !1
                }, r.extraDateSpan),
                dayEl: o.els[e],
                rect: {
                    left: o.lefts[e],
                    right: o.rights[e],
                    top: n,
                    bottom: n + l
                },
                layer: 0
            }) : null
        }
    }

    function Rl(e, t) {
        let r = t || e,
            n = It(e, r);
        return null === n && (r = e, n = 1), {
            snapDuration: r,
            snapsPerSlot: n
        }
    }
    class Al extends fs {
        sliceRange(t, r) {
            var n = [];
            for (let e = 0; e < r.length; e += 1) {
                var i = D(t, r[e]);
                i && n.push({
                    start: i.start,
                    end: i.end,
                    isStart: i.start.valueOf() === t.start.valueOf(),
                    isEnd: i.end.valueOf() === t.end.valueOf(),
                    col: e
                })
            }
            return n
        }
    }
    class xl extends a {
        constructor() {
            super(...arguments), this.buildDayRanges = f(Tl), this.slicer = new Al, this.timeColsRef = {
                current: null
            }
        }
        render() {
            let {
                props: r,
                context: n
            } = this, {
                dateProfile: i,
                dayTableModel: s
            } = r, {
                nowIndicator: o,
                nextDayThreshold: a
            } = n.options, l = this.buildDayRanges(s, i, n.dateEnv);
            return b(m, {
                unit: o ? "minute" : "day"
            }, (e, t) => b(Dl, Object.assign({
                ref: this.timeColsRef
            }, this.slicer.sliceProps(r, i, null, n, l), {
                forPrint: r.forPrint,
                axis: r.axis,
                dateProfile: i,
                slatMetas: r.slatMetas,
                slotDuration: r.slotDuration,
                cells: s.cells[0],
                tableColGroupNode: r.tableColGroupNode,
                tableMinWidth: r.tableMinWidth,
                clientWidth: r.clientWidth,
                clientHeight: r.clientHeight,
                expandRows: r.expandRows,
                nowDate: e,
                nowIndicatorSegs: o && this.slicer.sliceNowDate(e, i, a, n, l),
                todayRange: t,
                onScrollTopRequest: r.onScrollTopRequest,
                onSlatCoords: r.onSlatCoords
            })))
        }
    }

    function Tl(e, t, r) {
        var n, i = [];
        for (n of e.headerDates) i.push({
            start: r.add(n, t.slotMinTime),
            end: r.add(n, t.slotMaxTime)
        });
        return i
    }
    let Ml = [{
        hours: 1
    }, {
        minutes: 30
    }, {
        minutes: 15
    }, {
        seconds: 30
    }, {
        seconds: 15
    }];

    function kl(e, t, r, n, i) {
        let s = new Date(0),
            o = e,
            a = M(0),
            l = r || (e => {
                let t, r, n;
                for (t = Ml.length - 1; 0 <= t; --t)
                    if (null !== (n = It(r = M(Ml[t]), e)) && 1 < n) return r;
                return e
            })(n),
            c = [];
        for (; k(o) < k(t);) {
            var d = i.add(s, o),
                u = null !== It(a, l);
            c.push({
                date: d,
                time: o,
                key: d.toISOString(),
                isoTimeStr: Jt(d),
                isLabeled: u
            }), o = xt(o, n), a = xt(a, n)
        }
        return c
    }

    function _l(e, t) {
        e = new us(e.renderRange, t);
        return new hs(e, !1)
    }
    Fe('.fc-v-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-v-event .fc-event-main{color:var(--fc-event-text-color);height:100%}.fc-v-event .fc-event-main-frame{display:flex;flex-direction:column;height:100%}.fc-v-event .fc-event-time{flex-grow:0;flex-shrink:0;max-height:100%;overflow:hidden}.fc-v-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-height:0}.fc-v-event .fc-event-title{bottom:0;max-height:100%;overflow:hidden;top:0}.fc-v-event:not(.fc-event-start){border-top-left-radius:0;border-top-right-radius:0;border-top-width:0}.fc-v-event:not(.fc-event-end){border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-width:0}.fc-v-event.fc-event-selected:before{left:-10px;right:-10px}.fc-v-event .fc-event-resizer-start{cursor:n-resize}.fc-v-event .fc-event-resizer-end{cursor:s-resize}.fc-v-event:not(.fc-event-selected) .fc-event-resizer{height:var(--fc-event-resizer-thickness);left:0;right:0}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-start{top:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer{left:50%;margin-left:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-start{top:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc .fc-timegrid .fc-daygrid-body{z-index:2}.fc .fc-timegrid-divider{padding:0 0 2px}.fc .fc-timegrid-body{min-height:100%;position:relative;z-index:1}.fc .fc-timegrid-axis-chunk{position:relative}.fc .fc-timegrid-axis-chunk>table,.fc .fc-timegrid-slots{position:relative;z-index:1}.fc .fc-timegrid-slot{border-bottom:0;height:1.5em}.fc .fc-timegrid-slot:empty:before{content:"\\00a0"}.fc .fc-timegrid-slot-minor{border-top-style:dotted}.fc .fc-timegrid-slot-label-cushion{display:inline-block;white-space:nowrap}.fc .fc-timegrid-slot-label{vertical-align:middle}.fc .fc-timegrid-axis-cushion,.fc .fc-timegrid-slot-label-cushion{padding:0 4px}.fc .fc-timegrid-axis-frame-liquid{height:100%}.fc .fc-timegrid-axis-frame{align-items:center;display:flex;justify-content:flex-end;overflow:hidden}.fc .fc-timegrid-axis-cushion{flex-shrink:0;max-width:60px}.fc-direction-ltr .fc-timegrid-slot-label-frame{text-align:right}.fc-direction-rtl .fc-timegrid-slot-label-frame{text-align:left}.fc-liquid-hack .fc-timegrid-axis-frame-liquid{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-timegrid-col-frame{min-height:100%;position:relative}.fc-media-screen.fc-liquid-hack .fc-timegrid-col-frame{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols{bottom:0;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols>table{height:100%}.fc-media-screen .fc-timegrid-col-bg,.fc-media-screen .fc-timegrid-col-events,.fc-media-screen .fc-timegrid-now-indicator-container{left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col-bg{z-index:2}.fc .fc-timegrid-col-bg .fc-non-business{z-index:1}.fc .fc-timegrid-col-bg .fc-bg-event{z-index:2}.fc .fc-timegrid-col-bg .fc-highlight{z-index:3}.fc .fc-timegrid-bg-harness{left:0;position:absolute;right:0}.fc .fc-timegrid-col-events{z-index:3}.fc .fc-timegrid-now-indicator-container{bottom:0;overflow:hidden}.fc-direction-ltr .fc-timegrid-col-events{margin:0 2.5% 0 2px}.fc-direction-rtl .fc-timegrid-col-events{margin:0 2px 0 2.5%}.fc-timegrid-event-harness{position:absolute}.fc-timegrid-event-harness>.fc-timegrid-event{bottom:0;left:0;position:absolute;right:0;top:0}.fc-timegrid-event-harness-inset .fc-timegrid-event,.fc-timegrid-event.fc-event-mirror,.fc-timegrid-more-link{box-shadow:0 0 0 1px var(--fc-page-bg-color)}.fc-timegrid-event,.fc-timegrid-more-link{border-radius:3px;font-size:var(--fc-small-font-size)}.fc-timegrid-event{margin-bottom:1px}.fc-timegrid-event .fc-event-main{padding:1px 1px 0}.fc-timegrid-event .fc-event-time{font-size:var(--fc-small-font-size);margin-bottom:1px;white-space:nowrap}.fc-timegrid-event-short .fc-event-main-frame{flex-direction:row;overflow:hidden}.fc-timegrid-event-short .fc-event-time:after{content:"\\00a0-\\00a0"}.fc-timegrid-event-short .fc-event-title{font-size:var(--fc-small-font-size)}.fc-timegrid-more-link{background:var(--fc-more-link-bg-color);color:var(--fc-more-link-text-color);cursor:pointer;margin-bottom:1px;position:absolute;z-index:9999}.fc-timegrid-more-link-inner{padding:3px 2px;top:0}.fc-direction-ltr .fc-timegrid-more-link{right:0}.fc-direction-rtl .fc-timegrid-more-link{left:0}.fc .fc-timegrid-now-indicator-arrow,.fc .fc-timegrid-now-indicator-line{pointer-events:none}.fc .fc-timegrid-now-indicator-line{border-color:var(--fc-now-indicator-color);border-style:solid;border-width:1px 0 0;left:0;position:absolute;right:0;z-index:4}.fc .fc-timegrid-now-indicator-arrow{border-color:var(--fc-now-indicator-color);border-style:solid;margin-top:-5px;position:absolute;z-index:4}.fc-direction-ltr .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 0 5px 6px;left:0}.fc-direction-rtl .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 6px 5px 0;right:0}');
    var Il = C({
        name: "@fullcalendar/timegrid",
        initialView: "timeGridWeek",
        optionRefiners: {
            allDaySlot: Boolean
        },
        views: {
            timeGrid: {
                component: class extends nl {
                    constructor() {
                        super(...arguments), this.buildTimeColsModel = f(_l), this.buildSlatMetas = f(kl)
                    }
                    render() {
                        let {
                            options: t,
                            dateEnv: e,
                            dateProfileGenerator: r
                        } = this.context, n = this.props, i = n.dateProfile, s = this.buildTimeColsModel(i, r), o = this.allDaySplitter.splitProps(n), a = this.buildSlatMetas(i.slotMinTime, i.slotMaxTime, t.slotLabelInterval, t.slotDuration, e), l = t.dayMinWidth, c = !l, d = l, u = t.dayHeaders && b(cs, {
                            dates: s.headerDates,
                            dateProfile: i,
                            datesRepDistinctDays: !0,
                            renderIntro: c ? this.renderHeadAxis : null
                        }), h = !1 !== t.allDaySlot && (e => b(Ya, Object.assign({}, o.allDay, {
                            dateProfile: i,
                            dayTableModel: s,
                            nextDayThreshold: t.nextDayThreshold,
                            tableMinWidth: e.tableMinWidth,
                            colGroupNode: e.tableColGroupNode,
                            renderRowIntro: c ? this.renderTableRowAxis : null,
                            showWeekNumbers: !1,
                            expandRows: !1,
                            headerAlignElRef: this.headerElRef,
                            clientWidth: e.clientWidth,
                            clientHeight: e.clientHeight,
                            forPrint: n.forPrint
                        }, this.getAllDayMaxEventProps()))), f = e => b(xl, Object.assign({}, o.timed, {
                            dayTableModel: s,
                            dateProfile: i,
                            axis: c,
                            slotDuration: t.slotDuration,
                            slatMetas: a,
                            forPrint: n.forPrint,
                            tableColGroupNode: e.tableColGroupNode,
                            tableMinWidth: e.tableMinWidth,
                            clientWidth: e.clientWidth,
                            clientHeight: e.clientHeight,
                            onSlatCoords: this.handleSlatCoords,
                            expandRows: e.expandRows,
                            onScrollTopRequest: this.handleScrollTopRequest
                        }));
                        return d ? this.renderHScrollLayout(u, h, f, s.colCnt, l, a, this.state.slatCoords) : this.renderSimpleLayout(u, h, f)
                    }
                },
                usesMinMaxTime: !0,
                allDaySlot: !0,
                slotDuration: "00:30:00",
                slotEventOverlap: !0
            },
            timeGridDay: {
                type: "timeGrid",
                duration: {
                    days: 1
                }
            },
            timeGridWeek: {
                type: "timeGrid",
                duration: {
                    weeks: 1
                }
            }
        }
    });
    class Ol extends s {
        constructor() {
            super(...arguments), this.state = {
                textId: t()
            }
        }
        render() {
            let {
                theme: t,
                dateEnv: e,
                options: r,
                viewApi: n
            } = this.context, {
                cellId: i,
                dayDate: s,
                todayRange: o
            } = this.props, a = this.state.textId, l = xi(s, o), c = r.listDayFormat ? e.format(s, r.listDayFormat) : "", d = r.listDaySideFormat ? e.format(s, r.listDaySideFormat) : "", u = Object.assign({
                date: e.toDate(s),
                view: n,
                textId: a,
                text: c,
                sideText: d,
                navLinkAttrs: Ii(this.context, s),
                sideNavLinkAttrs: Ii(this.context, s, "day", !1)
            }, l);
            return b(g, {
                elTag: "tr",
                elClasses: ["fc-list-day", ...Ti(l, t)],
                elAttrs: {
                    "data-date": Zt(s)
                },
                renderProps: u,
                generatorName: "dayHeaderContent",
                customGenerator: r.dayHeaderContent,
                defaultGenerator: Pl,
                classNameGenerator: r.dayHeaderClassNames,
                didMount: r.dayHeaderDidMount,
                willUnmount: r.dayHeaderWillUnmount
            }, e => b("th", {
                scope: "colgroup",
                colSpan: 3,
                id: i,
                "aria-labelledby": a
            }, b(e, {
                elTag: "div",
                elClasses: ["fc-list-day-cushion", t.getClass("tableCellShaded")]
            })))
        }
    }

    function Pl(e) {
        return b(A, null, e.text && b("a", Object.assign({
            id: e.textId,
            className: "fc-list-day-text"
        }, e.navLinkAttrs), e.text), e.sideText && b("a", Object.assign({
            "aria-hidden": !0,
            className: "fc-list-day-side-text"
        }, e.sideNavLinkAttrs), e.sideText))
    }
    let Nl = I({
        hour: "numeric",
        minute: "2-digit",
        meridiem: "short"
    });
    class Hl extends s {
        render() {
            let {
                props: e,
                context: r
            } = this, t = r.options, {
                seg: n,
                timeHeaderId: i,
                eventHeaderId: s,
                dateHeaderId: o
            } = e, a = t.eventTimeFormat || Nl;
            return b(Ws, Object.assign({}, e, {
                elTag: "tr",
                elClasses: ["fc-list-event", n.eventRange.def.url && "fc-event-forced-url"],
                defaultGenerator: () => {
                    return e = n, t = ri(e, r), b("a", Object.assign({}, t), e.eventRange.def.title);
                    var e, t
                },
                seg: n,
                timeText: "",
                disableDragging: !0,
                disableResizing: !0
            }), (e, t) => b(A, null, ((i, s, o, a, l) => {
                var c = o.options;
                if (!1 === c.displayEventTime) return null;
                {
                    let e, t = i.eventRange.def,
                        r = i.eventRange.instance,
                        n = !1;
                    return (t.allDay ? n = !0 : sn(i.eventRange.range) ? i.isStart ? e = ei(i, s, o, null, null, r.range.start, i.end) : i.isEnd ? e = ei(i, s, o, null, null, i.start, r.range.end) : n = !0 : e = ei(i, s, o), n) ? (i = {
                        text: o.options.allDayText,
                        view: o.viewApi
                    }, b(g, {
                        elTag: "td",
                        elClasses: ["fc-list-event-time"],
                        elAttrs: {
                            headers: a + " " + l
                        },
                        renderProps: i,
                        generatorName: "allDayContent",
                        customGenerator: c.allDayContent,
                        defaultGenerator: Wl,
                        classNameGenerator: c.allDayClassNames,
                        didMount: c.allDayDidMount,
                        willUnmount: c.allDayWillUnmount
                    })) : b("td", {
                        className: "fc-list-event-time"
                    }, e)
                }
            })(n, a, r, i, o), b("td", {
                "aria-hidden": !0,
                className: "fc-list-event-graphic"
            }, b("span", {
                className: "fc-list-event-dot",
                style: {
                    borderColor: t.borderColor || t.backgroundColor
                }
            })), b(e, {
                elTag: "td",
                elClasses: ["fc-list-event-title"],
                elAttrs: {
                    headers: s + " " + o
                }
            })))
        }
    }

    function Wl(e) {
        return e.text
    }

    function Bl(e) {
        return e.text
    }

    function jl(e) {
        let t = v(e.renderRange.start),
            r = e.renderRange.end,
            n = [],
            i = [];
        for (; t < r;) n.push(t), i.push({
            start: t,
            end: _(t, 1)
        }), t = _(t, 1);
        return {
            dayDates: n,
            dayRanges: i
        }
    }

    function Ll(e) {
        return !1 === e ? null : I(e)
    }
    Fe(':root{--fc-list-event-dot-width:10px;--fc-list-event-hover-bg-color:#f5f5f5}.fc-theme-standard .fc-list{border:1px solid var(--fc-border-color)}.fc .fc-list-empty{align-items:center;background-color:var(--fc-neutral-bg-color);display:flex;height:100%;justify-content:center}.fc .fc-list-empty-cushion{margin:5em 0}.fc .fc-list-table{border-style:hidden;width:100%}.fc .fc-list-table tr>*{border-left:0;border-right:0}.fc .fc-list-sticky .fc-list-day>*{background:var(--fc-page-bg-color);position:sticky;top:0}.fc .fc-list-table thead{left:-10000px;position:absolute}.fc .fc-list-table tbody>tr:first-child th{border-top:0}.fc .fc-list-table th{padding:0}.fc .fc-list-day-cushion,.fc .fc-list-table td{padding:8px 14px}.fc .fc-list-day-cushion:after{clear:both;content:"";display:table}.fc-theme-standard .fc-list-day-cushion{background-color:var(--fc-neutral-bg-color)}.fc-direction-ltr .fc-list-day-text,.fc-direction-rtl .fc-list-day-side-text{float:left}.fc-direction-ltr .fc-list-day-side-text,.fc-direction-rtl .fc-list-day-text{float:right}.fc-direction-ltr .fc-list-table .fc-list-event-graphic{padding-right:0}.fc-direction-rtl .fc-list-table .fc-list-event-graphic{padding-left:0}.fc .fc-list-event.fc-event-forced-url{cursor:pointer}.fc .fc-list-event:hover td{background-color:var(--fc-list-event-hover-bg-color)}.fc .fc-list-event-graphic,.fc .fc-list-event-time{white-space:nowrap;width:1px}.fc .fc-list-event-dot{border:calc(var(--fc-list-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-list-event-dot-width)/2);box-sizing:content-box;display:inline-block;height:0;width:0}.fc .fc-list-event-title a{color:inherit;text-decoration:none}.fc .fc-list-event.fc-event-forced-url:hover a{text-decoration:underline}');
    var zl = C({
        name: "@fullcalendar/list",
        optionRefiners: {
            listDayFormat: Ll,
            listDaySideFormat: Ll,
            noEventsClassNames: r,
            noEventsContent: r,
            noEventsDidMount: r,
            noEventsWillUnmount: r
        },
        views: {
            list: {
                component: class extends a {
                    constructor() {
                        super(...arguments), this.computeDateVars = f(jl), this.eventStoreToSegs = f(this._eventStoreToSegs), this.state = {
                            timeHeaderId: t(),
                            eventHeaderId: t(),
                            dateHeaderIdRoot: t()
                        }, this.setRootEl = e => {
                            e ? this.context.registerInteractiveComponent(this, {
                                el: e
                            }) : this.context.unregisterInteractiveComponent(this)
                        }
                    }
                    render() {
                        var {
                            props: e,
                            context: t
                        } = this, {
                            dayDates: r,
                            dayRanges: n
                        } = this.computeDateVars(e.dateProfile), n = this.eventStoreToSegs(e.eventStore, e.eventUiBases, n);
                        return b(Zr, {
                            elRef: this.setRootEl,
                            elClasses: ["fc-list", t.theme.getClass("table"), !1 !== t.options.stickyHeaderDates ? "fc-list-sticky" : ""],
                            viewSpec: t.viewSpec
                        }, b(Cs, {
                            liquid: !e.isHeightAuto,
                            overflowX: e.isHeightAuto ? "visible" : "hidden",
                            overflowY: e.isHeightAuto ? "visible" : "auto"
                        }, 0 < n.length ? this.renderSegList(n, r) : this.renderEmptyMessage()))
                    }
                    renderEmptyMessage() {
                        var {
                            options: e,
                            viewApi: t
                        } = this.context, t = {
                            text: e.noEventsText,
                            view: t
                        };
                        return b(g, {
                            elTag: "div",
                            elClasses: ["fc-list-empty"],
                            renderProps: t,
                            generatorName: "noEventsContent",
                            customGenerator: e.noEventsContent,
                            defaultGenerator: Bl,
                            classNameGenerator: e.noEventsClassNames,
                            didMount: e.noEventsDidMount,
                            willUnmount: e.noEventsWillUnmount
                        }, e => b(e, {
                            elTag: "div",
                            elClasses: ["fc-list-empty-cushion"]
                        }))
                    }
                    renderSegList(e, l) {
                        let {
                            theme: c,
                            options: d
                        } = this.context, {
                            timeHeaderId: u,
                            eventHeaderId: h,
                            dateHeaderIdRoot: f
                        } = this.state, g = (e => {
                            let t, r, n = [];
                            for (t = 0; t < e.length; t += 1) r = e[t], (n[r.dayIndex] || (n[r.dayIndex] = [])).push(r);
                            return n
                        })(e);
                        return b(m, {
                            unit: "day"
                        }, (t, r) => {
                            var n = [];
                            for (let e = 0; e < g.length; e += 1) {
                                var i = g[e];
                                if (i) {
                                    var s, o = Zt(l[e]),
                                        a = f + "-" + o;
                                    n.push(b(Ol, {
                                        key: o,
                                        cellId: a,
                                        dayDate: l[e],
                                        todayRange: r
                                    }));
                                    for (s of Kn(i, d.eventOrder)) n.push(b(Hl, Object.assign({
                                        key: o + ":" + s.eventRange.instance.instanceId,
                                        seg: s,
                                        isDragging: !1,
                                        isResizing: !1,
                                        isDateSelecting: !1,
                                        isSelected: !1,
                                        timeHeaderId: u,
                                        eventHeaderId: h,
                                        dateHeaderId: a
                                    }, E(s, r, t))))
                                }
                            }
                            return b("table", {
                                className: "fc-list-table " + c.getClass("table")
                            }, b("thead", null, b("tr", null, b("th", {
                                scope: "col",
                                id: u
                            }, d.timeHint), b("th", {
                                scope: "col",
                                "aria-hidden": !0
                            }), b("th", {
                                scope: "col",
                                id: h
                            }, d.eventHint))), b("tbody", null, n))
                        })
                    }
                    _eventStoreToSegs(e, t, r) {
                        return this.eventRangesToSegs(qn(e, t, this.props.dateProfile.activeRange, this.context.options.nextDayThreshold).fg, r)
                    }
                    eventRangesToSegs(e, t) {
                        var r, n = [];
                        for (r of e) n.push(...this.eventRangeToSegs(r, t));
                        return n
                    }
                    eventRangeToSegs(e, t) {
                        let r, n, i, s = this.context.dateEnv,
                            o = this.context.options.nextDayThreshold,
                            a = e.range,
                            l = e.def.allDay,
                            c = [];
                        for (r = 0; r < t.length; r += 1)
                            if ((n = D(a, t[r])) && (i = {
                                    component: this,
                                    eventRange: e,
                                    start: n.start,
                                    end: n.end,
                                    isStart: e.isStart && n.start.valueOf() === a.start.valueOf(),
                                    isEnd: e.isEnd && n.end.valueOf() === a.end.valueOf(),
                                    dayIndex: r
                                }, c.push(i), !i.isEnd) && !l && r + 1 < t.length && a.end < s.add(t[r + 1].start, o)) {
                                i.end = a.end, i.isEnd = !0;
                                break
                            } return c
                    }
                },
                buttonTextKey: "list",
                listDayFormat: {
                    month: "long",
                    day: "numeric",
                    year: "numeric"
                }
            },
            listDay: {
                type: "list",
                duration: {
                    days: 1
                },
                listDayFormat: {
                    weekday: "long"
                }
            },
            listWeek: {
                type: "list",
                duration: {
                    weeks: 1
                },
                listDayFormat: {
                    weekday: "long"
                },
                listDaySideFormat: {
                    month: "long",
                    day: "numeric",
                    year: "numeric"
                }
            },
            listMonth: {
                type: "list",
                duration: {
                    month: 1
                },
                listDaySideFormat: {
                    weekday: "long"
                }
            },
            listYear: {
                type: "list",
                duration: {
                    year: 1
                },
                listDaySideFormat: {
                    weekday: "long"
                }
            }
        }
    });
    class Ul extends a {
        constructor() {
            super(...arguments), this.buildDayTableModel = f(Qa), this.slicer = new qa, this.state = {
                labelId: t()
            }
        }
        render() {
            var {
                props: e,
                state: t,
                context: r
            } = this, {
                dateProfile: n,
                forPrint: i
            } = e, s = r.options, o = this.buildDayTableModel(n, r.dateProfileGenerator), a = this.slicer.sliceProps(e, n, s.nextDayThreshold, r, o), l = null != e.tableWidth ? e.tableWidth / s.aspectRatio : null, c = o.cells.length, c = null != l ? l / c : null;
            return b("div", {
                ref: e.elRef,
                "data-date": e.isoDateStr,
                className: "fc-multimonth-month",
                style: {
                    width: e.width
                },
                role: "grid",
                "aria-labelledby": t.labelId
            }, b("div", {
                className: "fc-multimonth-header",
                style: {
                    marginBottom: c
                },
                role: "presentation"
            }, b("div", {
                className: "fc-multimonth-title",
                id: t.labelId
            }, r.dateEnv.format(e.dateProfile.currentRange.start, e.titleFormat)), b("table", {
                className: ["fc-multimonth-header-table", r.theme.getClass("table")].join(" "),
                role: "presentation"
            }, b("thead", {
                role: "rowgroup"
            }, b(cs, {
                dateProfile: e.dateProfile,
                dates: o.headerDates,
                datesRepDistinctDays: !1
            })))), b("div", {
                className: ["fc-multimonth-daygrid", "fc-daygrid", "fc-daygrid-body", !i && "fc-daygrid-body-balanced", i && "fc-daygrid-body-unbalanced", i && "fc-daygrid-body-natural"].join(" "),
                style: {
                    marginTop: -c
                }
            }, b("table", {
                className: ["fc-multimonth-daygrid-table", r.theme.getClass("table")].join(" "),
                style: {
                    height: i ? "" : l
                },
                role: "presentation"
            }, b("tbody", {
                role: "rowgroup"
            }, b(Ua, Object.assign({}, a, {
                dateProfile: n,
                cells: o.cells,
                eventSelection: e.eventSelection,
                dayMaxEvents: !i,
                dayMaxEventRows: !i,
                showWeekNumbers: s.weekNumbers,
                clientWidth: e.clientWidth,
                clientHeight: e.clientHeight,
                forPrint: i
            }))))))
        }
    }
    let Gl = M(1, "month");

    function Fl(r, n, i, s, o) {
        let {
            start: e,
            end: t
        } = n.currentRange, a = e;
        for (var l = []; a.valueOf() < t.valueOf();) {
            let e = i.add(a, Gl),
                t = {
                    start: r.skipHiddenDays(a),
                    end: r.skipHiddenDays(e, -1, !0)
                };
            var c = Xa({
                    currentRange: t,
                    snapToWeek: !0,
                    fixedWeekCount: s,
                    dateEnv: i
                }),
                c = {
                    start: r.skipHiddenDays(c.start),
                    end: r.skipHiddenDays(c.end, -1, !0)
                },
                d = n.activeRange ? D(n.activeRange, o ? c : t) : null;
            l.push({
                currentDate: n.currentDate,
                isValid: n.isValid,
                validRange: n.validRange,
                renderRange: c,
                activeRange: d,
                currentRange: t,
                currentRangeUnit: "month",
                isRangeAllDay: !0,
                dateIncrement: n.dateIncrement,
                slotMinTime: n.slotMaxTime,
                slotMaxTime: n.slotMinTime
            }), a = e
        }
        return l
    }
    let Vl = I({
            year: "numeric",
            month: "long"
        }),
        ql = I({
            month: "long"
        });

    function Yl(e, t) {
        return e || (t[0].currentRange.start.getUTCFullYear() !== t[t.length - 1].currentRange.start.getUTCFullYear() ? Vl : ql)
    }
    var Ql = {
            multiMonthTitleFormat: I,
            multiMonthMaxColumns: Number,
            multiMonthMinWidth: Number
        },
        Ql = (Fe(".fc .fc-multimonth{border:1px solid var(--fc-border-color);display:flex;flex-wrap:wrap;overflow-x:hidden;overflow-y:auto}.fc .fc-multimonth-title{font-size:1.2em;font-weight:700;padding:1em 0;text-align:center}.fc .fc-multimonth-daygrid{background:var(--fc-page-bg-color)}.fc .fc-multimonth-daygrid-table,.fc .fc-multimonth-header-table{table-layout:fixed;width:100%}.fc .fc-multimonth-daygrid-table{border-top-style:hidden!important}.fc .fc-multimonth-singlecol .fc-multimonth{position:relative}.fc .fc-multimonth-singlecol .fc-multimonth-header{background:var(--fc-page-bg-color);position:relative;top:0;z-index:2}.fc .fc-multimonth-singlecol .fc-multimonth-daygrid{position:relative;z-index:1}.fc .fc-multimonth-singlecol .fc-multimonth-daygrid-table,.fc .fc-multimonth-singlecol .fc-multimonth-header-table{border-left-style:hidden;border-right-style:hidden}.fc .fc-multimonth-singlecol .fc-multimonth-month:last-child .fc-multimonth-daygrid-table{border-bottom-style:hidden}.fc .fc-multimonth-multicol{line-height:1}.fc .fc-multimonth-multicol .fc-multimonth-month{padding:0 1.2em 1.2em}.fc .fc-multimonth-multicol .fc-daygrid-more-link{border:1px solid var(--fc-event-border-color);display:block;float:none;padding:1px}.fc .fc-multimonth-compact{line-height:1}.fc .fc-multimonth-compact .fc-multimonth-daygrid-table,.fc .fc-multimonth-compact .fc-multimonth-header-table{font-size:.9em}.fc-media-screen .fc-multimonth-singlecol .fc-multimonth-header{position:sticky}.fc-media-print .fc-multimonth{overflow:visible}"), C({
            name: "@fullcalendar/multimonth",
            initialView: "multiMonthYear",
            optionRefiners: Ql,
            views: {
                multiMonth: {
                    component: class extends a {
                        constructor() {
                            super(...arguments), this.splitDateProfileByMonth = f(Fl), this.buildMonthFormat = f(Yl), this.scrollElRef = {
                                current: null
                            }, this.firstMonthElRef = {
                                current: null
                            }, this.needsScrollReset = !1, this.handleSizing = e => {
                                e && this.updateSize()
                            }
                        }
                        render() {
                            let {
                                context: e,
                                props: n,
                                state: t
                            } = this, r = e.options, {
                                clientWidth: i,
                                clientHeight: s
                            } = t, o = t.monthHPadding || 0, a = Math.min(null != i ? Math.floor(i / (r.multiMonthMinWidth + o)) : 1, r.multiMonthMaxColumns) || 1, l = 100 / a + "%", c = null == i ? null : i / a - o, d = null != i && 1 === a, u = this.splitDateProfileByMonth(e.dateProfileGenerator, n.dateProfile, e.dateEnv, !d && r.fixedWeekCount, r.showNonCurrentDates), h = this.buildMonthFormat(r.multiMonthTitleFormat, u), f = ["fc-multimonth", d ? "fc-multimonth-singlecol" : "fc-multimonth-multicol", null != c && c < 400 ? "fc-multimonth-compact" : "", n.isHeightAuto ? "" : "fc-scroller"];
                            return b(Zr, {
                                elRef: this.scrollElRef,
                                elClasses: f,
                                viewSpec: e.viewSpec
                            }, u.map((e, t) => {
                                var r = Xt(e.currentRange.start);
                                return b(Ul, Object.assign({}, n, {
                                    key: r,
                                    isoDateStr: r,
                                    elRef: 0 === t ? this.firstMonthElRef : void 0,
                                    titleFormat: h,
                                    dateProfile: e,
                                    width: l,
                                    tableWidth: c,
                                    clientWidth: i,
                                    clientHeight: s
                                }))
                            }))
                        }
                        componentDidMount() {
                            this.updateSize(), this.context.addResizeHandler(this.handleSizing), this.requestScrollReset()
                        }
                        componentDidUpdate(e) {
                            h(e, this.props) || this.handleSizing(!1), e.dateProfile !== this.props.dateProfile ? this.requestScrollReset() : this.flushScrollReset()
                        }
                        componentWillUnmount() {
                            this.context.removeResizeHandler(this.handleSizing)
                        }
                        updateSize() {
                            var e = this.scrollElRef.current,
                                t = this.firstMonthElRef.current;
                            e && this.setState({
                                clientWidth: e.clientWidth,
                                clientHeight: e.clientHeight
                            }), t && e && null == this.state.monthHPadding && this.setState({
                                monthHPadding: e.clientWidth - t.firstChild.offsetWidth
                            })
                        }
                        requestScrollReset() {
                            this.needsScrollReset = !0, this.flushScrollReset()
                        }
                        flushScrollReset() {
                            var e, t;
                            this.needsScrollReset && null != this.state.monthHPadding && (t = this.props.dateProfile.currentDate, t = (e = this.scrollElRef.current).querySelector(`[data-date="${Xt(t)}"]`), e.scrollTop = t.getBoundingClientRect().top - this.firstMonthElRef.current.getBoundingClientRect().top, this.needsScrollReset = !1)
                        }
                        shouldComponentUpdate() {
                            return !0
                        }
                    },
                    dateProfileGeneratorClass: Za,
                    multiMonthMinWidth: 350,
                    multiMonthMaxColumns: 3
                },
                multiMonthYear: {
                    type: "multiMonth",
                    duration: {
                        years: 1
                    },
                    fixedWeekCount: !0,
                    showNonCurrentDates: !1
                }
            }
        })),
        Zl = C({
            name: "@fullcalendar/premium-common",
            premiumReleaseDate: "2025-06-30",
            optionRefiners: {
                schedulerLicenseKey: String
            }
        });
    let Xl;

    function Jl() {
        return Xl = Xl || (() => {
            var e = document.createElement("div");
            e.style.position = "absolute", e.style.top = "-1000px", e.style.width = "100px", e.style.height = "100px", e.style.overflow = "scroll", e.style.direction = "rtl";
            let t, r = document.createElement("div");
            return r.style.width = "200px", r.style.height = "200px", e.appendChild(r), document.body.appendChild(e), t = 0 < e.scrollLeft ? "positive" : (e.scrollLeft = 1, 0 < e.scrollLeft ? "reverse" : "negative"), Ze(e), t
        })()
    }
    class Kl {
        constructor(e, t) {
            this.scrollEl = e, this.isRtl = t, this.updateSize = () => {
                var e, i, s, t = this.scrollEl,
                    r = Je(t, ".fc-sticky");
                e = r, i = this.queryElGeoms(r), s = t.clientWidth, e.forEach((e, t) => {
                    var {
                        textAlign: t,
                        elWidth: r,
                        parentBound: n
                    } = i[t], n = n.right - n.left, t = "center" === t && s < n ? (s - r) / 2 : "";
                    et(e, {
                        left: t,
                        right: t,
                        top: 0
                    })
                })
            }
        }
        queryElGeoms(e) {
            var t, r, s, {
                    scrollEl: n,
                    isRtl: o
                } = this,
                a = (t = (n = n).getBoundingClientRect(), r = Bi(n), {
                    left: t.left + r.borderLeft + r.scrollbarLeft - (e => {
                        let t = e.scrollLeft;
                        if ("rtl" === window.getComputedStyle(e).direction) switch (Jl()) {
                            case "negative":
                                t *= -1;
                            case "reverse":
                                t = e.scrollWidth - t - e.clientWidth
                        }
                        return t
                    })(n),
                    top: t.top + r.borderTop - n.scrollTop
                }),
                l = [];
            for (s of e) {
                let e = Si(ji(s.parentNode, !0, !0), -a.left, -a.top),
                    t = s.getBoundingClientRect(),
                    r = window.getComputedStyle(s),
                    n = window.getComputedStyle(s.parentNode).textAlign,
                    i = null;
                "start" === n ? n = o ? "right" : "left" : "end" === n && (n = o ? "left" : "right"), "sticky" !== r.position && (i = Si(t, -a.left - (parseFloat(r.left) || 0), -a.top - (parseFloat(r.top) || 0))), l.push({
                    parentBound: e,
                    naturalBound: i,
                    elWidth: t.width,
                    elHeight: t.height,
                    textAlign: n
                })
            }
            return l
        }
    }
    class $l extends s {
        constructor() {
            super(...arguments), this.elRef = {
                current: null
            }, this.state = {
                xScrollbarWidth: 0,
                yScrollbarWidth: 0
            }, this.handleScroller = e => {
                this.scroller = e, o(this.props.scrollerRef, e)
            }, this.handleSizing = () => {
                var e = this.props;
                "scroll-hidden" === e.overflowY && this.setState({
                    yScrollbarWidth: this.scroller.getYScrollbarWidth()
                }), "scroll-hidden" === e.overflowX && this.setState({
                    xScrollbarWidth: this.scroller.getXScrollbarWidth()
                })
            }
        }
        render() {
            let {
                props: e,
                state: t,
                context: r
            } = this, n = r.isRtl && Ni(), i = 0, s = 0, o = 0, {
                overflowX: a,
                overflowY: l
            } = e;
            return e.forPrint && (a = "visible", l = "visible"), "scroll-hidden" === a && (o = t.xScrollbarWidth), "scroll-hidden" === l && null != t.yScrollbarWidth && (n ? i = t.yScrollbarWidth : s = t.yScrollbarWidth), b("div", {
                ref: this.elRef,
                className: "fc-scroller-harness" + (e.liquid ? " fc-scroller-harness-liquid" : "")
            }, b(Cs, {
                ref: this.handleScroller,
                elRef: this.props.scrollerElRef,
                overflowX: "scroll-hidden" === a ? "scroll" : a,
                overflowY: "scroll-hidden" === l ? "scroll" : l,
                overcomeLeft: i,
                overcomeRight: s,
                overcomeBottom: o,
                maxHeight: "number" == typeof e.maxHeight ? e.maxHeight + ("scroll-hidden" === a ? t.xScrollbarWidth : 0) : "",
                liquid: e.liquid,
                liquidIsAbsolute: !0
            }, e.children))
        }
        componentDidMount() {
            this.handleSizing(), this.context.addResizeHandler(this.handleSizing)
        }
        getSnapshotBeforeUpdate(e) {
            return this.props.forPrint && !e.forPrint ? {
                simulateScrollLeft: this.scroller.el.scrollLeft
            } : {}
        }
        componentDidUpdate(e, t, r) {
            var {
                props: n,
                scroller: {
                    el: i
                }
            } = this;
            if (h(e, n) || this.handleSizing(), void 0 !== r.simulateScrollLeft) i.style.left = -r.simulateScrollLeft + "px";
            else if (!n.forPrint && e.forPrint) {
                let e = -parseInt(i.style.left);
                i.style.left = "", i.scrollLeft = e
            }
        }
        componentWillUnmount() {
            this.context.removeResizeHandler(this.handleSizing)
        }
        needsXScrolling() {
            return this.scroller.needsXScrolling()
        }
        needsYScrolling() {
            return this.scroller.needsYScrolling()
        }
    }
    let ec = "wheel mousewheel DomMouseScroll MozMousePixelScroll".split(" ");
    class tc {
        constructor(e) {
            this.el = e, this.emitter = new Hn, this.isScrolling = !1, this.isTouching = !1, this.isRecentlyWheeled = !1, this.isRecentlyScrolled = !1, this.wheelWaiter = new Qe(this._handleWheelWaited.bind(this)), this.scrollWaiter = new Qe(this._handleScrollWaited.bind(this)), this.handleScroll = () => {
                this.startScroll(), this.emitter.trigger("scroll", this.isRecentlyWheeled, this.isTouching), this.isRecentlyScrolled = !0, this.scrollWaiter.request(500)
            }, this.handleWheel = () => {
                this.isRecentlyWheeled = !0, this.wheelWaiter.request(500)
            }, this.handleTouchStart = () => {
                this.isTouching = !0
            }, this.handleTouchEnd = () => {
                this.isTouching = !1, this.isRecentlyScrolled || this.endScroll()
            }, e.addEventListener("scroll", this.handleScroll), e.addEventListener("touchstart", this.handleTouchStart, {
                passive: !0
            }), e.addEventListener("touchend", this.handleTouchEnd);
            for (var t of ec) e.addEventListener(t, this.handleWheel)
        }
        destroy() {
            var e, t = this.el;
            t.removeEventListener("scroll", this.handleScroll), t.removeEventListener("touchstart", this.handleTouchStart, {
                passive: !0
            }), t.removeEventListener("touchend", this.handleTouchEnd);
            for (e of ec) t.removeEventListener(e, this.handleWheel)
        }
        startScroll() {
            this.isScrolling || (this.isScrolling = !0, this.emitter.trigger("scrollStart", this.isRecentlyWheeled, this.isTouching))
        }
        endScroll() {
            this.isScrolling && (this.emitter.trigger("scrollEnd"), this.isScrolling = !1, this.isRecentlyScrolled = !0, this.isRecentlyWheeled = !1, this.scrollWaiter.clear(), this.wheelWaiter.clear())
        }
        _handleScrollWaited() {
            this.isRecentlyScrolled = !1, this.isTouching || this.endScroll()
        }
        _handleWheelWaited() {
            this.isRecentlyWheeled = !1
        }
    }
    class rc {
        constructor(e, t) {
            this.isVertical = e, this.scrollEls = t, this.isPaused = !1, this.scrollListeners = t.map(e => this.bindScroller(e))
        }
        destroy() {
            for (var e of this.scrollListeners) e.destroy()
        }
        bindScroller(n) {
            let {
                scrollEls: i,
                isVertical: s
            } = this, e = new tc(n);
            return e.emitter.on("scroll", (e, t) => {
                if (!this.isPaused && (this.masterEl && (this.masterEl === n || !e && !t) || this.assignMaster(n), this.masterEl === n))
                    for (var r of i) r !== n && (s ? r.scrollTop = n.scrollTop : r.scrollLeft = n.scrollLeft)
            }), e.emitter.on("scrollEnd", () => {
                this.masterEl === n && (this.masterEl = null)
            }), e
        }
        assignMaster(e) {
            this.masterEl = e;
            for (var t of this.scrollListeners) t.el !== e && t.endScroll()
        }
        forceScrollLeft(e) {
            this.isPaused = !0;
            for (var t of this.scrollListeners) {
                r = void 0;
                n = void 0;
                var r = t.el;
                var n = e;
                if ("rtl" === window.getComputedStyle(r).direction) switch (Jl()) {
                    case "reverse":
                        n = r.scrollWidth - n;
                        break;
                    case "negative":
                        n = -(r.scrollWidth - n)
                }
                r.scrollLeft = n
            }
            this.isPaused = !1
        }
        forceScrollTop(e) {
            this.isPaused = !0;
            for (var t of this.scrollListeners) t.el.scrollTop = e;
            this.isPaused = !1
        }
    }
    N.SCROLLGRID_RESIZE_INTERVAL = 500;
    class nc extends s {
        constructor() {
            super(...arguments), this.compileColGroupStats = er(oc, cc), this.renderMicroColGroups = er(Ts), this.clippedScrollerRefs = new y, this.scrollerElRefs = new y(this._handleScrollerEl.bind(this)), this.chunkElRefs = new y(this._handleChunkEl.bind(this)), this.scrollSyncersBySection = {}, this.scrollSyncersByColumn = {}, this.rowUnstableMap = new Map, this.rowInnerMaxHeightMap = new Map, this.anyRowHeightsChanged = !1, this.recentSizingCnt = 0, this.state = {
                shrinkWidths: [],
                forceYScrollbars: !1,
                forceXScrollbars: !1,
                scrollerClientWidths: {},
                scrollerClientHeights: {},
                sectionRowMaxHeights: []
            }, this.handleSizing = (e, t) => {
                var r;
                this.allowSizing() && (t || (this.anyRowHeightsChanged = !0), r = {}, !e && (t || this.rowUnstableMap.size) || (r.sectionRowMaxHeights = this.computeSectionRowMaxHeights()), this.setState(Object.assign(Object.assign({
                    shrinkWidths: this.computeShrinkWidths()
                }, this.computeScrollerDims()), r), () => {
                    this.rowUnstableMap.size || this.updateStickyScrolling()
                }))
            }, this.handleRowHeightChange = (e, t) => {
                var {
                    rowUnstableMap: r,
                    rowInnerMaxHeightMap: n
                } = this;
                t ? (r.delete(e), t = ic(e), n.has(e) && n.get(e) === t || (n.set(e, t), this.anyRowHeightsChanged = !0), !r.size && this.anyRowHeightsChanged && (this.anyRowHeightsChanged = !1, this.setState({
                    sectionRowMaxHeights: this.computeSectionRowMaxHeights()
                }))) : r.set(e, !0)
            }
        }
        render() {
            let {
                props: e,
                state: t,
                context: r
            } = this, n = t.shrinkWidths, i = this.compileColGroupStats(e.colGroups.map(e => [e])), s = this.renderMicroColGroups(i.map((e, t) => [e.cols, n[t]])), o = _s(e.liquid, r);
            this.getDims();
            let a, l = e.sections,
                c = l.length,
                d = 0,
                u = [],
                h = [],
                f = [];
            for (; d < c && "header" === (a = l[d]).type;) u.push(this.renderSection(a, d, i, s, t.sectionRowMaxHeights, !0)), d += 1;
            for (; d < c && "body" === (a = l[d]).type;) h.push(this.renderSection(a, d, i, s, t.sectionRowMaxHeights, !1)), d += 1;
            for (; d < c && "footer" === (a = l[d]).type;) f.push(this.renderSection(a, d, i, s, t.sectionRowMaxHeights, !0)), d += 1;
            var g = !hi(),
                p = {
                    role: "rowgroup"
                };
            return b("table", {
                ref: e.elRef,
                role: "grid",
                className: o.join(" ")
            }, ((e, n) => (e = e.map((e, t) => {
                let r = e.width;
                return b("col", {
                    style: {
                        width: r = "shrink" === r ? e.totalColWidth + Ms(n[t]) + 1 : r
                    }
                })
            }), b("colgroup", {}, ...e)))(i, n), Boolean(!g && u.length) && b("thead", p, ...u), Boolean(!g && h.length) && b("tbody", p, ...h), Boolean(!g && f.length) && b("tfoot", p, ...f), g && b("tbody", p, ...u, ...h, ...f))
        }
        renderSection(r, n, i, s, o, a) {
            return "outerContent" in r ? b(A, {
                key: r.key
            }, r.outerContent) : b("tr", {
                key: r.key,
                role: "presentation",
                className: Is(r, this.props.liquid).join(" ")
            }, r.chunks.map((e, t) => this.renderChunk(r, n, i[t], s[t], e, t, (o[n] || [])[t] || [], a)))
        }
        renderChunk(e, t, r, n, i, s, o, a) {
            var l, c, d, u, h, f, g, p, m;
            return "outerContent" in i ? b(A, {
                key: i.key
            }, i.outerContent) : (h = this.state, {
                scrollerClientWidths: m,
                scrollerClientHeights: l
            } = h, [u, d] = this.getDims(), c = t * d + s, s = s === (!this.context.isRtl || Ni() ? d - 1 : 0), t = (d = t === u - 1) && h.forceXScrollbars, u = s && h.forceYScrollbars, h = r && r.allowXScrolling, f = Rs(this.props, e), g = Ds(this.props, e), p = e.expandRows && g, n = As(e, i, {
                tableColGroupNode: n,
                tableMinWidth: r && r.totalColMinWidth || "",
                clientWidth: void 0 !== m[c] ? m[c] : null,
                clientHeight: void 0 !== l[c] ? l[c] : null,
                expandRows: p,
                syncRowHeights: Boolean(e.syncRowHeights),
                rowSyncHeights: o,
                reportRowHeightChange: this.handleRowHeightChange
            }, a), r = t ? d ? "scroll" : "scroll-hidden" : h ? d ? "auto" : "scroll-hidden" : "hidden", m = u ? s ? "scroll" : "scroll-hidden" : f ? s ? "auto" : "scroll-hidden" : "hidden", n = b($l, {
                ref: this.clippedScrollerRefs.createRef(c),
                scrollerElRef: this.scrollerElRefs.createRef(c),
                overflowX: r,
                overflowY: m,
                forPrint: this.props.forPrint,
                liquid: g,
                maxHeight: e.maxHeight
            }, n), b(a ? "th" : "td", {
                key: i.key,
                ref: this.chunkElRefs.createRef(c),
                role: "presentation"
            }, n))
        }
        componentDidMount() {
            this.getStickyScrolling = er(hc), this.getScrollSyncersBySection = tr(dc.bind(this, !0), null, uc), this.getScrollSyncersByColumn = tr(dc.bind(this, !1), null, uc), this.updateScrollSyncers(), this.handleSizing(!1), this.context.addResizeHandler(this.handleSizing)
        }
        componentDidUpdate(e, t) {
            this.updateScrollSyncers(), this.handleSizing(!1, t.sectionRowMaxHeights !== this.state.sectionRowMaxHeights)
        }
        componentWillUnmount() {
            this.context.removeResizeHandler(this.handleSizing), this.destroyScrollSyncers()
        }
        allowSizing() {
            var e = new Date;
            return !this.lastSizingDate || e.valueOf() > this.lastSizingDate.valueOf() + N.SCROLLGRID_RESIZE_INTERVAL ? (this.lastSizingDate = e, !(this.recentSizingCnt = 0)) : (this.recentSizingCnt += 1) <= 10
        }
        computeShrinkWidths() {
            let e = this.compileColGroupStats(this.props.colGroups.map(e => [e])),
                [t, r] = this.getDims(),
                n = t * r,
                i = [];
            return e.forEach((e, t) => {
                e.hasShrinkCol && (e = this.chunkElRefs.collect(t, n, r), i[t] = ws(e))
            }), i
        }
        computeSectionRowMaxHeights() {
            let i = new Map,
                [e, s] = this.getDims(),
                t = [];
            for (let n = 0; n < e; n += 1) {
                var o = this.props.sections[n],
                    a = [];
                if (o && o.syncRowHeights) {
                    var l = [];
                    for (let e = 0; e < s; e += 1) {
                        var c = n * s + e,
                            c = this.chunkElRefs.currentMap[c],
                            c = c ? Je(c, ".fc-scrollgrid-sync-table tr").map(e => {
                                var t = ic(e);
                                return i.set(e, t), t
                            }) : [];
                        l.push(c)
                    }
                    let r = l[0].length,
                        t = !0;
                    for (let e = 1; e < s; e += 1)
                        if ((!o.chunks[e] || void 0 === o.chunks[e].outerContent) && l[e].length !== r) {
                            t = !1;
                            break
                        } if (t) {
                        for (let e = 0; e < s; e += 1) a.push([]);
                        for (let t = 0; t < r; t += 1) {
                            var d = [];
                            for (let e = 0; e < s; e += 1) {
                                var u = l[e][t];
                                null != u && d.push(u)
                            }
                            var h = Math.max(...d);
                            for (let e = 0; e < s; e += 1) a[e].push(h)
                        }
                    } else {
                        var f = [];
                        for (let e = 0; e < s; e += 1) f.push((e => {
                            let t = 0;
                            for (var r of e) t += r;
                            return t
                        })(l[e]) + l[e].length);
                        var g = Math.max(...f);
                        for (let o = 0; o < s; o += 1) {
                            let e = l[o].length,
                                t = g - e,
                                r = Math.floor(t / e),
                                n = t - r * (e - 1),
                                i = [],
                                s = 0;
                            for (s < e && (i.push(n), s += 1); s < e;) i.push(r), s += 1;
                            a.push(i)
                        }
                    }
                }
                t.push(a)
            }
            return this.rowInnerMaxHeightMap = i, t
        }
        computeScrollerDims() {
            let r = Hi(),
                [n, i] = this.getDims(),
                s = !this.context.isRtl || Ni() ? i - 1 : 0,
                o = n - 1,
                t = this.clippedScrollerRefs.currentMap,
                a = this.scrollerElRefs.currentMap,
                l = !1,
                c = !1,
                d = {},
                u = {};
            for (let e = 0; e < n; e += 1) {
                var h = t[e * i + s];
                if (h && h.needsYScrolling()) {
                    l = !0;
                    break
                }
            }
            for (let e = 0; e < i; e += 1) {
                var f = t[o * i + e];
                if (f && f.needsXScrolling()) {
                    c = !0;
                    break
                }
            }
            for (let t = 0; t < n; t += 1)
                for (let e = 0; e < i; e += 1) {
                    var g = t * i + e,
                        p = a[g];
                    p && (p = p.parentNode, d[g] = Math.floor(p.getBoundingClientRect().width - (e === s && l ? r.y : 0)), u[g] = Math.floor(p.getBoundingClientRect().height - (t === o && c ? r.x : 0)))
                }
            return {
                forceYScrollbars: l,
                forceXScrollbars: c,
                scrollerClientWidths: d,
                scrollerClientHeights: u
            }
        }
        updateStickyScrolling() {
            let t = this.context.isRtl,
                e = this.scrollerElRefs.getAll().map(e => [e, t]);
            this.getStickyScrolling(e).forEach(e => e.updateSize())
        }
        updateScrollSyncers() {
            var [t, r] = this.getDims(), n = t * r, i = {}, s = {}, o = this.scrollerElRefs.currentMap;
            for (let e = 0; e < t; e += 1) {
                var a = e * r;
                i[e] = Ir(o, a, a + r, 1)
            }
            for (let e = 0; e < r; e += 1) s[e] = this.scrollerElRefs.collect(e, n, r);
            this.scrollSyncersBySection = this.getScrollSyncersBySection(i), this.scrollSyncersByColumn = this.getScrollSyncersByColumn(s)
        }
        destroyScrollSyncers() {
            O(this.scrollSyncersBySection, uc), O(this.scrollSyncersByColumn, uc)
        }
        getChunkConfigByIndex(e) {
            var t = this.getDims()[1],
                r = Math.floor(e / t),
                r = this.props.sections[r];
            return r && r.chunks[e % t]
        }
        forceScrollLeft(e, t) {
            e = this.scrollSyncersByColumn[e];
            e && e.forceScrollLeft(t)
        }
        forceScrollTop(e, t) {
            e = this.scrollSyncersBySection[e];
            e && e.forceScrollTop(t)
        }
        _handleChunkEl(e, t) {
            t = this.getChunkConfigByIndex(parseInt(t, 10));
            t && o(t.elRef, e)
        }
        _handleScrollerEl(e, t) {
            t = this.getChunkConfigByIndex(parseInt(t, 10));
            t && o(t.scrollerElRef, e)
        }
        getDims() {
            var e = this.props.sections.length;
            return [e, e ? this.props.sections[0].chunks.length : 0]
        }
    }

    function ic(e) {
        e = Je(e, ".fc-scrollgrid-sync-inner").map(sc);
        return e.length ? Math.max(...e) : 0
    }

    function sc(e) {
        return e.offsetHeight
    }

    function oc(e) {
        var t = ac(e.cols, "width"),
            r = ac(e.cols, "minWidth"),
            n = ks(e.cols);
        return {
            hasShrinkCol: n,
            totalColWidth: t,
            totalColMinWidth: r,
            allowXScrolling: "shrink" !== e.width && Boolean(t || r || n),
            cols: e.cols,
            width: e.width
        }
    }

    function ac(e, t) {
        let r = 0;
        for (var n of e) {
            var i = n[t];
            "number" == typeof i && (r += i * (n.span || 1))
        }
        return r
    }
    nc.addStateEquality({
        shrinkWidths: d,
        scrollerClientWidths: h,
        scrollerClientHeights: h
    });
    let lc = {
        cols: xs
    };

    function cc(e, t) {
        return _r(e, t, lc)
    }

    function dc(e, ...t) {
        return new rc(e, t)
    }

    function uc(e) {
        e.destroy()
    }

    function hc(e, t) {
        return new Kl(e, t)
    }
    var fc = C({
        name: "@fullcalendar/scrollgrid",
        premiumReleaseDate: "2025-06-30",
        deps: [Zl],
        scrollGridImpl: nc
    });
    N.COLLAPSIBLE_WIDTH_THRESHOLD = 1200;
    let gc = [],
        pc = [];

    function mc() {
        for (var e of gc) e.emitter.trigger("_beforeprint");
        Br(() => {
            pc.push((() => {
                let e = Je(document.body, ".fc-scrollgrid");
                return e.forEach(yc), () => e.forEach(bc)
            })())
        })
    }

    function vc() {
        for (var e of gc) e.emitter.trigger("_afterprint");
        Br(() => {
            for (; pc.length;) pc.shift()()
        })
    }

    function yc(e) {
        var t = e.getBoundingClientRect().width;
        (!e.classList.contains("fc-scrollgrid-collapsible") || t < N.COLLAPSIBLE_WIDTH_THRESHOLD) && (e.style.width = t + "px")
    }

    function bc(e) {
        e.style.width = ""
    }
    Fe(".fc .fc-event,.fc .fc-scrollgrid table tr{-moz-column-break-inside:avoid;break-inside:avoid}.fc-media-print{display:block;max-width:100%}.fc-media-print .fc-bg-event,.fc-media-print .fc-non-business,.fc-media-print .fc-timegrid-axis-chunk,.fc-media-print .fc-timegrid-slots,.fc-media-print .fc-timeline-slots{display:none}.fc-media-print .fc-h-event,.fc-media-print .fc-toolbar button,.fc-media-print .fc-v-event{background:#fff!important;color:#000!important}.fc-media-print .fc-event,.fc-media-print .fc-event-main{color:#000!important}.fc-media-print .fc-timegrid-event{margin:.5em 0}");
    var Sc = C({
        name: "@fullcalendar/adaptive",
        premiumReleaseDate: "2025-06-30",
        deps: [Zl],
        contextInit: function(e) {
            gc.length || (window.addEventListener("beforeprint", mc), window.addEventListener("afterprint", vc)), gc.push(e), e.calendarApi.on("_unmount", () => {
                Pt(gc, e), gc.length || (window.removeEventListener("beforeprint", mc), window.removeEventListener("afterprint", vc))
            })
        }
    });
    N.MAX_TIMELINE_SLOTS = 1e3;
    let Ec = [{
        years: 1
    }, {
        months: 1
    }, {
        days: 1
    }, {
        hours: 1
    }, {
        minutes: 30
    }, {
        minutes: 15
    }, {
        minutes: 10
    }, {
        minutes: 5
    }, {
        minutes: 1
    }, {
        seconds: 30
    }, {
        seconds: 15
    }, {
        seconds: 10
    }, {
        seconds: 5
    }, {
        seconds: 1
    }, {
        milliseconds: 500
    }, {
        milliseconds: 100
    }, {
        milliseconds: 10
    }, {
        milliseconds: 1
    }];

    function Cc(e, t, l, r) {
        var c = {
                labelInterval: l.slotLabelInterval,
                slotDuration: l.slotDuration
            },
            n = c,
            i = e,
            s = t;
        if (i = i.currentRange, n.labelInterval && s.countDurationsBetween(i.start, i.end, n.labelInterval) > N.MAX_TIMELINE_SLOTS && (console.warn("slotLabelInterval results in too many cells"), n.labelInterval = null), n.slotDuration && s.countDurationsBetween(i.start, i.end, n.slotDuration) > N.MAX_TIMELINE_SLOTS && (console.warn("slotDuration results in too many cells"), n.slotDuration = null), n.labelInterval && n.slotDuration) {
            let e = It(n.labelInterval, n.slotDuration);
            (null === e || e < 1) && (console.warn("slotLabelInterval must be a multiple of slotDuration"), n.slotDuration = null)
        }
        Rc(c, e, t);
        {
            s = c;
            var o = e,
                a = t;
            i = o.currentRange;
            let r = s.slotDuration;
            if (!r) {
                var d, u = Rc(s, o, a);
                for (d of Ec) {
                    let e = M(d),
                        t = It(u, e);
                    if (null !== t && 1 < t && t <= 6) {
                        r = e;
                        break
                    }
                }
                r = (r = r && 200 < a.countDurationsBetween(i.start, i.end, r) ? null : r) || u, s.slotDuration = r
            }
        }
        n = l.slotLabelFormat, o = Array.isArray(n) ? n : null != n ? [n] : ((e, t) => {
            let r, n;
            var i = c.labelInterval;
            let s = Ot(i).unit;
            var o = l.weekNumbers;
            let a = r = n = null;
            switch (s = "week" !== s || o ? s : "day") {
                case "year":
                    a = {
                        year: "numeric"
                    };
                    break;
                case "month":
                    1 < Ac("years", e, t) && (a = {
                        year: "numeric"
                    }), r = {
                        month: "short"
                    };
                    break;
                case "week":
                    1 < Ac("years", e, t) && (a = {
                        year: "numeric"
                    }), r = {
                        week: "narrow"
                    };
                    break;
                case "day":
                    1 < Ac("years", e, t) ? a = {
                        year: "numeric",
                        month: "long"
                    } : 1 < Ac("months", e, t) && (a = {
                        month: "long"
                    }), o && (r = {
                        week: "short"
                    }), n = {
                        weekday: "narrow",
                        day: "numeric"
                    };
                    break;
                case "hour":
                    o && (a = {
                        week: "short"
                    }), 1 < Ac("days", e, t) && (r = {
                        weekday: "short",
                        day: "numeric",
                        month: "numeric",
                        omitCommas: !0
                    }), n = {
                        hour: "numeric",
                        minute: "2-digit",
                        omitZeroMinute: !0,
                        meridiem: "short"
                    };
                    break;
                case "minute":
                    6 <= kt(i) / 60 ? (a = {
                        hour: "numeric",
                        meridiem: "short"
                    }, r = e => ":" + T(e.date.minute, 2)) : a = {
                        hour: "numeric",
                        minute: "numeric",
                        meridiem: "short"
                    };
                    break;
                case "second":
                    6 <= _t(i) / 60 ? (a = {
                        hour: "numeric",
                        minute: "2-digit",
                        meridiem: "lowercase"
                    }, r = e => ":" + T(e.date.second, 2)) : a = {
                        hour: "numeric",
                        minute: "2-digit",
                        second: "2-digit",
                        meridiem: "lowercase"
                    };
                    break;
                case "millisecond":
                    a = {
                        hour: "numeric",
                        minute: "2-digit",
                        second: "2-digit",
                        meridiem: "lowercase"
                    }, r = e => "." + T(e.millisecond, 3)
            }
            return [].concat(a || [], r || [], n || [])
        })(e, t);
        c.headerFormats = o.map(e => I(e)), c.isTimeScale = Boolean(c.slotDuration.milliseconds);
        let h = null;
        if (!c.isTimeScale) {
            let e = Ot(c.slotDuration).unit;
            /year|month|week/.test(e) && (h = e)
        }
        c.largeUnit = h, c.emphasizeWeeks = 1 === At(c.slotDuration) && 2 <= Ac("weeks", e, t) && !l.businessHours;
        let f, g, p = l.snapDuration,
            m = (p && (f = M(p), g = It(c.slotDuration, f)), null == g && (f = c.slotDuration, g = 1), c.snapDuration = f, c.snapsPerSlot = g, k(e.slotMaxTime) - k(e.slotMinTime)),
            v = wc(e.renderRange.start, c, t),
            y = wc(e.renderRange.end, c, t),
            b = (c.isTimeScale && (v = t.add(v, e.slotMinTime), y = t.add(_(y, -1), e.slotMaxTime)), c.timeWindowMs = m, c.normalizedRange = {
                start: v,
                end: y
            }, []),
            S = v;
        for (; S < y;) Dc(S, c, e, r) && b.push(S), S = t.add(S, c.slotDuration);
        c.slotDates = b;
        let E = -1,
            C = 0;
        var w = [],
            D = [];
        for (S = v; S < y;) Dc(S, c, e, r) ? (E += 1, w.push(E), D.push(C)) : w.push(E + .5), S = t.add(S, c.snapDuration), C += 1;
        return c.snapDiffToIndex = w, c.snapIndexToDiff = D, c.snapCnt = E + 1, c.slotCnt = c.snapCnt / c.snapsPerSlot, c.isWeekStarts = (e => {
            let {
                slotDates: t,
                emphasizeWeeks: r
            } = c, n = null, i = [];
            for (var s of t) {
                var s = e.computeWeekNumber(s),
                    o = r && null !== n && n !== s;
                n = s, i.push(o)
            }
            return i
        })(t), c.cellRows = ((l, c) => {
            var t = l.slotDates,
                d = l.headerFormats,
                u = d.map(() => []),
                e = At(l.slotDuration),
                h = 7 === e ? "week" : 1 === e ? "day" : null,
                f = d.map(e => e.getSmallestUnit ? e.getSmallestUnit() : null);
            for (let e = 0; e < t.length; e += 1) {
                var g, p = t[e],
                    m = l.isWeekStarts[e];
                for (let a = 0; a < d.length; a += 1) {
                    let e = d[a],
                        t = u[a],
                        r = t[t.length - 1],
                        n = a === d.length - 1,
                        i = 1 < d.length && !n,
                        s = null,
                        o = f[a] || (n ? h : null);
                    i ? (g = c.format(p, e), r && r.text === g ? r.colspan += 1 : s = xc(p, g, o)) : !r || Ct(c.countDurationsBetween(l.normalizedRange.start, p, l.labelInterval)) ? (g = c.format(p, e), s = xc(p, g, o)) : r.colspan += 1, s && (s.weekStart = m, t.push(s))
                }
            }
            return u
        })(c, t), c.slotsPerLabel = It(c.labelInterval, c.slotDuration), c
    }

    function wc(e, t, r) {
        let n = e;
        return t.isTimeScale || (n = v(n), t.largeUnit && (n = r.startOf(n, t.largeUnit))), n
    }

    function Dc(e, t, r, n) {
        return !n.isHiddenDay(e) && (!t.isTimeScale || (n = v(e), ((e.valueOf() - n.valueOf() - k(r.slotMinTime)) % 864e5 + 864e5) % 864e5 < t.timeWindowMs))
    }

    function Rc(n, e, t) {
        let i = e.currentRange,
            s = n.labelInterval;
        if (!s) {
            let r;
            if (n.slotDuration) {
                for (r of Ec) {
                    let e = M(r),
                        t = It(e, n.slotDuration);
                    if (null !== t && t <= 6) {
                        s = e;
                        break
                    }
                }
                s = s || n.slotDuration
            } else
                for (r of Ec)
                    if (s = M(r), 18 <= t.countDurationsBetween(i.start, i.end, s)) break;
            n.labelInterval = s
        }
        return s
    }

    function Ac(e, t, r) {
        let n = t.currentRange,
            i = null;
        return "years" === e ? i = r.diffWholeYears(n.start, n.end) : "months" === e || "weeks" === e ? i = r.diffWholeMonths(n.start, n.end) : "days" === e && (i = zt(n.start, n.end)), i || 0
    }

    function xc(e, t, r) {
        return {
            date: e,
            text: t,
            rowUnit: r,
            colspan: 1,
            isWeekStart: !1
        }
    }
    class Tc extends s {
        constructor() {
            super(...arguments), this.refineRenderProps = $t(_c), this.buildCellNavLinkAttrs = f(Mc)
        }
        render() {
            let {
                props: t,
                context: r
            } = this, {
                dateEnv: e,
                options: n
            } = r, {
                cell: i,
                dateProfile: s,
                tDateProfile: o
            } = t, a = xi(i.date, t.todayRange, t.nowDate, s), l = this.refineRenderProps({
                level: t.rowLevel,
                dateMarker: i.date,
                text: i.text,
                dateEnv: r.dateEnv,
                viewApi: r.viewApi
            });
            return b(g, {
                elTag: "th",
                elClasses: ["fc-timeline-slot", "fc-timeline-slot-label", i.isWeekStart && "fc-timeline-slot-em", ...("time" === i.rowUnit ? Mi : Ti)(a, r.theme)],
                elAttrs: {
                    colSpan: i.colspan,
                    "data-date": e.formatIso(i.date, {
                        omitTime: !o.isTimeScale,
                        omitTimeZoneOffset: !0
                    })
                },
                renderProps: l,
                generatorName: "slotLabelContent",
                customGenerator: n.slotLabelContent,
                defaultGenerator: kc,
                classNameGenerator: n.slotLabelClassNames,
                didMount: n.slotLabelDidMount,
                willUnmount: n.slotLabelWillUnmount
            }, e => b("div", {
                className: "fc-timeline-slot-frame",
                style: {
                    height: t.rowInnerHeight
                }
            }, b(e, {
                elTag: "a",
                elClasses: ["fc-timeline-slot-cushion", "fc-scrollgrid-sync-inner", t.isSticky && "fc-sticky"],
                elAttrs: this.buildCellNavLinkAttrs(r, i.date, i.rowUnit)
            })))
        }
    }

    function Mc(e, t, r) {
        return r && "time" !== r ? Ii(e, t, r) : {}
    }

    function kc(e) {
        return e.text
    }

    function _c(e) {
        return {
            level: e.level,
            date: e.dateEnv.toDate(e.dateMarker),
            view: e.viewApi,
            text: e.text
        }
    }
    class Ic extends s {
        render() {
            let {
                dateProfile: i,
                tDateProfile: s,
                rowInnerHeights: o,
                todayRange: a,
                nowDate: l
            } = this.props, c = s.cellRows;
            return b(A, null, c.map((e, t) => {
                let r = t === c.length - 1,
                    n = s.isTimeScale && r;
                return b("tr", {
                    key: t,
                    className: ["fc-timeline-header-row", n ? "fc-timeline-header-row-chrono" : ""].join(" ")
                }, e.map(e => b(Tc, {
                    key: e.date.toISOString(),
                    cell: e,
                    rowLevel: t,
                    dateProfile: i,
                    tDateProfile: s,
                    todayRange: a,
                    nowDate: l,
                    rowInnerHeight: o && o[t],
                    isSticky: !r
                })))
            }))
        }
    }
    class Oc {
        constructor(e, t, r, n, i, s) {
            this.slatRootEl = e, this.dateProfile = r, this.tDateProfile = n, this.dateEnv = i, this.isRtl = s, this.outerCoordCache = new Ui(e, t, !0, !1), this.innerCoordCache = new Ui(e, Ke(t, "div"), !0, !1)
        }
        isDateInRange(e) {
            return S(this.dateProfile.currentRange, e)
        }
        dateToCoord(e) {
            var t = this.tDateProfile,
                e = this.computeDateSnapCoverage(e) / t.snapsPerSlot,
                r = Math.floor(e),
                e = e - (r = Math.min(r, t.slotCnt - 1)),
                {
                    innerCoordCache: t,
                    outerCoordCache: n
                } = this;
            return this.isRtl ? n.originClientRect.width - (n.rights[r] - t.getWidth(r) * e) : n.lefts[r] + t.getWidth(r) * e
        }
        rangeToCoords(e) {
            return {
                start: this.dateToCoord(e.start),
                end: this.dateToCoord(e.end)
            }
        }
        durationToCoord(t) {
            let {
                dateProfile: r,
                tDateProfile: n,
                dateEnv: i,
                isRtl: s
            } = this, o = 0;
            if (r) {
                let e = i.add(r.activeRange.start, t);
                n.isTimeScale || (e = v(e)), o = this.dateToCoord(e), !s && o && (o += 1)
            }
            return o
        }
        coordFromLeft(e) {
            return this.isRtl ? this.outerCoordCache.originClientRect.width - e : e
        }
        computeDateSnapCoverage(e) {
            return Pc(e, this.tDateProfile, this.dateEnv)
        }
    }

    function Pc(e, t, r) {
        r = r.countDurationsBetween(t.normalizedRange.start, e, t.snapDuration);
        if (r < 0) return 0;
        if (r >= t.snapDiffToIndex.length) return t.snapCnt;
        let n = Math.floor(r),
            i = t.snapDiffToIndex[n];
        return Ct(i) ? i += r - n : i = Math.ceil(i), i
    }

    function Nc(e, t) {
        return null === e ? {
            left: "",
            right: ""
        } : t ? {
            right: e,
            left: ""
        } : {
            left: e,
            right: ""
        }
    }

    function Hc(e, t) {
        return e ? t ? {
            right: e.start,
            left: -e.end
        } : {
            left: e.start,
            right: -e.end
        } : {
            left: "",
            right: ""
        }
    }
    class Wc extends s {
        constructor() {
            super(...arguments), this.rootElRef = {
                current: null
            }
        }
        render() {
            let {
                props: r,
                context: n
            } = this, e = Ot(r.tDateProfile.slotDuration).unit, i = r.slatCoords && r.slatCoords.dateProfile === r.dateProfile ? r.slatCoords : null;
            return b(m, {
                unit: e
            }, (e, t) => b("div", {
                className: "fc-timeline-header",
                ref: this.rootElRef
            }, b("table", {
                "aria-hidden": !0,
                className: "fc-scrollgrid-sync-table",
                style: {
                    minWidth: r.tableMinWidth,
                    width: r.clientWidth
                }
            }, r.tableColGroupNode, b("tbody", null, b(Ic, {
                dateProfile: r.dateProfile,
                tDateProfile: r.tDateProfile,
                nowDate: e,
                todayRange: t,
                rowInnerHeights: r.rowInnerHeights
            }))), n.options.nowIndicator && b("div", {
                className: "fc-timeline-now-indicator-container"
            }, i && i.isDateInRange(e) && b(Ls, {
                elClasses: ["fc-timeline-now-indicator-arrow"],
                elStyle: Nc(i.dateToCoord(e), n.isRtl),
                isAxis: !0,
                date: e
            }))))
        }
        componentDidMount() {
            this.updateSize()
        }
        componentDidUpdate() {
            this.updateSize()
        }
        updateSize() {
            this.props.onMaxCushionWidth && this.props.onMaxCushionWidth(this.computeMaxCushionWidth())
        }
        computeMaxCushionWidth() {
            return Math.max(...Je(this.rootElRef.current, ".fc-timeline-header-row:last-child .fc-timeline-slot-cushion").map(e => e.getBoundingClientRect().width))
        }
    }
    class Bc extends s {
        render() {
            var {
                props: e,
                context: t
            } = this, {
                dateEnv: r,
                options: n,
                theme: i
            } = t, {
                date: s,
                tDateProfile: o,
                isEm: a
            } = e, l = xi(e.date, e.todayRange, e.nowDate, e.dateProfile), t = Object.assign(Object.assign({
                date: r.toDate(e.date)
            }, l), {
                view: t.viewApi
            });
            return b(g, {
                elTag: "td",
                elRef: e.elRef,
                elClasses: ["fc-timeline-slot", "fc-timeline-slot-lane", a && "fc-timeline-slot-em", o.isTimeScale ? Ct(r.countDurationsBetween(o.normalizedRange.start, e.date, o.labelInterval)) ? "fc-timeline-slot-major" : "fc-timeline-slot-minor" : "", ...(e.isDay ? Ti : Mi)(l, i)],
                elAttrs: {
                    "data-date": r.formatIso(s, {
                        omitTimeZoneOffset: !0,
                        omitTime: !o.isTimeScale
                    })
                },
                renderProps: t,
                generatorName: "slotLaneContent",
                customGenerator: n.slotLaneContent,
                classNameGenerator: n.slotLaneClassNames,
                didMount: n.slotLaneDidMount,
                willUnmount: n.slotLaneWillUnmount
            }, e => b(e, {
                elTag: "div"
            }))
        }
    }
    class jc extends s {
        render() {
            let n = this.props,
                {
                    tDateProfile: i,
                    cellElRefs: s
                } = n,
                {
                    slotDates: e,
                    isWeekStarts: o
                } = i,
                a = !i.isTimeScale && !i.largeUnit;
            return b("tbody", null, b("tr", null, e.map((e, t) => {
                var r = e.toISOString();
                return b(Bc, {
                    key: r,
                    elRef: s.createRef(r),
                    date: e,
                    dateProfile: n.dateProfile,
                    tDateProfile: i,
                    nowDate: n.nowDate,
                    todayRange: n.todayRange,
                    isEm: o[t],
                    isDay: a
                })
            })))
        }
    }
    class Lc extends s {
        constructor() {
            super(...arguments), this.rootElRef = {
                current: null
            }, this.cellElRefs = new y, this.handleScrollRequest = e => {
                var t = this.props.onScrollLeftRequest,
                    r = this.coords;
                return t && r ? (e.time && t(r.coordFromLeft(r.durationToCoord(e.time))), !0) : null
            }
        }
        render() {
            var {
                props: e,
                context: t
            } = this;
            return b("div", {
                className: "fc-timeline-slots",
                ref: this.rootElRef
            }, b("table", {
                "aria-hidden": !0,
                className: t.theme.getClass("table"),
                style: {
                    minWidth: e.tableMinWidth,
                    width: e.clientWidth
                }
            }, e.tableColGroupNode, b(jc, {
                cellElRefs: this.cellElRefs,
                dateProfile: e.dateProfile,
                tDateProfile: e.tDateProfile,
                nowDate: e.nowDate,
                todayRange: e.todayRange
            })))
        }
        componentDidMount() {
            this.updateSizing(), this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest)
        }
        componentDidUpdate(e) {
            this.updateSizing(), this.scrollResponder.update(e.dateProfile !== this.props.dateProfile)
        }
        componentWillUnmount() {
            this.scrollResponder.detach(), this.props.onCoords && this.props.onCoords(null)
        }
        updateSizing() {
            var t, {
                props: e,
                context: r
            } = this;
            null !== e.clientWidth && this.scrollResponder && this.rootElRef.current.offsetWidth && (this.coords = new Oc(this.rootElRef.current, (t = this.cellElRefs.currentMap, e.tDateProfile.slotDates.map(e => {
                e = e.toISOString();
                return t[e]
            })), e.dateProfile, e.tDateProfile, r.dateEnv, r.isRtl), e.onCoords && e.onCoords(this.coords), this.scrollResponder.update(!1))
        }
        positionToHit(e) {
            var t, r = this.coords.outerCoordCache,
                {
                    dateEnv: n,
                    isRtl: i
                } = this.context,
                s = this.props.tDateProfile,
                o = r.leftToIndex(e);
            return null != o ? (t = r.getWidth(o), i = i ? (r.rights[o] - e) / t : (e - r.lefts[o]) / t, e = Math.floor(i * s.snapsPerSlot), {
                dateSpan: {
                    range: {
                        start: t = n.add(s.slotDates[o], Tt(s.snapDuration, e)),
                        end: n.add(t, s.snapDuration)
                    },
                    allDay: !this.props.tDateProfile.isTimeScale
                },
                dayEl: this.cellElRefs.currentMap[o],
                left: r.lefts[o],
                right: r.rights[o]
            }) : null
        }
    }

    function zc(e, n, i) {
        var s = [];
        if (i)
            for (var o of e) {
                let e = i.rangeToCoords(o),
                    t = Math.round(e.start),
                    r = Math.round(e.end);
                r - t < n && (r = t + n), s.push({
                    start: t,
                    end: r
                })
            }
        return s
    }
    class Uc extends s {
        render() {
            var e = this.props,
                t = [].concat(e.eventResizeSegs, e.dateSelectionSegs);
            return e.timelineCoords && b("div", {
                className: "fc-timeline-bg"
            }, this.renderSegs(e.businessHourSegs || [], e.timelineCoords, "non-business"), this.renderSegs(e.bgEventSegs || [], e.timelineCoords, "bg-event"), this.renderSegs(t, e.timelineCoords, "highlight"))
        }
        renderSegs(e, t, r) {
            let {
                todayRange: n,
                nowDate: i
            } = this.props, s = this.context.isRtl, o = zc(e, 0, t), a = e.map((e, t) => {
                t = Hc(o[t], s);
                return b("div", {
                    key: ti(e.eventRange),
                    className: "fc-timeline-bg-harness",
                    style: t
                }, "bg-event" === r ? b(Vs, Object.assign({
                    seg: e
                }, E(e, n, i))) : Ys(r))
            });
            return b(A, null, a)
        }
    }
    class Gc extends fs {
        sliceRange(e, t, r, n, i) {
            e = e, a = i, !(s = n).isTimeScale && (e = nn(e), s.largeUnit) && (o = e, ((e = {
                start: a.startOf(e.start, s.largeUnit),
                end: a.startOf(e.end, s.largeUnit)
            }).end.valueOf() !== o.end.valueOf() || e.end <= e.start) && (e = {
                start: e.start,
                end: a.add(e.end, s.slotDuration)
            }));
            var s, o = e,
                a = [];
            return Pc(o.start, n, i) < Pc(o.end, n, i) && (s = D(o, n.normalizedRange)) && a.push({
                start: s.start,
                end: s.end,
                isStart: s.start.valueOf() === o.start.valueOf() && Dc(s.start, n, t, r),
                isEnd: s.end.valueOf() === o.end.valueOf() && Dc(p(s.end, -1), n, t, r)
            }), a
        }
    }
    let Fc = I({
        hour: "numeric",
        minute: "2-digit",
        omitZeroMinute: !0,
        meridiem: "narrow"
    });
    class Vc extends s {
        render() {
            var e = this.props;
            return b(Bs, Object.assign({}, e, {
                elClasses: ["fc-timeline-event", "fc-h-event"],
                defaultTimeFormat: Fc,
                defaultDisplayEventTime: !e.isTimeScale
            }))
        }
    }
    class qc extends s {
        render() {
            let {
                props: r,
                context: e
            } = this, {
                hiddenSegs: t,
                placement: n,
                resourceId: i
            } = r, {
                top: s,
                hcoords: o
            } = n, a = o && null !== s, l = Hc(o, e.isRtl), c = i ? {
                resourceId: i
            } : {};
            return b(Ks, {
                elRef: r.elRef,
                elClasses: ["fc-timeline-more-link"],
                elStyle: Object.assign({
                    visibility: a ? "" : "hidden",
                    top: s || 0
                }, l),
                allDayDate: null,
                moreCnt: t.length,
                allSegs: t,
                hiddenSegs: t,
                dateProfile: r.dateProfile,
                todayRange: r.todayRange,
                extraDateSpan: c,
                popoverContent: () => b(A, null, t.map(e => {
                    var t = e.eventRange.instance.instanceId;
                    return b("div", {
                        key: t,
                        style: {
                            visibility: r.isForcedInvisible[t] ? "hidden" : ""
                        }
                    }, b(Vc, Object.assign({
                        isTimeScale: r.isTimeScale,
                        seg: e,
                        isDragging: !1,
                        isResizing: !1,
                        isDateSelecting: !1,
                        isSelected: t === r.eventSelection
                    }, E(e, r.todayRange, r.nowDate))))
                }))
            }, e => b(e, {
                elTag: "div",
                elClasses: ["fc-timeline-more-link-inner", "fc-sticky"]
            }))
        }
    }
    class Yc extends s {
        constructor() {
            super(...arguments), this.slicer = new Gc, this.sortEventSegs = f(Kn), this.harnessElRefs = new y, this.moreElRefs = new y, this.innerElRef = {
                current: null
            }, this.state = {
                eventInstanceHeights: {},
                moreLinkHeights: {}
            }, this.handleResize = e => {
                e && this.updateSize()
            }
        }
        render() {
            var {
                props: e,
                state: t,
                context: r
            } = this, n = r.options, {
                dateProfile: i,
                tDateProfile: s
            } = e, i = this.slicer.sliceProps(e, i, s.isTimeScale ? null : e.nextDayThreshold, r, i, r.dateProfileGenerator, s, r.dateEnv), s = (i.eventDrag ? i.eventDrag.segs : null) || (i.eventResize ? i.eventResize.segs : null) || [], r = this.sortEventSegs(i.fgEventSegs, n.eventOrder), [r, t] = ((t, r, n, i, e, s) => {
                var o = [],
                    a = [];
                for (let e = 0; e < t.length; e += 1) {
                    var l = t[e],
                        c = n[l.eventRange.instance.instanceId],
                        d = r[e];
                    c && d ? o.push({
                        index: e,
                        span: d,
                        thickness: c
                    }) : a.push({
                        seg: l,
                        hcoords: d,
                        top: null
                    })
                }
                var u, h = new Yi;
                null != e && (h.strictOrder = e), null != s && (h.maxStackCnt = s);
                var s = (e = h.addSegs(o)).map(e => ({
                        seg: t[e.index],
                        hcoords: e.span,
                        top: null
                    })),
                    f = Xi(e),
                    g = [],
                    p = [],
                    m = e => t[e.index];
                for (let e = 0; e < f.length; e += 1) {
                    var v = f[e],
                        y = v.entries.map(m),
                        b = i[Qt(to(y))];
                    null != b ? g.push({
                        index: t.length + e,
                        thickness: b,
                        span: v.span
                    }) : p.push({
                        seg: y,
                        hcoords: v.span,
                        top: null
                    })
                }
                h.maxStackCnt = -1, h.addSegs(g);
                let S = h.toRects(),
                    E = [],
                    C = 0;
                for (u of S) {
                    var w = u.index;
                    E.push({
                        seg: w < t.length ? t[w] : f[w - t.length].entries.map(m),
                        hcoords: u.span,
                        top: u.levelCoord
                    }), C = Math.max(C, u.levelCoord + u.thickness)
                }
                return [E.concat(a, s, p), C]
            })(r, zc(r, n.eventMinWidth, e.timelineCoords), t.eventInstanceHeights, t.moreLinkHeights, n.eventOrderStrict, n.eventMaxStack), n = (i.eventDrag ? i.eventDrag.affectedInstances : null) || (i.eventResize ? i.eventResize.affectedInstances : null) || {};
            return b(A, null, b(Uc, {
                businessHourSegs: i.businessHourSegs,
                bgEventSegs: i.bgEventSegs,
                timelineCoords: e.timelineCoords,
                eventResizeSegs: i.eventResize ? i.eventResize.segs : [],
                dateSelectionSegs: i.dateSelectionSegs,
                nowDate: e.nowDate,
                todayRange: e.todayRange
            }), b("div", {
                className: "fc-timeline-events fc-scrollgrid-sync-inner",
                ref: this.innerElRef,
                style: {
                    height: t
                }
            }, this.renderFgSegs(r, n, !1, !1, !1), this.renderFgSegs(((e, t, n) => {
                if (!e.length || !t) return [];
                let r = (() => {
                    var e, t = {};
                    for (e of n) {
                        var r = e.seg;
                        Array.isArray(r) || (t[r.eventRange.instance.instanceId] = e.top)
                    }
                    return t
                })();
                return e.map(e => ({
                    seg: e,
                    hcoords: t.rangeToCoords(e),
                    top: r[e.eventRange.instance.instanceId]
                }))
            })(s, e.timelineCoords, r), {}, Boolean(i.eventDrag), Boolean(i.eventResize), !1)))
        }
        componentDidMount() {
            this.updateSize(), this.context.addResizeHandler(this.handleResize)
        }
        componentDidUpdate(e, t) {
            e.eventStore === this.props.eventStore && e.timelineCoords === this.props.timelineCoords && t.moreLinkHeights === this.state.moreLinkHeights || this.updateSize()
        }
        componentWillUnmount() {
            this.context.removeResizeHandler(this.handleResize)
        }
        updateSize() {
            let e = this.props,
                t = e.timelineCoords,
                r = this.innerElRef.current;
            e.onHeightChange && e.onHeightChange(r, !1), t && this.setState({
                eventInstanceHeights: O(this.harnessElRefs.currentMap, e => Math.round(e.getBoundingClientRect().height)),
                moreLinkHeights: O(this.moreElRefs.currentMap, e => Math.round(e.getBoundingClientRect().height))
            }, () => {
                e.onHeightChange && e.onHeightChange(r, !0)
            }), e.syncParentMinHeight && (r.parentElement.style.minHeight = r.style.height)
        }
        renderFgSegs(e, s, o, a, l) {
            let {
                harnessElRefs: c,
                moreElRefs: d,
                props: u,
                context: h
            } = this, f = o || a || l;
            return b(A, null, e.map(e => {
                var t, {
                    seg: r,
                    hcoords: n,
                    top: i
                } = e;
                return Array.isArray(r) ? (t = Qt(to(r)), b(qc, {
                    key: "m:" + t,
                    elRef: d.createRef(t),
                    hiddenSegs: r,
                    placement: e,
                    dateProfile: u.dateProfile,
                    nowDate: u.nowDate,
                    todayRange: u.todayRange,
                    isTimeScale: u.tDateProfile.isTimeScale,
                    eventSelection: u.eventSelection,
                    resourceId: u.resourceId,
                    isForcedInvisible: s
                })) : (t = r.eventRange.instance.instanceId, e = f || Boolean(!s[t] && n && null !== i), n = Hc(n, h.isRtl), b("div", {
                    key: "e:" + t,
                    ref: f ? null : c.createRef(t),
                    className: "fc-timeline-event-harness",
                    style: Object.assign({
                        visibility: e ? "" : "hidden",
                        top: i || 0
                    }, n)
                }, b(Vc, Object.assign({
                    isTimeScale: u.tDateProfile.isTimeScale,
                    seg: r,
                    isDragging: o,
                    isResizing: a,
                    isDateSelecting: l,
                    isSelected: t === u.eventSelection
                }, E(r, u.todayRange, u.nowDate)))))
            }))
        }
    }
    Yc.addStateEquality({
        eventInstanceHeights: h,
        moreLinkHeights: h
    });
    class Qc extends a {
        constructor() {
            super(...arguments), this.slatsRef = {
                current: null
            }, this.state = {
                coords: null
            }, this.handeEl = e => {
                e ? this.context.registerInteractiveComponent(this, {
                    el: e
                }) : this.context.unregisterInteractiveComponent(this)
            }, this.handleCoords = e => {
                this.setState({
                    coords: e
                }), this.props.onSlatCoords && this.props.onSlatCoords(e)
            }
        }
        render() {
            let {
                props: r,
                state: n,
                context: i
            } = this, s = i.options, {
                dateProfile: o,
                tDateProfile: a
            } = r, e = Ot(a.slotDuration).unit;
            return b("div", {
                className: "fc-timeline-body",
                ref: this.handeEl,
                style: {
                    minWidth: r.tableMinWidth,
                    height: r.clientHeight,
                    width: r.clientWidth
                }
            }, b(m, {
                unit: e
            }, (e, t) => b(A, null, b(Lc, {
                ref: this.slatsRef,
                dateProfile: o,
                tDateProfile: a,
                nowDate: e,
                todayRange: t,
                clientWidth: r.clientWidth,
                tableColGroupNode: r.tableColGroupNode,
                tableMinWidth: r.tableMinWidth,
                onCoords: this.handleCoords,
                onScrollLeftRequest: r.onScrollLeftRequest
            }), b(Yc, {
                dateProfile: o,
                tDateProfile: r.tDateProfile,
                nowDate: e,
                todayRange: t,
                nextDayThreshold: s.nextDayThreshold,
                businessHours: r.businessHours,
                eventStore: r.eventStore,
                eventUiBases: r.eventUiBases,
                dateSelection: r.dateSelection,
                eventSelection: r.eventSelection,
                eventDrag: r.eventDrag,
                eventResize: r.eventResize,
                timelineCoords: n.coords,
                syncParentMinHeight: !0
            }), s.nowIndicator && n.coords && n.coords.isDateInRange(e) && b("div", {
                className: "fc-timeline-now-indicator-container"
            }, b(Ls, {
                elClasses: ["fc-timeline-now-indicator-line"],
                elStyle: Nc(n.coords.dateToCoord(e), i.isRtl),
                isAxis: !1,
                date: e
            })))))
        }
        queryHit(e, t, r, n) {
            e = this.slatsRef.current.positionToHit(e);
            return e ? {
                dateProfile: this.props.dateProfile,
                dateSpan: e.dateSpan,
                rect: {
                    left: e.left,
                    right: e.right,
                    top: 0,
                    bottom: n
                },
                dayEl: e.dayEl,
                layer: 0
            } : null
        }
    }

    function Zc(e, t) {
        return [{
            span: e.slotCnt,
            minWidth: t || 1
        }]
    }
    Fe('.fc .fc-timeline-body{min-height:100%;position:relative;z-index:1}.fc .fc-timeline-slots{bottom:0;position:absolute;top:0;z-index:1}.fc .fc-timeline-slots>table{height:100%}.fc .fc-timeline-slot-minor{border-style:dotted}.fc .fc-timeline-slot-frame{align-items:center;display:flex;justify-content:center}.fc .fc-timeline-header-row-chrono .fc-timeline-slot-frame{justify-content:flex-start}.fc .fc-timeline-header-row:last-child .fc-timeline-slot-frame{overflow:hidden}.fc .fc-timeline-slot-cushion{padding:4px 5px;white-space:nowrap}.fc-direction-ltr .fc-timeline-slot{border-right:0!important}.fc-direction-rtl .fc-timeline-slot{border-left:0!important}.fc .fc-timeline-now-indicator-container{bottom:0;left:0;position:absolute;right:0;top:0;width:0;z-index:4}.fc .fc-timeline-now-indicator-arrow,.fc .fc-timeline-now-indicator-line{border-color:var(--fc-now-indicator-color);border-style:solid;pointer-events:none;position:absolute;top:0}.fc .fc-timeline-now-indicator-arrow{border-left-color:transparent;border-right-color:transparent;border-width:6px 5px 0;margin:0 -6px}.fc .fc-timeline-now-indicator-line{border-width:0 0 0 1px;bottom:0;margin:0 -1px}.fc .fc-timeline-events{position:relative;width:0;z-index:3}.fc .fc-timeline-event-harness,.fc .fc-timeline-more-link{position:absolute;top:0}.fc-timeline-event{z-index:1}.fc-timeline-event.fc-event-mirror{z-index:2}.fc-timeline-event{align-items:center;border-radius:0;display:flex;font-size:var(--fc-small-font-size);margin-bottom:1px;padding:2px 1px;position:relative}.fc-timeline-event .fc-event-main{flex-grow:1;flex-shrink:1;min-width:0}.fc-timeline-event .fc-event-time{font-weight:700}.fc-timeline-event .fc-event-time,.fc-timeline-event .fc-event-title{padding:0 2px;white-space:nowrap}.fc-direction-ltr .fc-timeline-event.fc-event-end,.fc-direction-ltr .fc-timeline-more-link{margin-right:1px}.fc-direction-rtl .fc-timeline-event.fc-event-end,.fc-direction-rtl .fc-timeline-more-link{margin-left:1px}.fc-timeline-overlap-disabled .fc-timeline-event{margin-bottom:0;padding-bottom:5px;padding-top:5px}.fc-timeline-event:not(.fc-event-end):after,.fc-timeline-event:not(.fc-event-start):before{border-color:transparent #000;border-style:solid;border-width:5px;content:"";flex-grow:0;flex-shrink:0;height:0;margin:0 1px;opacity:.5;width:0}.fc-direction-ltr .fc-timeline-event:not(.fc-event-start):before,.fc-direction-rtl .fc-timeline-event:not(.fc-event-end):after{border-left:0}.fc-direction-ltr .fc-timeline-event:not(.fc-event-end):after,.fc-direction-rtl .fc-timeline-event:not(.fc-event-start):before{border-right:0}.fc-timeline-more-link{background:var(--fc-more-link-bg-color);color:var(--fc-more-link-text-color);cursor:pointer;font-size:var(--fc-small-font-size);padding:1px}.fc-timeline-more-link-inner{display:inline-block;left:0;padding:2px;right:0}.fc .fc-timeline-bg{bottom:0;left:0;position:absolute;right:0;top:0;width:0;z-index:2}.fc .fc-timeline-bg .fc-non-business{z-index:1}.fc .fc-timeline-bg .fc-bg-event{z-index:2}.fc .fc-timeline-bg .fc-highlight{z-index:3}.fc .fc-timeline-bg-harness{bottom:0;position:absolute;top:0}');
    let Xc = C({
            name: "@fullcalendar/timeline",
            premiumReleaseDate: "2025-06-30",
            deps: [Zl],
            initialView: "timelineDay",
            views: {
                timeline: {
                    component: class extends a {
                        constructor() {
                            super(...arguments), this.buildTimelineDateProfile = f(Cc), this.scrollGridRef = {
                                current: null
                            }, this.state = {
                                slatCoords: null,
                                slotCushionMaxWidth: null
                            }, this.handleSlatCoords = e => {
                                this.setState({
                                    slatCoords: e
                                })
                            }, this.handleScrollLeftRequest = e => {
                                this.scrollGridRef.current.forceScrollLeft(0, e)
                            }, this.handleMaxCushionWidth = e => {
                                this.setState({
                                    slotCushionMaxWidth: Math.ceil(e)
                                })
                            }
                        }
                        render() {
                            let {
                                props: t,
                                state: r,
                                context: e
                            } = this, n = e.options, i = !t.forPrint && Ps(n), s = !t.forPrint && Ns(n), o = this.buildTimelineDateProfile(t.dateProfile, e.dateEnv, n, e.dateProfileGenerator), a = n.slotMinWidth, l = Zc(o, a || this.computeFallbackSlotMinWidth(o)), c = [{
                                type: "header",
                                key: "header",
                                isSticky: i,
                                chunks: [{
                                    key: "timeline",
                                    content: e => b(Wc, {
                                        dateProfile: t.dateProfile,
                                        clientWidth: e.clientWidth,
                                        clientHeight: e.clientHeight,
                                        tableMinWidth: e.tableMinWidth,
                                        tableColGroupNode: e.tableColGroupNode,
                                        tDateProfile: o,
                                        slatCoords: r.slatCoords,
                                        onMaxCushionWidth: a ? null : this.handleMaxCushionWidth
                                    })
                                }]
                            }, {
                                type: "body",
                                key: "body",
                                liquid: !0,
                                chunks: [{
                                    key: "timeline",
                                    content: e => b(Qc, Object.assign({}, t, {
                                        clientWidth: e.clientWidth,
                                        clientHeight: e.clientHeight,
                                        tableMinWidth: e.tableMinWidth,
                                        tableColGroupNode: e.tableColGroupNode,
                                        tDateProfile: o,
                                        onSlatCoords: this.handleSlatCoords,
                                        onScrollLeftRequest: this.handleScrollLeftRequest
                                    }))
                                }]
                            }];
                            return s && c.push({
                                type: "footer",
                                key: "footer",
                                isSticky: !0,
                                chunks: [{
                                    key: "timeline",
                                    content: Os
                                }]
                            }), b(Zr, {
                                elClasses: ["fc-timeline", !1 === n.eventOverlap ? "fc-timeline-overlap-disabled" : ""],
                                viewSpec: e.viewSpec
                            }, b(nc, {
                                ref: this.scrollGridRef,
                                liquid: !t.isHeightAuto && !t.forPrint,
                                forPrint: t.forPrint,
                                collapsibleWidth: !1,
                                colGroups: [{
                                    cols: l
                                }],
                                sections: c
                            }))
                        }
                        computeFallbackSlotMinWidth(e) {
                            return Math.max(30, (this.state.slotCushionMaxWidth || 0) / e.slotsPerLabel)
                        }
                    },
                    usesMinMaxTime: !0,
                    eventResizableFromStart: !0
                },
                timelineDay: {
                    type: "timeline",
                    duration: {
                        days: 1
                    }
                },
                timelineWeek: {
                    type: "timeline",
                    duration: {
                        weeks: 1
                    }
                },
                timelineMonth: {
                    type: "timeline",
                    duration: {
                        months: 1
                    }
                },
                timelineYear: {
                    type: "timeline",
                    duration: {
                        years: 1
                    }
                }
            }
        }),
        Jc = {
            id: String,
            parentId: String,
            children: r,
            title: String,
            businessHours: r,
            extendedProps: r,
            eventEditable: Boolean,
            eventStartEditable: Boolean,
            eventDurationEditable: Boolean,
            eventConstraint: r,
            eventOverlap: Boolean,
            eventAllow: r,
            eventClassNames: Cn,
            eventBackgroundColor: String,
            eventBorderColor: String,
            eventTextColor: String,
            eventColor: String
        };

    function Kc(e, t = "", r, n) {
        var {
            refined: e,
            extra: i
        } = Dr(e, Jc), s = {
            id: e.id || "_fc:" + c(),
            parentId: e.parentId || t,
            title: e.title || "",
            businessHours: e.businessHours ? Bn(e.businessHours, n) : null,
            ui: Rn({
                editable: e.eventEditable,
                startEditable: e.eventStartEditable,
                durationEditable: e.eventDurationEditable,
                constraint: e.eventConstraint,
                overlap: e.eventOverlap,
                allow: e.eventAllow,
                classNames: e.eventClassNames,
                backgroundColor: e.eventBackgroundColor,
                borderColor: e.eventBorderColor,
                textColor: e.eventTextColor,
                color: e.eventColor
            }, n),
            extendedProps: Object.assign(Object.assign({}, i), e.extendedProps)
        };
        if (Object.freeze(s.ui.classNames), Object.freeze(s.extendedProps), !r[s.id] && (r[s.id] = s, e.children))
            for (var o of e.children) Kc(o, s.id, r, n);
        return s
    }

    function $c(e) {
        return 0 === e.indexOf("_fc:") ? "" : e
    }
    class w {
        constructor(e, t) {
            this._context = e, this._resource = t
        }
        setProp(e, t) {
            var r = this._resource;
            this._context.dispatch({
                type: "SET_RESOURCE_PROP",
                resourceId: r.id,
                propName: e,
                propValue: t
            }), this.sync(r)
        }
        setExtendedProp(e, t) {
            var r = this._resource;
            this._context.dispatch({
                type: "SET_RESOURCE_EXTENDED_PROP",
                resourceId: r.id,
                propName: e,
                propValue: t
            }), this.sync(r)
        }
        sync(e) {
            let t = this._context,
                r = e.id;
            this._resource = t.getCurrentData().resourceStore[r], t.emitter.trigger("resourceChange", {
                oldResource: new w(t, e),
                resource: this,
                revert() {
                    t.dispatch({
                        type: "ADD_RESOURCE",
                        resourceHash: {
                            [r]: e
                        }
                    })
                }
            })
        }
        remove() {
            let e = this._context,
                t = this._resource,
                r = t.id;
            e.dispatch({
                type: "REMOVE_RESOURCE",
                resourceId: r
            }), e.emitter.trigger("resourceRemove", {
                resource: this,
                revert() {
                    e.dispatch({
                        type: "ADD_RESOURCE",
                        resourceHash: {
                            [r]: t
                        }
                    })
                }
            })
        }
        getParent() {
            var e = this._context,
                t = this._resource.parentId;
            return t ? new w(e, e.getCurrentData().resourceStore[t]) : null
        }
        getChildren() {
            var e, t = this._resource.id,
                r = this._context,
                n = r.getCurrentData().resourceStore,
                i = [];
            for (e in n) n[e].parentId === t && i.push(new w(r, n[e]));
            return i
        }
        getEvents() {
            var e, t = this._resource.id,
                r = this._context,
                {
                    defs: n,
                    instances: i
                } = r.getCurrentData().eventStore,
                s = [];
            for (e in i) {
                var o = i[e],
                    a = n[o.defId]; - 1 !== a.resourceIds.indexOf(t) && s.push(new P(r, a, o))
            }
            return s
        }
        get id() {
            return $c(this._resource.id)
        }
        get title() {
            return this._resource.title
        }
        get eventConstraint() {
            return this._resource.ui.constraints[0] || null
        }
        get eventOverlap() {
            return this._resource.ui.overlap
        }
        get eventAllow() {
            return this._resource.ui.allows[0] || null
        }
        get eventBackgroundColor() {
            return this._resource.ui.backgroundColor
        }
        get eventBorderColor() {
            return this._resource.ui.borderColor
        }
        get eventTextColor() {
            return this._resource.ui.textColor
        }
        get eventClassNames() {
            return this._resource.ui.classNames
        }
        get extendedProps() {
            return this._resource.extendedProps
        }
        toPlainObject(e = {}) {
            var t = this._resource,
                r = t.ui,
                n = this.id,
                i = {};
            return n && (i.id = n), t.title && (i.title = t.title), e.collapseEventColor && r.backgroundColor && r.backgroundColor === r.borderColor ? i.eventColor = r.backgroundColor : (r.backgroundColor && (i.eventBackgroundColor = r.backgroundColor), r.borderColor && (i.eventBorderColor = r.borderColor)), r.textColor && (i.eventTextColor = r.textColor), r.classNames.length && (i.eventClassNames = r.classNames), Object.keys(t.extendedProps).length && (e.collapseExtendedProps ? Object.assign(i, t.extendedProps) : i.extendedProps = t.extendedProps), i
        }
        toJSON() {
            return this.toPlainObject()
        }
    }
    class ed extends Ri {
        getKeyInfo(e) {
            return Object.assign({
                "": {}
            }, e.resourceStore)
        }
        getKeysForDateSpan(e) {
            return [e.resourceId || ""]
        }
        getKeysForEventDef(e) {
            e = e.resourceIds;
            return e.length ? e : [""]
        }
    }
    let td = vt("id,title");

    function rd(e) {
        return {
            resource: new w(e.context, e.resource)
        }
    }
    class nd extends s {
        constructor() {
            super(...arguments), this.refineRenderProps = $t(sd)
        }
        render() {
            let r = this.props;
            return b(u.Consumer, null, e => {
                var t = e.options,
                    e = this.refineRenderProps({
                        resource: r.resource,
                        date: r.date,
                        context: e
                    });
                return b(g, {
                    elRef: r.elRef,
                    elTag: r.elTag,
                    elAttrs: Object.assign(Object.assign({}, r.elAttrs), {
                        "data-resource-id": r.resource.id,
                        "data-date": r.date ? Zt(r.date) : void 0
                    }),
                    elClasses: r.elClasses,
                    elStyle: r.elStyle,
                    renderProps: e,
                    generatorName: "resourceLabelContent",
                    customGenerator: t.resourceLabelContent,
                    defaultGenerator: id,
                    classNameGenerator: t.resourceLabelClassNames,
                    didMount: t.resourceLabelDidMount,
                    willUnmount: t.resourceLabelWillUnmount
                }, r.children)
            })
        }
    }

    function id(e) {
        return e.resource.title || e.resource.id
    }

    function sd(e) {
        return {
            resource: new w(e.context, e.resource),
            date: e.date ? e.context.dateEnv.toDate(e.date) : null,
            view: e.context.viewApi
        }
    }
    class od extends s {
        render() {
            let t = this.props;
            return b(nd, {
                elTag: "th",
                elClasses: ["fc-col-header-cell", "fc-resource"],
                elAttrs: {
                    role: "columnheader",
                    colSpan: t.colSpan
                },
                resource: t.resource,
                date: t.date
            }, e => b("div", {
                className: "fc-scrollgrid-sync-inner"
            }, b(e, {
                elTag: "span",
                elClasses: ["fc-col-header-cell-cushion", t.isSticky && "fc-sticky"]
            })))
        }
    }
    class ad extends s {
        constructor() {
            super(...arguments), this.buildDateFormat = f(ld)
        }
        render() {
            let {
                props: r,
                context: n
            } = this, i = this.buildDateFormat(n.options.dayHeaderFormat, r.datesRepDistinctDays, r.dates.length);
            return b(m, {
                unit: "day"
            }, (e, t) => 1 === r.dates.length ? this.renderResourceRow(r.resources, r.dates[0]) : n.options.datesAboveResources ? this.renderDayAndResourceRows(r.dates, i, t, r.resources) : this.renderResourceAndDayRows(r.resources, r.dates, i, t))
        }
        renderResourceRow(e, t) {
            e = e.map(e => b(od, {
                key: e.id,
                resource: e,
                colSpan: 1,
                date: t
            }));
            return this.buildTr(e, "resources")
        }
        renderDayAndResourceRows(e, t, r, n) {
            var i, s = [],
                o = [];
            for (i of e) {
                s.push(this.renderDateCell(i, t, r, n.length, null, !0));
                for (var a of n) o.push(b(od, {
                    key: a.id + ":" + i.toISOString(),
                    resource: a,
                    colSpan: 1,
                    date: i
                }))
            }
            return b(A, null, this.buildTr(s, "day"), this.buildTr(o, "resources"))
        }
        renderResourceAndDayRows(e, t, r, n) {
            var i, s = [],
                o = [];
            for (i of e) {
                s.push(b(od, {
                    key: i.id,
                    resource: i,
                    colSpan: t.length,
                    isSticky: !0
                }));
                for (var a of t) o.push(this.renderDateCell(a, r, n, 1, i))
            }
            return b(A, null, this.buildTr(s, "resources"), this.buildTr(o, "day"))
        }
        renderDateCell(e, t, r, n, i, s) {
            var o = this.props,
                a = i ? ":" + i.id : "",
                l = i ? {
                    resource: new w(this.context, i)
                } : {},
                i = i ? {
                    "data-resource-id": i.id
                } : {};
            return o.datesRepDistinctDays ? b(os, {
                key: e.toISOString() + a,
                date: e,
                dateProfile: o.dateProfile,
                todayRange: r,
                colCnt: o.dates.length * o.resources.length,
                dayHeaderFormat: t,
                colSpan: n,
                isSticky: s,
                extraRenderProps: l,
                extraDataAttrs: i
            }) : b(ls, {
                key: e.getUTCDay() + a,
                dow: e.getUTCDay(),
                dayHeaderFormat: t,
                colSpan: n,
                isSticky: s,
                extraRenderProps: l,
                extraDataAttrs: i
            })
        }
        buildTr(e, t) {
            var r = this.props.renderIntro;
            return e.length || (e = [b("td", {
                key: 0
            }, "")]), b("tr", {
                key: t,
                role: "row"
            }, r && r(t), e)
        }
    }

    function ld(e, t, r) {
        return e || ns(t, r)
    }
    class cd {
        constructor(t) {
            var r = {},
                n = [];
            for (let e = 0; e < t.length; e += 1) {
                var i = t[e].id;
                n.push(i), r[i] = e
            }
            this.ids = n, this.indicesById = r, this.length = t.length
        }
    }
    class dd {
        constructor(e, t, r) {
            this.dayTableModel = e, this.resources = t, this.context = r, this.resourceIndex = new cd(t), this.rowCnt = e.rowCnt, this.colCnt = e.colCnt * t.length, this.cells = this.buildCells()
        }
        buildCells() {
            var {
                rowCnt: e,
                dayTableModel: n,
                resources: i
            } = this, t = [];
            for (let r = 0; r < e; r += 1) {
                var s = [];
                for (let t = 0; t < n.colCnt; t += 1)
                    for (let e = 0; e < i.length; e += 1) {
                        var o = i[e],
                            a = {
                                resource: new w(this.context, o)
                            },
                            l = {
                                "data-resource-id": o.id
                            },
                            c = ["fc-resource"],
                            d = {
                                resourceId: o.id
                            },
                            u = n.cells[r][t].date;
                        s[this.computeCol(t, e)] = {
                            key: o.id + ":" + u.toISOString(),
                            date: u,
                            extraRenderProps: a,
                            extraDataAttrs: l,
                            extraClassNames: c,
                            extraDateSpan: d
                        }
                    }
                t.push(s)
            }
            return t
        }
    }
    class ud extends dd {
        computeCol(e, t) {
            return t * this.dayTableModel.colCnt + e
        }
        computeColRanges(e, t, r) {
            return [{
                firstCol: this.computeCol(e, r),
                lastCol: this.computeCol(t, r),
                isStart: !0,
                isEnd: !0
            }]
        }
    }
    class hd extends dd {
        computeCol(e, t) {
            return e * this.resources.length + t
        }
        computeColRanges(t, r, n) {
            var i = [];
            for (let e = t; e <= r; e += 1) {
                var s = this.computeCol(e, n);
                i.push({
                    firstCol: s,
                    lastCol: s,
                    isStart: e === t,
                    isEnd: e === r
                })
            }
            return i
        }
    }
    let fd = [];
    class gd {
        constructor() {
            this.joinDateSelection = f(this.joinSegs), this.joinBusinessHours = f(this.joinSegs), this.joinFgEvents = f(this.joinSegs), this.joinBgEvents = f(this.joinSegs), this.joinEventDrags = f(this.joinInteractions), this.joinEventResizes = f(this.joinInteractions)
        }
        joinProps(e, t) {
            let r = [],
                n = [],
                i = [],
                s = [],
                o = [],
                a = [],
                l = "",
                c = t.resourceIndex.ids.concat([""]);
            for (var d of c) {
                var u = e[d];
                r.push(u.dateSelectionSegs), n.push(d ? u.businessHourSegs : fd), i.push(d ? u.fgEventSegs : fd), s.push(u.bgEventSegs), o.push(u.eventDrag), a.push(u.eventResize), l = l || u.eventSelection
            }
            return {
                dateSelectionSegs: this.joinDateSelection(t, ...r),
                businessHourSegs: this.joinBusinessHours(t, ...n),
                fgEventSegs: this.joinFgEvents(t, ...i),
                bgEventSegs: this.joinBgEvents(t, ...s),
                eventDrag: this.joinEventDrags(t, ...o),
                eventResize: this.joinEventResizes(t, ...a),
                eventSelection: l
            }
        }
        joinSegs(t, ...r) {
            var n = t.resources.length,
                i = [];
            for (let e = 0; e < n; e += 1) {
                for (var s of r[e]) i.push(...this.transformSeg(s, t, e));
                for (var o of r[n]) i.push(...this.transformSeg(o, t, e))
            }
            return i
        }
        expandSegs(t, r) {
            var n = t.resources.length,
                i = [];
            for (let e = 0; e < n; e += 1)
                for (var s of r) i.push(...this.transformSeg(s, t, e));
            return i
        }
        joinInteractions(t, ...r) {
            let n = t.resources.length,
                i = {},
                s = [],
                o = !1,
                a = !1;
            for (let e = 0; e < n; e += 1) {
                var l = r[e];
                if (l) {
                    o = !0;
                    for (var c of l.segs) s.push(...this.transformSeg(c, t, e));
                    Object.assign(i, l.affectedInstances), a = a || l.isEvent
                }
                if (r[n])
                    for (var d of r[n].segs) s.push(...this.transformSeg(d, t, e))
            }
            return o ? {
                affectedInstances: i,
                segs: s,
                isEvent: a
            } : null
        }
    }
    class pd extends Ri {
        getKeyInfo(e) {
            let t = e.resourceDayTableModel,
                r = O(t.resourceIndex.indicesById, e => t.resources[e]);
            return r[""] = {}, r
        }
        getKeysForDateSpan(e) {
            return [e.resourceId || ""]
        }
        getKeysForEventDef(e) {
            e = e.resourceIds;
            return e.length ? e : [""]
        }
    }

    function md(e, t) {
        return vd(e, [], t, !1, {}, !0).map(e => e.resource)
    }

    function vd(a, e, t, r, n, i) {
        var s = [];
        return function t(r, n, i, s, o, a, l) {
            for (let e = 0; e < r.length; e += 1) {
                var c, d, u, h = r[e],
                    f = h.group;
                f ? i ? (u = n.length, d = s.length, t(h.children, n, i, s.concat(0), o, a, l), u < n.length && (((c = n[u]).rowSpans = c.rowSpans.slice())[d] = n.length - u)) : (d = null != a[c = f.spec.field + ":" + f.value] ? a[c] : l, n.push({
                    id: c,
                    group: f,
                    isExpanded: d
                }), d && t(h.children, n, i, s, o + 1, a, l)) : h.resource && (f = null != a[u = h.resource.id] ? a[u] : l, n.push({
                    id: u,
                    rowSpans: s,
                    depth: o,
                    isExpanded: f,
                    hasChildren: Boolean(h.children.length),
                    resource: h.resource,
                    resourceFields: h.resourceFields
                }), f) && t(h.children, n, i, s, o + 1, a, l)
            }
        }(((e, t, r) => {
            var n, i = ((e, t) => {
                    var r, n, i = {};
                    for (r in e) {
                        var s = e[r];
                        i[r] = {
                            resource: s,
                            resourceFields: bd(s),
                            children: []
                        }
                    }
                    for (n in e) {
                        var o = e[n];
                        o.parentId && (o = i[o.parentId]) && yd(i[n], o.children, t)
                    }
                    return i
                })(a, r),
                s = [];
            for (n in i) {
                var o = i[n];
                o.resource.parentId || function e(t, r, n, i, s, o) {
                    n.length && (-1 === s || i <= s) ? e(t, ((e, r, n) => {
                        let i, s, o = e.resourceFields[n.field];
                        if (n.order)
                            for (s = 0; s < r.length; s += 1) {
                                let t = r[s];
                                if (t.group) {
                                    let e = bt(o, t.group.value) * n.order;
                                    if (0 == e) {
                                        i = t;
                                        break
                                    }
                                    if (e < 0) break
                                }
                            } else
                                for (s = 0; s < r.length; s += 1) {
                                    let e = r[s];
                                    if (e.group && o === e.group.value) {
                                        i = e;
                                        break
                                    }
                                }
                        return i || (i = {
                            group: {
                                value: o,
                                spec: n
                            },
                            children: []
                        }, r.splice(s, 0, i)), i
                    })(t, r, n[0]).children, n.slice(1), i + 1, s, o) : yd(t, r, o)
                }(o, s, t, 0, e, r)
            }
            return s
        })(r ? -1 : 1, e, t), s, r, [], 0, n, i), s
    }

    function yd(e, t, r) {
        let n;
        for (n = 0; n < t.length && !(0 < yt(t[n].resourceFields, e.resourceFields, r)); n += 1);
        t.splice(n, 0, e)
    }

    function bd(e) {
        e = Object.assign(Object.assign(Object.assign({}, e.extendedProps), e.ui), e);
        return delete e.ui, delete e.extendedProps, e
    }

    function Sd(e, t) {
        let r = e.resourceEditable;
        return r = null == r && (e = e.sourceId && t.getCurrentData().eventSources[e.sourceId], null == (r = e ? e.extendedProps.resourceEditable : r)) && null == (r = t.options.eventResourceEditable) ? t.options.editable : r
    }

    function Ed(e, t, n, i) {
        if (t) {
            let r = ((e, t) => {
                var r, n, i = {};
                for (r in e)
                    for (n of t[e[r].defId].resourceIds) i[n] = !0;
                return i
            })((t = n.instances, s = i, xr(t, e => en(e.range, s))), n.defs);
            return Object.assign(r, ((e, t) => {
                var r, n, i = {};
                for (r in e)
                    for (;
                        (n = t[r]) && (r = n.parentId);) i[r] = !0;
                return i
            })(r, e)), xr(e, (e, t) => r[t])
        }
        var s;
        return e
    }

    function Cd(e) {
        return O(e, e => e.ui)
    }

    function wd(e, o, a) {
        return O(e, (e, t) => {
            if (t) {
                var r, n = e,
                    t = o[t],
                    i = a,
                    s = [];
                for (r of t.resourceIds) i[r] && s.unshift(i[r]);
                return s.unshift(n), An(s)
            }
            return e
        })
    }
    let Dd = [];

    function Rd(e) {
        Dd.push(e)
    }

    function Ad(e) {
        return Dd[e]
    }
    let xd = {
        id: String,
        resources: r,
        url: String,
        method: String,
        startParam: String,
        endParam: String,
        timeZoneParam: String,
        extraParams: r
    };

    function Td(e) {
        let t;
        if ("string" == typeof e ? t = {
                url: e
            } : "function" == typeof e || Array.isArray(e) ? t = {
                resources: e
            } : "object" == typeof e && e && (t = e), t) {
            var r, {
                refined: n,
                extra: i
            } = Dr(t, xd);
            for (r in i) console.warn(`Unknown resource prop '${r}'`);
            i = (t => {
                var r = Dd;
                for (let e = r.length - 1; 0 <= e; --e) {
                    var n = r[e].parseMeta(t);
                    if (n) return {
                        meta: n,
                        sourceDefId: e
                    }
                }
                return null
            })(n);
            if (i) return {
                _raw: e,
                sourceId: c(),
                sourceDefId: i.sourceDefId,
                meta: i.meta,
                publicId: n.id || "",
                isFetching: !1,
                latestFetchId: "",
                fetchRange: null
            }
        }
        return null
    }

    function Md(e, t, r, n) {
        return e ? kd(Td(e), r ? t : null, n) : null
    }

    function kd(e, t, r) {
        let n = Ad(e.sourceDefId),
            i = c();
        return n.fetch({
            resourceSource: e,
            range: t,
            context: r
        }, e => {
            r.dispatch({
                type: "RECEIVE_RESOURCES",
                fetchId: i,
                fetchRange: t,
                rawResources: e.rawResources
            })
        }, e => {
            r.dispatch({
                type: "RECEIVE_RESOURCE_ERROR",
                fetchId: i,
                fetchRange: t,
                error: e
            })
        }), Object.assign(Object.assign({}, e), {
            isFetching: !0,
            latestFetchId: i
        })
    }
    var _d = {
        resourceId: String,
        resourceIds: r,
        resourceEditable: Boolean
    };

    function Id(e, t) {
        return Object.assign(Object.assign({}, t), {
            constraints: (n = e, t.constraints.map(e => {
                var t = e.defs;
                if (t)
                    for (var r in t) {
                        r = t[r].resourceIds;
                        if (r.length && -1 === r.indexOf(n)) return !1
                    }
                return e
            }))
        });
        var n
    }
    vi.prototype.addResource = function(e, t = !0) {
        let r, n, i = this.getCurrentData();
        e instanceof w ? (n = e._resource, r = {
            [n.id]: n
        }) : (r = {}, n = Kc(e, "", r, i)), this.dispatch({
            type: "ADD_RESOURCE",
            resourceHash: r
        }), t && this.trigger("_scrollRequest", {
            resourceId: n.id
        });
        e = new w(i, n);
        return i.emitter.trigger("resourceAdd", {
            resource: e,
            revert: () => {
                this.dispatch({
                    type: "REMOVE_RESOURCE",
                    resourceId: n.id
                })
            }
        }), e
    }, vi.prototype.getResourceById = function(e) {
        e = String(e);
        var t = this.getCurrentData();
        if (t.resourceStore) {
            e = t.resourceStore[e];
            if (e) return new w(t, e)
        }
        return null
    }, vi.prototype.getResources = function() {
        var e = this.getCurrentData(),
            t = e.resourceStore,
            r = [];
        if (t)
            for (var n in t) r.push(new w(e, t[n]));
        return r
    }, vi.prototype.getTopLevelResources = function() {
        var e = this.getCurrentData(),
            t = e.resourceStore,
            r = [];
        if (t)
            for (var n in t) t[n].parentId || r.push(new w(e, t[n]));
        return r
    }, vi.prototype.refetchResources = function() {
        this.dispatch({
            type: "REFETCH_RESOURCES"
        })
    };
    var Od = {
            initialResources: r,
            resources: r,
            eventResourceEditable: Boolean,
            refetchResourcesOnNavigate: Boolean,
            resourceOrder: vt,
            filterResourcesWithEvents: Boolean,
            resourceGroupField: String,
            resourceAreaWidth: r,
            resourceAreaColumns: r,
            resourcesInitiallyExpanded: Boolean,
            datesAboveResources: Boolean,
            needsResourceData: Boolean,
            resourceAreaHeaderClassNames: r,
            resourceAreaHeaderContent: r,
            resourceAreaHeaderDidMount: r,
            resourceAreaHeaderWillUnmount: r,
            resourceGroupLabelClassNames: r,
            resourceGroupLabelContent: r,
            resourceGroupLabelDidMount: r,
            resourceGroupLabelWillUnmount: r,
            resourceLabelClassNames: r,
            resourceLabelContent: r,
            resourceLabelDidMount: r,
            resourceLabelWillUnmount: r,
            resourceLaneClassNames: r,
            resourceLaneContent: r,
            resourceLaneDidMount: r,
            resourceLaneWillUnmount: r,
            resourceGroupLaneClassNames: r,
            resourceGroupLaneContent: r,
            resourceGroupLaneDidMount: r,
            resourceGroupLaneWillUnmount: r
        },
        Pd = {
            resourcesSet: r,
            resourceAdd: r,
            resourceChange: r,
            resourceRemove: r
        },
        _d = (P.prototype.getResources = function() {
            let t = this._context.calendarApi;
            return this._def.resourceIds.map(e => t.getResourceById(e))
        }, P.prototype.setResources = function(e) {
            var t, r = [];
            for (t of e) {
                let e = null;
                "string" == typeof t ? e = t : "number" == typeof t ? e = String(t) : t instanceof w ? e = t.id : console.warn("unknown resource type: " + t), e && r.push(e)
            }
            this.mutate({
                standardProps: {
                    resourceIds: r
                }
            })
        }, Rd({
            ignoreRange: !0,
            parseMeta: e => Array.isArray(e.resources) ? e.resources : null,
            fetch(e, t) {
                t({
                    rawResources: e.resourceSource.meta
                })
            }
        }), Rd({
            parseMeta: e => "function" == typeof e.resources ? e.resources : null,
            fetch(e, t, r) {
                var n = e.context.dateEnv,
                    i = e.resourceSource.meta,
                    e = e.range ? {
                        start: n.toDate(e.range.start),
                        end: n.toDate(e.range.end),
                        startStr: n.formatIso(e.range.start),
                        endStr: n.formatIso(e.range.end),
                        timeZone: n.timeZone
                    } : {};
                li(i.bind(null, e), e => t({
                    rawResources: e
                }), r)
            }
        }), Rd({
            parseMeta: e => e.url ? {
                url: e.url,
                method: (e.method || "GET").toUpperCase(),
                extraParams: e.extraParams
            } : null,
            fetch(c, r, e) {
                var t = c.resourceSource.meta,
                    n = ((e, t) => {
                        let r, n, i, s, {
                                dateEnv: o,
                                options: a
                            } = c.context,
                            l = {};
                        return t && (null == (r = e.startParam) && (r = a.startParam), null == (n = e.endParam) && (n = a.endParam), null == (i = e.timeZoneParam) && (i = a.timeZoneParam), l[r] = o.formatIso(t.start), l[n] = o.formatIso(t.end), "local" !== o.timeZone) && (l[i] = o.timeZone), s = "function" == typeof e.extraParams ? e.extraParams() : e.extraParams || {}, Object.assign(l, s), l
                    })(t, c.range);
                di(t.method, t.url, n).then(([e, t]) => {
                    r({
                        rawResources: e,
                        response: t
                    })
                }, e)
            }
        }), C({
            name: "@fullcalendar/resource",
            premiumReleaseDate: "2025-06-30",
            deps: [Zl],
            reducers: [function(e, t, r) {
                var n = ((e, t, r) => {
                    var n, i, s, o, {
                        options: a,
                        dateProfile: l
                    } = r;
                    if (!e || !t) return Md(a.initialResources || a.resources, l.activeRange, a.refetchResourcesOnNavigate, r);
                    switch (t.type) {
                        case "RESET_RESOURCE_SOURCE":
                            return Md(t.resourceSourceInput, l.activeRange, a.refetchResourcesOnNavigate, r);
                        case "PREV":
                        case "NEXT":
                        case "CHANGE_DATE":
                        case "CHANGE_VIEW_TYPE":
                            return n = e, i = l.activeRange, s = a.refetchResourcesOnNavigate, o = r, !s || Boolean(Ad(n.sourceDefId).ignoreRange) || n.fetchRange && $r(n.fetchRange, i) ? n : kd(n, i, o);
                        case "RECEIVE_RESOURCES":
                        case "RECEIVE_RESOURCE_ERROR":
                            return s = e, n = t.fetchId, i = t.fetchRange, n === s.latestFetchId ? Object.assign(Object.assign({}, s), {
                                isFetching: !1,
                                fetchRange: i
                            }) : s;
                        case "REFETCH_RESOURCES":
                            return kd(e, l.activeRange, r);
                        default:
                            return e
                    }
                })(e && e.resourceSource, t, r);
                return {
                    resourceSource: n,
                    resourceStore: ((e, t, r, n) => {
                        if (!e || !t) return {};
                        switch (t.type) {
                            case "RECEIVE_RESOURCES":
                                var i = t.rawResources,
                                    s = n;
                                if (r.latestFetchId !== t.fetchId) return e;
                                var o, a = {};
                                for (o of i) Kc(o, "", a, s);
                                return a;
                            case "ADD_RESOURCE":
                                return i = t.resourceHash, Object.assign(Object.assign({}, e), i);
                            case "REMOVE_RESOURCE":
                                var l, c = t.resourceId,
                                    d = Object.assign({}, e);
                                for (l in delete d[c], d) d[l].parentId === c && (d[l] = Object.assign(Object.assign({}, d[l]), {
                                    parentId: ""
                                }));
                                return d;
                            case "SET_RESOURCE_PROP":
                                return u = e, h = t.resourceId, f = t.propName, g = t.propValue, (p = u[h]) ? Object.assign(Object.assign({}, u), {
                                    [h]: Object.assign(Object.assign({}, p), {
                                        [f]: g
                                    })
                                }) : u;
                            case "SET_RESOURCE_EXTENDED_PROP":
                                return h = e, p = t.resourceId, f = t.propName, g = t.propValue, (u = h[p]) ? Object.assign(Object.assign({}, h), {
                                    [p]: Object.assign(Object.assign({}, u), {
                                        extendedProps: Object.assign(Object.assign({}, u.extendedProps), {
                                            [f]: g
                                        })
                                    })
                                }) : h;
                            default:
                                return e
                        }
                        var u, h, f, g, p
                    })(e && e.resourceStore, t, n, r),
                    resourceEntityExpansions: (n = e && e.resourceEntityExpansions, r = t, n && r ? "SET_RESOURCE_ENTITY_EXPANDED" !== r.type ? n : Object.assign(Object.assign({}, n), {
                        [r.id]: r.isExpanded
                    }) : {})
                }
            }],
            isLoadingFuncs: [e => e.resourceSource && e.resourceSource.isFetching],
            eventRefiners: _d,
            eventDefMemberAdders: [function(e) {
                return {
                    resourceIds: (e.resourceIds || []).map(e => String(e)).concat(e.resourceId ? [e.resourceId] : []),
                    resourceEditable: e.resourceEditable
                }
            }],
            isDraggableTransformers: [function(e, t, r, n) {
                if (!e) {
                    var i = n.getCurrentData();
                    if (i.viewSpecs[i.currentViewType].optionDefaults.needsResourceData && Sd(t, n)) return !0
                }
                return e
            }],
            eventDragMutationMassagers: [function(e, t, r) {
                t = t.dateSpan.resourceId, r = r.dateSpan.resourceId;
                t && r && t !== r && (e.resourceMutation = {
                    matchResourceId: t,
                    setResourceId: r
                })
            }],
            eventDefMutationAppliers: [function(e, t, r) {
                var n, t = t.resourceMutation;
                t && Sd(e, r) && -1 !== (r = e.resourceIds.indexOf(t.matchResourceId)) && ((n = e.resourceIds.slice()).splice(r, 1), -1 === n.indexOf(t.setResourceId) && n.push(t.setResourceId), e.resourceIds = n)
            }],
            dateSelectionTransformers: [function(e, t) {
                e = e.dateSpan.resourceId, t = t.dateSpan.resourceId;
                return e && t ? {
                    resourceId: e
                } : null
            }],
            datePointTransforms: [function(e, t) {
                return e.resourceId ? {
                    resource: t.calendarApi.getResourceById(e.resourceId)
                } : {}
            }],
            dateSpanTransforms: [function(e, t) {
                return e.resourceId ? {
                    resource: t.calendarApi.getResourceById(e.resourceId)
                } : {}
            }],
            viewPropsTransformers: [class {
                constructor() {
                    this.filterResources = f(Ed)
                }
                transform(e, t) {
                    return t.viewSpec.optionDefaults.needsResourceData ? {
                        resourceStore: this.filterResources(t.resourceStore, t.options.filterResourcesWithEvents, t.eventStore, t.dateProfile.activeRange),
                        resourceEntityExpansions: t.resourceEntityExpansions
                    } : null
                }
            }, class {
                constructor() {
                    this.buildResourceEventUis = f(Cd, h), this.injectResourceEventUis = f(wd)
                }
                transform(e, t) {
                    return t.viewSpec.optionDefaults.needsResourceData ? null : {
                        eventUiBases: this.injectResourceEventUis(e.eventUiBases, e.eventStore.defs, this.buildResourceEventUis(t.resourceStore))
                    }
                }
            }],
            isPropsValid: function(e, t) {
                var r, n = (new ed).splitProps(Object.assign(Object.assign({}, e), {
                    resourceStore: t.getCurrentData().resourceStore
                }));
                for (r in n) {
                    let e = n[r];
                    if (!ys(e = r && n[""] ? Object.assign(Object.assign({}, e), {
                            eventStore: Sn(n[""].eventStore, e.eventStore),
                            eventUiBases: Object.assign(Object.assign({}, n[""].eventUiBases), e.eventUiBases)
                        }) : e, t, {
                            resourceId: r
                        }, Id.bind(null, r))) return !1
                }
                return !0
            },
            externalDefTransforms: [function(e) {
                return e.resourceId ? {
                    resourceId: e.resourceId
                } : {}
            }],
            eventDropTransformers: [function(e, t) {
                e = e.resourceMutation;
                return e ? (t = t.calendarApi, {
                    oldResource: t.getResourceById(e.matchResourceId),
                    newResource: t.getResourceById(e.setResourceId)
                }) : {
                    oldResource: null,
                    newResource: null
                }
            }],
            optionChangeHandlers: {
                resources: function(e, t) {
                    t.getCurrentData().resourceSource._raw !== e && t.dispatch({
                        type: "RESET_RESOURCE_SOURCE",
                        resourceSourceInput: e
                    })
                }
            },
            optionRefiners: Od,
            listenerRefiners: Pd,
            propSetHandlers: {
                resourceStore: function(e, t) {
                    var r = t.emitter;
                    r.hasHandlers("resourcesSet") && r.trigger("resourcesSet", ((e, t) => {
                        var r, n = [];
                        for (r in e) n.push(new w(t, e[r]));
                        return n
                    })(e, t))
                }
            }
        }));
    class Nd extends gd {
        transformSeg(t, e, r) {
            return e.computeColRanges(t.firstCol, t.lastCol, r).map(e => Object.assign(Object.assign(Object.assign({}, t), e), {
                isStart: t.isStart && e.isStart,
                isEnd: t.isEnd && e.isEnd
            }))
        }
    }
    class Hd extends a {
        constructor() {
            super(...arguments), this.splitter = new pd, this.slicers = {}, this.joiner = new Nd, this.tableRef = {
                current: null
            }, this.isHitComboAllowed = (e, t) => 1 === this.props.resourceDayTableModel.dayTableModel.colCnt || e.dateSpan.resourceId === t.dateSpan.resourceId
        }
        render() {
            let {
                props: e,
                context: r
            } = this, {
                resourceDayTableModel: n,
                nextDayThreshold: i,
                dateProfile: s
            } = e, o = this.splitter.splitProps(e);
            this.slicers = O(o, (e, t) => this.slicers[t] || new qa);
            var t = O(this.slicers, (e, t) => e.sliceProps(o[t], s, i, r, n.dayTableModel));
            return b(Va, Object.assign({
                forPrint: e.forPrint,
                ref: this.tableRef
            }, this.joiner.joinProps(t, n), {
                cells: n.cells,
                dateProfile: s,
                colGroupNode: e.colGroupNode,
                tableMinWidth: e.tableMinWidth,
                renderRowIntro: e.renderRowIntro,
                dayMaxEvents: e.dayMaxEvents,
                dayMaxEventRows: e.dayMaxEventRows,
                showWeekNumbers: e.showWeekNumbers,
                expandRows: e.expandRows,
                headerAlignElRef: e.headerAlignElRef,
                clientWidth: e.clientWidth,
                clientHeight: e.clientHeight,
                isHitComboAllowed: this.isHitComboAllowed
            }))
        }
    }

    function Wd(e, t, r, n, i) {
        e = Qa(e, t);
        return new(n ? hd : ud)(e, r, i)
    }
    Od = C({
        name: "@fullcalendar/resource-daygrid",
        premiumReleaseDate: "2025-06-30",
        deps: [Zl, _d, ba],
        initialView: "resourceDayGridDay",
        views: {
            resourceDayGrid: {
                type: "dayGrid",
                component: class extends Ca {
                    constructor() {
                        super(...arguments), this.flattenResources = f(md), this.buildResourceDayTableModel = f(Wd), this.headerRef = {
                            current: null
                        }, this.tableRef = {
                            current: null
                        }
                    }
                    render() {
                        let {
                            props: t,
                            context: e
                        } = this, r = e.options, n = r.resourceOrder || td, i = this.flattenResources(t.resourceStore, n), s = this.buildResourceDayTableModel(t.dateProfile, e.dateProfileGenerator, i, r.datesAboveResources, e), o = r.dayHeaders && b(ad, {
                            ref: this.headerRef,
                            resources: i,
                            dateProfile: t.dateProfile,
                            dates: s.dayTableModel.headerDates,
                            datesRepDistinctDays: !0
                        }), a = e => b(Hd, {
                            ref: this.tableRef,
                            dateProfile: t.dateProfile,
                            resourceDayTableModel: s,
                            businessHours: t.businessHours,
                            eventStore: t.eventStore,
                            eventUiBases: t.eventUiBases,
                            dateSelection: t.dateSelection,
                            eventSelection: t.eventSelection,
                            eventDrag: t.eventDrag,
                            eventResize: t.eventResize,
                            nextDayThreshold: r.nextDayThreshold,
                            tableMinWidth: e.tableMinWidth,
                            colGroupNode: e.tableColGroupNode,
                            dayMaxEvents: r.dayMaxEvents,
                            dayMaxEventRows: r.dayMaxEventRows,
                            showWeekNumbers: r.weekNumbers,
                            expandRows: !t.isHeightAuto,
                            headerAlignElRef: this.headerElRef,
                            clientWidth: e.clientWidth,
                            clientHeight: e.clientHeight,
                            forPrint: t.forPrint
                        });
                        return r.dayMinWidth ? this.renderHScrollLayout(o, a, s.colCnt, r.dayMinWidth) : this.renderSimpleLayout(o, a)
                    }
                },
                needsResourceData: !0
            },
            resourceDayGridDay: {
                type: "resourceDayGrid",
                duration: {
                    days: 1
                }
            },
            resourceDayGridWeek: {
                type: "resourceDayGrid",
                duration: {
                    weeks: 1
                }
            },
            resourceDayGridMonth: {
                type: "resourceDayGrid",
                duration: {
                    months: 1
                },
                fixedWeekCount: !0
            }
        }
    });
    class Bd extends gd {
        transformSeg(e, t, r) {
            return [Object.assign(Object.assign({}, e), {
                col: t.computeCol(e.col, r)
            })]
        }
    }
    class jd extends a {
        constructor() {
            super(...arguments), this.buildDayRanges = f(Tl), this.splitter = new pd, this.slicers = {}, this.joiner = new Bd, this.timeColsRef = {
                current: null
            }, this.isHitComboAllowed = (e, t) => 1 === this.dayRanges.length || e.dateSpan.resourceId === t.dateSpan.resourceId
        }
        render() {
            let {
                props: r,
                context: n
            } = this, {
                dateEnv: e,
                options: i
            } = n, {
                dateProfile: s,
                resourceDayTableModel: o
            } = r, a = this.dayRanges = this.buildDayRanges(o.dayTableModel, s, e), l = this.splitter.splitProps(r), c = (this.slicers = O(l, (e, t) => this.slicers[t] || new Al), O(this.slicers, (e, t) => e.sliceProps(l[t], s, null, n, a)));
            return b(m, {
                unit: i.nowIndicator ? "minute" : "day"
            }, (e, t) => b(Dl, Object.assign({
                ref: this.timeColsRef
            }, this.joiner.joinProps(c, o), {
                dateProfile: s,
                axis: r.axis,
                slotDuration: r.slotDuration,
                slatMetas: r.slatMetas,
                cells: o.cells[0],
                tableColGroupNode: r.tableColGroupNode,
                tableMinWidth: r.tableMinWidth,
                clientWidth: r.clientWidth,
                clientHeight: r.clientHeight,
                expandRows: r.expandRows,
                nowDate: e,
                nowIndicatorSegs: i.nowIndicator && this.buildNowIndicatorSegs(e),
                todayRange: t,
                onScrollTopRequest: r.onScrollTopRequest,
                forPrint: r.forPrint,
                onSlatCoords: r.onSlatCoords,
                isHitComboAllowed: this.isHitComboAllowed
            })))
        }
        buildNowIndicatorSegs(e) {
            e = this.slicers[""].sliceNowDate(e, this.props.dateProfile, this.context.options.nextDayThreshold, this.context, this.dayRanges);
            return this.joiner.expandSegs(this.props.resourceDayTableModel, e)
        }
    }

    function Ld(e, t, r, n, i) {
        e = _l(e, t);
        return new(n ? hd : ud)(e, r, i)
    }

    function zd({
        depth: t,
        hasChildren: e,
        isExpanded: r,
        onExpanderClick: n
    }) {
        var i = [];
        for (let e = 0; e < t; e += 1) i.push(b("span", {
            className: "fc-icon"
        }));
        var s = ["fc-icon"];
        return e && s.push(r ? "fc-icon-minus-square" : "fc-icon-plus-square"), i.push(b("span", {
            className: "fc-datagrid-expander" + (e ? "" : " fc-datagrid-expander-placeholder"),
            onClick: n
        }, b("span", {
            className: s.join(" ")
        }))), b(A, {}, ...i)
    }
    Pd = C({
        name: "@fullcalendar/resource-timegrid",
        premiumReleaseDate: "2025-06-30",
        deps: [Zl, _d, Il],
        initialView: "resourceTimeGridDay",
        views: {
            resourceTimeGrid: {
                type: "timeGrid",
                component: class extends nl {
                    constructor() {
                        super(...arguments), this.flattenResources = f(md), this.buildResourceTimeColsModel = f(Ld), this.buildSlatMetas = f(kl)
                    }
                    render() {
                        let {
                            props: t,
                            context: e
                        } = this, {
                            options: r,
                            dateEnv: n
                        } = e, i = t.dateProfile, s = this.allDaySplitter.splitProps(t), o = r.resourceOrder || td, a = this.flattenResources(t.resourceStore, o), l = this.buildResourceTimeColsModel(i, e.dateProfileGenerator, a, r.datesAboveResources, e), c = this.buildSlatMetas(i.slotMinTime, i.slotMaxTime, r.slotLabelInterval, r.slotDuration, n), d = r.dayMinWidth, u = !d, h = d, f = r.dayHeaders && b(ad, {
                            resources: a,
                            dates: l.dayTableModel.headerDates,
                            dateProfile: i,
                            datesRepDistinctDays: !0,
                            renderIntro: u ? this.renderHeadAxis : null
                        }), g = !1 !== r.allDaySlot && (e => b(Hd, Object.assign({}, s.allDay, {
                            dateProfile: i,
                            resourceDayTableModel: l,
                            nextDayThreshold: r.nextDayThreshold,
                            tableMinWidth: e.tableMinWidth,
                            colGroupNode: e.tableColGroupNode,
                            renderRowIntro: u ? this.renderTableRowAxis : null,
                            showWeekNumbers: !1,
                            expandRows: !1,
                            headerAlignElRef: this.headerElRef,
                            clientWidth: e.clientWidth,
                            clientHeight: e.clientHeight,
                            forPrint: t.forPrint
                        }, this.getAllDayMaxEventProps()))), p = e => b(jd, Object.assign({}, s.timed, {
                            dateProfile: i,
                            axis: u,
                            slotDuration: r.slotDuration,
                            slatMetas: c,
                            resourceDayTableModel: l,
                            tableColGroupNode: e.tableColGroupNode,
                            tableMinWidth: e.tableMinWidth,
                            clientWidth: e.clientWidth,
                            clientHeight: e.clientHeight,
                            onSlatCoords: this.handleSlatCoords,
                            expandRows: e.expandRows,
                            forPrint: t.forPrint,
                            onScrollTopRequest: this.handleScrollTopRequest
                        }));
                        return h ? this.renderHScrollLayout(f, g, p, l.colCnt, d, c, this.state.slatCoords) : this.renderSimpleLayout(f, g, p)
                    }
                },
                needsResourceData: !0
            },
            resourceTimeGridDay: {
                type: "resourceTimeGrid",
                duration: {
                    days: 1
                }
            },
            resourceTimeGridWeek: {
                type: "resourceTimeGrid",
                duration: {
                    weeks: 1
                }
            }
        }
    });
    class Ud extends s {
        constructor() {
            super(...arguments), this.refineRenderProps = $t(Fd), this.onExpanderClick = e => {
                var t = this.props;
                t.hasChildren && this.context.dispatch({
                    type: "SET_RESOURCE_ENTITY_EXPANDED",
                    id: t.resource.id,
                    isExpanded: !t.isExpanded
                })
            }
        }
        render() {
            let {
                props: t,
                context: e
            } = this, r = t.colSpec, n = this.refineRenderProps({
                resource: t.resource,
                fieldValue: t.fieldValue,
                context: e
            });
            return b(g, {
                elTag: "td",
                elClasses: ["fc-datagrid-cell", "fc-resource"],
                elAttrs: {
                    role: "gridcell",
                    "data-resource-id": t.resource.id
                },
                renderProps: n,
                generatorName: r.isMain ? "resourceLabelContent" : void 0,
                customGenerator: r.cellContent,
                defaultGenerator: Gd,
                classNameGenerator: r.cellClassNames,
                didMount: r.cellDidMount,
                willUnmount: r.cellWillUnmount
            }, e => b("div", {
                className: "fc-datagrid-cell-frame",
                style: {
                    height: t.innerHeight
                }
            }, b("div", {
                className: "fc-datagrid-cell-cushion fc-scrollgrid-sync-inner"
            }, r.isMain && b(zd, {
                depth: t.depth,
                hasChildren: t.hasChildren,
                isExpanded: t.isExpanded,
                onExpanderClick: this.onExpanderClick
            }), b(e, {
                elTag: "span",
                elClasses: ["fc-datagrid-cell-main"]
            }))))
        }
    }

    function Gd(e) {
        return e.fieldValue || b(A, null, "")
    }

    function Fd(e) {
        return {
            resource: new w(e.context, e.resource),
            fieldValue: e.fieldValue,
            view: e.context.viewApi
        }
    }
    class Vd extends s {
        render() {
            var {
                props: e,
                context: t
            } = this, r = e.colSpec, t = {
                groupValue: e.fieldValue,
                view: t.viewApi
            };
            return b(g, {
                elTag: "td",
                elClasses: ["fc-datagrid-cell", "fc-resource-group"],
                elAttrs: {
                    role: "gridcell",
                    rowSpan: e.rowSpan
                },
                renderProps: t,
                generatorName: "resourceGroupLabelContent",
                customGenerator: r.cellContent,
                defaultGenerator: qd,
                classNameGenerator: r.cellClassNames,
                didMount: r.cellDidMount,
                willUnmount: r.cellWillUnmount
            }, e => b("div", {
                className: "fc-datagrid-cell-frame fc-datagrid-cell-frame-liquid"
            }, b(e, {
                elTag: "div",
                elClasses: ["fc-datagrid-cell-cushion", "fc-sticky"]
            })))
        }
    }

    function qd(e) {
        return e.groupValue || b(A, null, "")
    }
    class Yd extends s {
        render() {
            let i = this.props,
                {
                    resource: s,
                    rowSpans: o,
                    depth: a
                } = i,
                l = bd(s);
            return b("tr", {
                role: "row"
            }, i.colSpecs.map((e, t) => {
                let r = o[t];
                if (0 === r) return null;
                null == r && (r = 1);
                var n = e.field ? l[e.field] : s.title || $c(s.id);
                return 1 < r ? b(Vd, {
                    key: t,
                    colSpec: e,
                    fieldValue: n,
                    rowSpan: r
                }) : b(Ud, {
                    key: t,
                    colSpec: e,
                    resource: s,
                    fieldValue: n,
                    depth: a,
                    hasChildren: i.hasChildren,
                    isExpanded: i.isExpanded,
                    innerHeight: i.innerHeight
                })
            }))
        }
    }
    Yd.addPropsEquality({
        rowSpans: d
    });
    class Qd extends s {
        constructor() {
            super(...arguments), this.innerInnerRef = {
                current: null
            }, this.onExpanderClick = () => {
                var e = this.props;
                this.context.dispatch({
                    type: "SET_RESOURCE_ENTITY_EXPANDED",
                    id: e.id,
                    isExpanded: !e.isExpanded
                })
            }
        }
        render() {
            let {
                props: t,
                context: e
            } = this, r = {
                groupValue: t.group.value,
                view: e.viewApi
            }, n = t.group.spec;
            return b("tr", {
                role: "row"
            }, b(g, {
                elTag: "th",
                elClasses: ["fc-datagrid-cell", "fc-resource-group", e.theme.getClass("tableCellShaded")],
                elAttrs: {
                    role: "columnheader",
                    scope: "colgroup",
                    colSpan: t.spreadsheetColCnt
                },
                renderProps: r,
                generatorName: "resourceGroupLabelContent",
                customGenerator: n.labelContent,
                defaultGenerator: Zd,
                classNameGenerator: n.labelClassNames,
                didMount: n.labelDidMount,
                willUnmount: n.labelWillUnmount
            }, e => b("div", {
                className: "fc-datagrid-cell-frame",
                style: {
                    height: t.innerHeight
                }
            }, b("div", {
                className: "fc-datagrid-cell-cushion fc-scrollgrid-sync-inner",
                ref: this.innerInnerRef
            }, b(zd, {
                depth: 0,
                hasChildren: !0,
                isExpanded: t.isExpanded,
                onExpanderClick: this.onExpanderClick
            }), b(e, {
                elTag: "span",
                elClasses: ["fc-datagrid-cell-main"]
            })))))
        }
    }

    function Zd(e) {
        return e.groupValue || b(A, null, "")
    }
    Qd.addPropsEquality({
        group: function(e, t) {
            return e.spec === t.spec && e.value === t.value
        }
    });
    class Xd extends s {
        constructor() {
            super(...arguments), this.resizerElRefs = new y(this._handleColResizerEl.bind(this)), this.colDraggings = {}
        }
        render() {
            let {
                colSpecs: e,
                superHeaderRendering: r,
                rowInnerHeights: n
            } = this.props, i = {
                view: this.context.viewApi
            }, s = [];
            if (n = n.slice(), r) {
                let t = n.shift();
                s.push(b("tr", {
                    key: "row-super",
                    role: "row"
                }, b(g, {
                    elTag: "th",
                    elClasses: ["fc-datagrid-cell", "fc-datagrid-cell-super"],
                    elAttrs: {
                        role: "columnheader",
                        scope: "colgroup",
                        colSpan: e.length
                    },
                    renderProps: i,
                    generatorName: "resourceAreaHeaderContent",
                    customGenerator: r.headerContent,
                    defaultGenerator: r.headerDefault,
                    classNameGenerator: r.headerClassNames,
                    didMount: r.headerDidMount,
                    willUnmount: r.headerWillUnmount
                }, e => b("div", {
                    className: "fc-datagrid-cell-frame",
                    style: {
                        height: t
                    }
                }, b(e, {
                    elTag: "div",
                    elClasses: ["fc-datagrid-cell-cushion", "fc-scrollgrid-sync-inner"]
                })))))
            }
            let o = n.shift();
            return s.push(b("tr", {
                key: "row",
                role: "row"
            }, e.map((t, r) => {
                let n = r === e.length - 1;
                return b(g, {
                    key: r,
                    elTag: "th",
                    elClasses: ["fc-datagrid-cell"],
                    elAttrs: {
                        role: "columnheader"
                    },
                    renderProps: i,
                    generatorName: "resourceAreaHeaderContent",
                    customGenerator: t.headerContent,
                    defaultGenerator: t.headerDefault,
                    classNameGenerator: t.headerClassNames,
                    didMount: t.headerDidMount,
                    willUnmount: t.headerWillUnmount
                }, e => b("div", {
                    className: "fc-datagrid-cell-frame",
                    style: {
                        height: o
                    }
                }, b("div", {
                    className: "fc-datagrid-cell-cushion fc-scrollgrid-sync-inner"
                }, t.isMain && b("span", {
                    className: "fc-datagrid-expander fc-datagrid-expander-placeholder"
                }, b("span", {
                    className: "fc-icon"
                })), b(e, {
                    elTag: "span",
                    elClasses: ["fc-datagrid-cell-main"]
                })), !n && b("div", {
                    className: "fc-datagrid-cell-resizer",
                    ref: this.resizerElRefs.createRef(r)
                })))
            }))), b(A, null, s)
        }
        _handleColResizerEl(e, t) {
            var r = this.colDraggings;
            e ? (e = this.initColResizing(e, parseInt(t, 10))) && (r[t] = e) : (e = r[t]) && (e.destroy(), delete r[t])
        }
        initColResizing(n, i) {
            let {
                pluginHooks: e,
                isRtl: s
            } = this.context, o = this.props.onColWidthChange, a = e.elementDraggingImpl;
            if (a) {
                let t, r, e = new a(n);
                return e.emitter.on("dragstart", () => {
                    var e = Je(l(n, "tr"), "th");
                    r = e.map(e => e.getBoundingClientRect().width), t = r[i]
                }), e.emitter.on("dragmove", e => {
                    r[i] = Math.max(t + e.deltaX * (s ? -1 : 1), 20), o && o(r.slice())
                }), e.setAutoScrollEnabled(!1), e
            }
            return null
        }
    }
    class Jd extends s {
        constructor() {
            super(...arguments), this.refineRenderProps = $t(rd), this.handleHeightChange = (e, t) => {
                this.props.onHeightChange && this.props.onHeightChange(l(e, "tr"), t)
            }
        }
        render() {
            let {
                props: t,
                context: e
            } = this, r = e.options, n = this.refineRenderProps({
                resource: t.resource,
                context: e
            });
            return b("tr", {
                ref: t.elRef
            }, b(g, {
                elTag: "td",
                elClasses: ["fc-timeline-lane", "fc-resource"],
                elAttrs: {
                    "data-resource-id": t.resource.id
                },
                renderProps: n,
                generatorName: "resourceLaneContent",
                customGenerator: r.resourceLaneContent,
                classNameGenerator: r.resourceLaneClassNames,
                didMount: r.resourceLaneDidMount,
                willUnmount: r.resourceLaneWillUnmount
            }, e => b("div", {
                className: "fc-timeline-lane-frame",
                style: {
                    height: t.innerHeight
                }
            }, b(e, {
                elTag: "div",
                elClasses: ["fc-timeline-lane-misc"]
            }), b(Yc, {
                dateProfile: t.dateProfile,
                tDateProfile: t.tDateProfile,
                nowDate: t.nowDate,
                todayRange: t.todayRange,
                nextDayThreshold: t.nextDayThreshold,
                businessHours: t.businessHours,
                eventStore: t.eventStore,
                eventUiBases: t.eventUiBases,
                dateSelection: t.dateSelection,
                eventSelection: t.eventSelection,
                eventDrag: t.eventDrag,
                eventResize: t.eventResize,
                timelineCoords: t.timelineCoords,
                onHeightChange: this.handleHeightChange,
                resourceId: t.resource.id
            }))))
        }
    }
    class Kd extends s {
        render() {
            let {
                props: t,
                context: e
            } = this, r = t.renderHooks, n = {
                groupValue: t.groupValue,
                view: e.viewApi
            };
            return b("tr", {
                ref: t.elRef
            }, b(g, {
                elTag: "td",
                elRef: t.elRef,
                elClasses: ["fc-timeline-lane", "fc-resource-group", e.theme.getClass("tableCellShaded")],
                renderProps: n,
                generatorName: "resourceGroupLaneContent",
                customGenerator: r.laneContent,
                classNameGenerator: r.laneClassNames,
                didMount: r.laneDidMount,
                willUnmount: r.laneWillUnmount
            }, e => b(e, {
                elTag: "div",
                elStyle: {
                    height: t.innerHeight
                }
            })))
        }
    }
    class $d extends s {
        render() {
            let {
                props: n,
                context: i
            } = this, {
                rowElRefs: s,
                innerHeights: o
            } = n;
            return b("tbody", null, n.rowNodes.map((e, t) => {
                var r;
                return e.group ? b(Kd, {
                    key: e.id,
                    elRef: s.createRef(e.id),
                    groupValue: e.group.value,
                    renderHooks: e.group.spec,
                    innerHeight: o[t] || ""
                }) : e.resource ? (r = e.resource, b(Jd, Object.assign({
                    key: e.id,
                    elRef: s.createRef(e.id)
                }, n.splitProps[r.id], {
                    resource: r,
                    dateProfile: n.dateProfile,
                    tDateProfile: n.tDateProfile,
                    nowDate: n.nowDate,
                    todayRange: n.todayRange,
                    nextDayThreshold: i.options.nextDayThreshold,
                    businessHours: r.businessHours || n.fallbackBusinessHours,
                    innerHeight: o[t] || "",
                    timelineCoords: n.slatCoords,
                    onHeightChange: n.onRowHeightChange
                }))) : null
            }))
        }
    }
    class eu extends s {
        constructor() {
            super(...arguments), this.rootElRef = {
                current: null
            }, this.rowElRefs = new y
        }
        render() {
            var {
                props: e,
                context: t
            } = this;
            return b("table", {
                ref: this.rootElRef,
                "aria-hidden": !0,
                className: "fc-scrollgrid-sync-table " + t.theme.getClass("table"),
                style: {
                    minWidth: e.tableMinWidth,
                    width: e.clientWidth,
                    height: e.minHeight
                }
            }, b($d, {
                rowElRefs: this.rowElRefs,
                rowNodes: e.rowNodes,
                dateProfile: e.dateProfile,
                tDateProfile: e.tDateProfile,
                nowDate: e.nowDate,
                todayRange: e.todayRange,
                splitProps: e.splitProps,
                fallbackBusinessHours: e.fallbackBusinessHours,
                slatCoords: e.slatCoords,
                innerHeights: e.innerHeights,
                onRowHeightChange: e.onRowHeightChange
            }))
        }
        componentDidMount() {
            this.updateCoords()
        }
        componentDidUpdate() {
            this.updateCoords()
        }
        componentWillUnmount() {
            this.props.onRowCoords && this.props.onRowCoords(null)
        }
        updateCoords() {
            var t, e = this.props;
            e.onRowCoords && null !== e.clientWidth && this.props.onRowCoords(new Ui(this.rootElRef.current, (t = this.rowElRefs.currentMap, e.rowNodes.map(e => t[e.id])), !1, !0))
        }
    }
    class tu extends a {
        constructor() {
            super(...arguments), this.computeHasResourceBusinessHours = f(ru), this.resourceSplitter = new ed, this.bgSlicer = new Gc, this.slatsRef = {
                current: null
            }, this.state = {
                slatCoords: null
            }, this.handleEl = e => {
                e ? this.context.registerInteractiveComponent(this, {
                    el: e
                }) : this.context.unregisterInteractiveComponent(this)
            }, this.handleSlatCoords = e => {
                this.setState({
                    slatCoords: e
                }), this.props.onSlatCoords && this.props.onSlatCoords(e)
            }, this.handleRowCoords = e => {
                this.rowCoords = e, this.props.onRowCoords && this.props.onRowCoords(e)
            }
        }
        render() {
            let {
                props: r,
                state: e,
                context: n
            } = this, {
                dateProfile: i,
                tDateProfile: s
            } = r, t = Ot(s.slotDuration).unit, o = this.computeHasResourceBusinessHours(r.rowNodes), a = this.resourceSplitter.splitProps(r), l = a[""], c = this.bgSlicer.sliceProps(l, i, s.isTimeScale ? null : r.nextDayThreshold, n, i, n.dateProfileGenerator, s, n.dateEnv), d = e.slatCoords && e.slatCoords.dateProfile === r.dateProfile ? e.slatCoords : null;
            return b("div", {
                ref: this.handleEl,
                className: ["fc-timeline-body", r.expandRows ? "fc-timeline-body-expandrows" : ""].join(" "),
                style: {
                    minWidth: r.tableMinWidth
                }
            }, b(m, {
                unit: t
            }, (e, t) => b(A, null, b(Lc, {
                ref: this.slatsRef,
                dateProfile: i,
                tDateProfile: s,
                nowDate: e,
                todayRange: t,
                clientWidth: r.clientWidth,
                tableColGroupNode: r.tableColGroupNode,
                tableMinWidth: r.tableMinWidth,
                onCoords: this.handleSlatCoords,
                onScrollLeftRequest: r.onScrollLeftRequest
            }), b(Uc, {
                businessHourSegs: o ? null : c.businessHourSegs,
                bgEventSegs: c.bgEventSegs,
                timelineCoords: d,
                eventResizeSegs: c.eventResize ? c.eventResize.segs : [],
                dateSelectionSegs: c.dateSelectionSegs,
                nowDate: e,
                todayRange: t
            }), b(eu, {
                rowNodes: r.rowNodes,
                dateProfile: i,
                tDateProfile: r.tDateProfile,
                nowDate: e,
                todayRange: t,
                splitProps: a,
                fallbackBusinessHours: o ? r.businessHours : null,
                clientWidth: r.clientWidth,
                minHeight: r.expandRows ? r.clientHeight : "",
                tableMinWidth: r.tableMinWidth,
                innerHeights: r.rowInnerHeights,
                slatCoords: d,
                onRowCoords: this.handleRowCoords,
                onRowHeightChange: r.onRowHeightChange
            }), n.options.nowIndicator && d && d.isDateInRange(e) && b("div", {
                className: "fc-timeline-now-indicator-container"
            }, b(Ls, {
                elClasses: ["fc-timeline-now-indicator-line"],
                elStyle: Nc(d.dateToCoord(e), n.isRtl),
                isAxis: !1,
                date: e
            })))))
        }
        queryHit(e, t) {
            var r = this.rowCoords,
                t = r.topToIndex(t);
            if (null != t) {
                var n = this.props.rowNodes[t].resource;
                if (n) {
                    e = this.slatsRef.current.positionToHit(e);
                    if (e) return {
                        dateProfile: this.props.dateProfile,
                        dateSpan: {
                            range: e.dateSpan.range,
                            allDay: e.dateSpan.allDay,
                            resourceId: n.id
                        },
                        rect: {
                            left: e.left,
                            right: e.right,
                            top: r.tops[t],
                            bottom: r.bottoms[t]
                        },
                        dayEl: e.dayEl,
                        layer: 0
                    }
                }
            }
            return null
        }
    }

    function ru(e) {
        for (var t of e) {
            t = t.resource;
            if (t && t.businessHours) return !0
        }
        return !1
    }
    class nu extends s {
        constructor() {
            super(...arguments), this.scrollGridRef = {
                current: null
            }, this.timeBodyScrollerElRef = {
                current: null
            }, this.spreadsheetHeaderChunkElRef = {
                current: null
            }, this.rootElRef = {
                current: null
            }, this.ensureScrollGridResizeId = 0, this.state = {
                resourceAreaWidthOverride: null
            }, this.ensureScrollGridResize = () => {
                this.ensureScrollGridResizeId && clearTimeout(this.ensureScrollGridResizeId), this.ensureScrollGridResizeId = setTimeout(() => {
                    this.scrollGridRef.current.handleSizing(!1)
                }, N.SCROLLGRID_RESIZE_INTERVAL + 1)
            }
        }
        render() {
            var {
                props: e,
                state: t,
                context: r
            } = this, n = r.options, i = !e.forPrint && Ps(n), s = !e.forPrint && Ns(n), i = [{
                type: "header",
                key: "header",
                syncRowHeights: !0,
                isSticky: i,
                chunks: [{
                    key: "datagrid",
                    elRef: this.spreadsheetHeaderChunkElRef,
                    tableClassName: "fc-datagrid-header",
                    rowContent: e.spreadsheetHeaderRows
                }, {
                    key: "divider",
                    outerContent: b("td", {
                        role: "presentation",
                        className: "fc-resource-timeline-divider " + r.theme.getClass("tableCellShaded")
                    })
                }, {
                    key: "timeline",
                    content: e.timeHeaderContent
                }]
            }, {
                type: "body",
                key: "body",
                syncRowHeights: !0,
                liquid: !0,
                expandRows: Boolean(n.expandRows),
                chunks: [{
                    key: "datagrid",
                    tableClassName: "fc-datagrid-body",
                    rowContent: e.spreadsheetBodyRows
                }, {
                    key: "divider",
                    outerContent: b("td", {
                        role: "presentation",
                        className: "fc-resource-timeline-divider " + r.theme.getClass("tableCellShaded")
                    })
                }, {
                    key: "timeline",
                    scrollerElRef: this.timeBodyScrollerElRef,
                    content: e.timeBodyContent
                }]
            }], s = (s && i.push({
                type: "footer",
                key: "footer",
                isSticky: !0,
                chunks: [{
                    key: "datagrid",
                    content: Os
                }, {
                    key: "divider",
                    outerContent: b("td", {
                        role: "presentation",
                        className: "fc-resource-timeline-divider " + r.theme.getClass("tableCellShaded")
                    })
                }, {
                    key: "timeline",
                    content: Os
                }]
            }), null != t.resourceAreaWidthOverride ? t.resourceAreaWidthOverride : n.resourceAreaWidth);
            return b(nc, {
                ref: this.scrollGridRef,
                elRef: this.rootElRef,
                liquid: !e.isHeightAuto && !e.forPrint,
                forPrint: e.forPrint,
                collapsibleWidth: !1,
                colGroups: [{
                    cols: e.spreadsheetCols,
                    width: s
                }, {
                    cols: []
                }, {
                    cols: e.timeCols
                }],
                sections: i
            })
        }
        forceTimeScroll(e) {
            this.scrollGridRef.current.forceScrollLeft(2, e)
        }
        forceResourceScroll(e) {
            this.scrollGridRef.current.forceScrollTop(1, e)
        }
        getResourceScroll() {
            return this.timeBodyScrollerElRef.current.scrollTop
        }
        componentDidMount() {
            this.initSpreadsheetResizing()
        }
        componentWillUnmount() {
            this.destroySpreadsheetResizing()
        }
        initSpreadsheetResizing() {
            let {
                isRtl: i,
                pluginHooks: e
            } = this.context, s = e.elementDraggingImpl, o = this.spreadsheetHeaderChunkElRef.current;
            if (s) {
                let t, r, e = this.rootElRef.current,
                    n = this.spreadsheetResizerDragging = new s(e, ".fc-resource-timeline-divider");
                n.emitter.on("dragstart", () => {
                    t = o.getBoundingClientRect().width, r = e.getBoundingClientRect().width
                }), n.emitter.on("dragmove", e => {
                    e = t + e.deltaX * (i ? -1 : 1), e = Math.max(e, 30);
                    e = Math.min(e, r - 30), this.setState({
                        resourceAreaWidthOverride: e
                    }, this.ensureScrollGridResize)
                }), n.setAutoScrollEnabled(!1)
            }
        }
        destroySpreadsheetResizing() {
            this.spreadsheetResizerDragging && this.spreadsheetResizerDragging.destroy()
        }
    }
    class iu extends s {
        constructor(e, t) {
            super(e, t), this.processColOptions = f(au), this.buildTimelineDateProfile = f(Cc), this.hasNesting = f(ou), this.buildRowNodes = f(vd), this.layoutRef = {
                current: null
            }, this.rowNodes = [], this.renderedRowNodes = [], this.buildRowIndex = f(su), this.handleSlatCoords = e => {
                this.setState({
                    slatCoords: e
                })
            }, this.handleRowCoords = e => {
                this.rowCoords = e, this.scrollResponder.update(!1)
            }, this.handleMaxCushionWidth = e => {
                this.setState({
                    slotCushionMaxWidth: Math.ceil(e)
                })
            }, this.handleScrollLeftRequest = e => {
                this.layoutRef.current.forceTimeScroll(e)
            }, this.handleScrollRequest = e => {
                var t = this.rowCoords,
                    r = this.layoutRef.current,
                    n = e.rowId || e.resourceId;
                return t ? (n && null != (n = this.buildRowIndex(this.renderedRowNodes)[n]) && (e = null != e.fromBottom ? t.bottoms[n] - e.fromBottom : t.tops[n], r.forceResourceScroll(e)), !0) : null
            }, this.handleColWidthChange = e => {
                this.setState({
                    spreadsheetColWidths: e
                })
            }, this.state = {
                resourceAreaWidth: t.options.resourceAreaWidth,
                spreadsheetColWidths: []
            }
        }
        render() {
            let {
                props: t,
                state: r,
                context: n
            } = this, {
                options: e,
                viewSpec: i
            } = n, {
                superHeaderRendering: s,
                groupSpecs: o,
                orderSpecs: a,
                isVGrouping: l,
                colSpecs: c
            } = this.processColOptions(n.options), d = this.buildTimelineDateProfile(t.dateProfile, n.dateEnv, e, n.dateProfileGenerator), u = this.rowNodes = this.buildRowNodes(t.resourceStore, o, a, l, t.resourceEntityExpansions, e.resourcesInitiallyExpanded), h = e.slotMinWidth, f = Zc(d, h || this.computeFallbackSlotMinWidth(d));
            return b(Zr, {
                elClasses: ["fc-resource-timeline", !this.hasNesting(u) && "fc-resource-timeline-flat", "fc-timeline", !1 === e.eventOverlap ? "fc-timeline-overlap-disabled" : "fc-timeline-overlap-enabled"],
                viewSpec: i
            }, b(nu, {
                ref: this.layoutRef,
                forPrint: t.forPrint,
                isHeightAuto: t.isHeightAuto,
                spreadsheetCols: (g = c, p = r.spreadsheetColWidths, m = "", g.map((e, t) => ({
                    className: e.isMain ? "fc-main-col" : "",
                    width: p[t] || e.width || m
                }))),
                spreadsheetHeaderRows: e => b(Xd, {
                    superHeaderRendering: s,
                    colSpecs: c,
                    onColWidthChange: this.handleColWidthChange,
                    rowInnerHeights: e.rowSyncHeights
                }),
                spreadsheetBodyRows: e => b(A, null, this.renderSpreadsheetRows(u, c, e.rowSyncHeights)),
                timeCols: f,
                timeHeaderContent: e => b(Wc, {
                    clientWidth: e.clientWidth,
                    clientHeight: e.clientHeight,
                    tableMinWidth: e.tableMinWidth,
                    tableColGroupNode: e.tableColGroupNode,
                    dateProfile: t.dateProfile,
                    tDateProfile: d,
                    slatCoords: r.slatCoords,
                    rowInnerHeights: e.rowSyncHeights,
                    onMaxCushionWidth: h ? null : this.handleMaxCushionWidth
                }),
                timeBodyContent: e => b(tu, {
                    dateProfile: t.dateProfile,
                    clientWidth: e.clientWidth,
                    clientHeight: e.clientHeight,
                    tableMinWidth: e.tableMinWidth,
                    tableColGroupNode: e.tableColGroupNode,
                    expandRows: e.expandRows,
                    tDateProfile: d,
                    rowNodes: u,
                    businessHours: t.businessHours,
                    dateSelection: t.dateSelection,
                    eventStore: t.eventStore,
                    eventUiBases: t.eventUiBases,
                    eventSelection: t.eventSelection,
                    eventDrag: t.eventDrag,
                    eventResize: t.eventResize,
                    resourceStore: t.resourceStore,
                    nextDayThreshold: n.options.nextDayThreshold,
                    rowInnerHeights: e.rowSyncHeights,
                    onSlatCoords: this.handleSlatCoords,
                    onRowCoords: this.handleRowCoords,
                    onScrollLeftRequest: this.handleScrollLeftRequest,
                    onRowHeightChange: e.reportRowHeightChange
                })
            }));
            var g, p, m
        }
        renderSpreadsheetRows(e, r, n) {
            return e.map((e, t) => e.group ? b(Qd, {
                key: e.id,
                id: e.id,
                spreadsheetColCnt: r.length,
                isExpanded: e.isExpanded,
                group: e.group,
                innerHeight: n[t] || ""
            }) : e.resource ? b(Yd, {
                key: e.id,
                colSpecs: r,
                rowSpans: e.rowSpans,
                depth: e.depth,
                isExpanded: e.isExpanded,
                hasChildren: e.hasChildren,
                resource: e.resource,
                innerHeight: n[t] || ""
            }) : null)
        }
        componentDidMount() {
            this.renderedRowNodes = this.rowNodes, this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest)
        }
        getSnapshotBeforeUpdate() {
            return this.props.forPrint ? {} : {
                resourceScroll: this.queryResourceScroll()
            }
        }
        componentDidUpdate(e, t, r) {
            this.renderedRowNodes = this.rowNodes, this.scrollResponder.update(e.dateProfile !== this.props.dateProfile), r.resourceScroll && this.handleScrollRequest(r.resourceScroll)
        }
        componentWillUnmount() {
            this.scrollResponder.detach()
        }
        computeFallbackSlotMinWidth(e) {
            return Math.max(30, (this.state.slotCushionMaxWidth || 0) / e.slotsPerLabel)
        }
        queryResourceScroll() {
            var {
                rowCoords: e,
                renderedRowNodes: t
            } = this;
            if (e) {
                var r = this.layoutRef.current,
                    n = e.bottoms,
                    i = r.getResourceScroll(),
                    s = {};
                for (let e = 0; e < n.length; e += 1) {
                    var o = t[e],
                        a = n[e] - i;
                    if (0 < a) {
                        s.rowId = o.id, s.fromBottom = a;
                        break
                    }
                }
                return s
            }
            return null
        }
    }

    function su(t) {
        var r = {};
        for (let e = 0; e < t.length; e += 1) r[t[e].id] = e;
        return r
    }

    function ou(e) {
        for (var t of e) {
            if (t.group) return !0;
            if (t.resource && t.hasChildren) return !0
        }
        return !1
    }

    function au(e) {
        let t = e.resourceAreaColumns || [],
            r = null,
            n = (t.length ? e.resourceAreaHeaderContent && (r = {
                headerClassNames: e.resourceAreaHeaderClassNames,
                headerContent: e.resourceAreaHeaderContent,
                headerDidMount: e.resourceAreaHeaderDidMount,
                headerWillUnmount: e.resourceAreaHeaderWillUnmount
            }) : t.push({
                headerClassNames: e.resourceAreaHeaderClassNames,
                headerContent: e.resourceAreaHeaderContent,
                headerDefault: () => "Resources",
                headerDidMount: e.resourceAreaHeaderDidMount,
                headerWillUnmount: e.resourceAreaHeaderWillUnmount
            }), []),
            i = [],
            s = [],
            o = !1;
        for (var a of t) a.group ? i.push(Object.assign(Object.assign({}, a), {
            cellClassNames: a.cellClassNames || e.resourceGroupLabelClassNames,
            cellContent: a.cellContent || e.resourceGroupLabelContent,
            cellDidMount: a.cellDidMount || e.resourceGroupLabelDidMount,
            cellWillUnmount: a.cellWillUnmount || e.resourceGroupLaneWillUnmount
        })) : n.push(a);
        var l, c = n[0],
            c = (c.isMain = !0, c.cellClassNames = c.cellClassNames || e.resourceLabelClassNames, c.cellContent = c.cellContent || e.resourceLabelContent, c.cellDidMount = c.cellDidMount || e.resourceLabelDidMount, c.cellWillUnmount = c.cellWillUnmount || e.resourceLabelWillUnmount, i.length ? (s = i, o = !0) : (c = e.resourceGroupField) && s.push({
                field: c,
                labelClassNames: e.resourceGroupLabelClassNames,
                labelContent: e.resourceGroupLabelContent,
                labelDidMount: e.resourceGroupLabelDidMount,
                labelWillUnmount: e.resourceGroupLabelWillUnmount,
                laneClassNames: e.resourceGroupLaneClassNames,
                laneContent: e.resourceGroupLaneContent,
                laneDidMount: e.resourceGroupLaneDidMount,
                laneWillUnmount: e.resourceGroupLaneWillUnmount
            }), e.resourceOrder || td),
            d = [];
        for (l of c) {
            let e = !1;
            for (var u of s)
                if (u.field === l.field) {
                    u.order = l.order, e = !0;
                    break
                } e || d.push(l)
        }
        return {
            superHeaderRendering: r,
            isVGrouping: o,
            groupSpecs: s,
            colSpecs: i.concat(n),
            orderSpecs: d
        }
    }
    return iu.addStateEquality({
        spreadsheetColWidths: d
    }), Fe(".fc .fc-resource-timeline-divider{cursor:col-resize;width:3px}.fc .fc-resource-group{font-weight:inherit;text-align:inherit}.fc .fc-resource-timeline .fc-resource-group:not([rowspan]){background:var(--fc-neutral-bg-color)}.fc .fc-timeline-lane-frame{position:relative}.fc .fc-timeline-overlap-enabled .fc-timeline-lane-frame .fc-timeline-events{box-sizing:content-box;padding-bottom:10px}.fc-timeline-body-expandrows td.fc-timeline-lane{position:relative}.fc-timeline-body-expandrows .fc-timeline-lane-frame{position:static}.fc-datagrid-cell-frame-liquid{height:100%}.fc-liquid-hack .fc-datagrid-cell-frame-liquid{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc .fc-datagrid-header .fc-datagrid-cell-frame{align-items:center;display:flex;justify-content:flex-start;position:relative}.fc .fc-datagrid-cell-resizer{bottom:0;cursor:col-resize;position:absolute;top:0;width:5px;z-index:1}.fc .fc-datagrid-cell-cushion{overflow:hidden;padding:8px;white-space:nowrap}.fc .fc-datagrid-expander{cursor:pointer;opacity:.65}.fc .fc-datagrid-expander .fc-icon{display:inline-block;width:1em}.fc .fc-datagrid-expander-placeholder{cursor:auto}.fc .fc-resource-timeline-flat .fc-datagrid-expander-placeholder{display:none}.fc-direction-ltr .fc-datagrid-cell-resizer{right:-3px}.fc-direction-rtl .fc-datagrid-cell-resizer{left:-3px}.fc-direction-ltr .fc-datagrid-expander{margin-right:3px}.fc-direction-rtl .fc-datagrid-expander{margin-left:3px}"), Zl = C({
        name: "@fullcalendar/resource-timeline",
        premiumReleaseDate: "2025-06-30",
        deps: [Zl, _d, Xc],
        initialView: "resourceTimelineDay",
        views: {
            resourceTimeline: {
                type: "timeline",
                component: iu,
                needsResourceData: !0,
                resourceAreaWidth: "30%",
                resourcesInitiallyExpanded: !0,
                eventResizableFromStart: !0
            },
            resourceTimelineDay: {
                type: "resourceTimeline",
                duration: {
                    days: 1
                }
            },
            resourceTimelineWeek: {
                type: "resourceTimeline",
                duration: {
                    weeks: 1
                }
            },
            resourceTimelineMonth: {
                type: "resourceTimeline",
                duration: {
                    months: 1
                }
            },
            resourceTimelineYear: {
                type: "resourceTimeline",
                duration: {
                    years: 1
                }
            }
        }
    }), _o.push(ya, ba, Il, zl, Ql, fc, Sc, Xc, _d, Od, Pd, Zl), e.Calendar = class extends vi {
        constructor(e, t = {}) {
            var r;
            super(), this.isRendering = !1, this.isRendered = !1, this.currentClassNames = [], this.customContentRenderId = 0, this.handleAction = e => {
                switch (e.type) {
                    case "SET_EVENT_DRAG":
                    case "SET_EVENT_RESIZE":
                        this.renderRunner.tryDrain()
                }
            }, this.handleData = e => {
                this.currentData = e, this.renderRunner.request(e.calendarOptions.rerenderDelay)
            }, this.handleRenderRequest = () => {
                if (this.isRendering) {
                    this.isRendered = !0;
                    let i = this.currentData;
                    Br(() => {
                        le(b(fi, {
                            options: i.calendarOptions,
                            theme: i.theme,
                            emitter: i.emitter
                        }, (e, t, r, n) => (this.setClassNames(e), this.setHeight(t), b(Qr.Provider, {
                            value: this.customContentRenderId
                        }, b(Jo, Object.assign({
                            isHeightAuto: r,
                            forPrint: n
                        }, i))))), this.el)
                    })
                } else this.isRendered && (this.isRendered = !1, le(null, this.el), this.setClassNames([]), this.setHeight(""))
            }, (r = e).isConnected && r.getRootNode && Ve(r.getRootNode()), this.el = e, this.renderRunner = new Qe(this.handleRenderRequest), new No({
                optionOverrides: t,
                calendarApi: this,
                onAction: this.handleAction,
                onData: this.handleData
            })
        }
        render() {
            var e = this.isRendering;
            e ? this.customContentRenderId += 1 : this.isRendering = !0, this.renderRunner.request(), e && this.updateSize()
        }
        destroy() {
            this.isRendering && (this.isRendering = !1, this.renderRunner.request())
        }
        updateSize() {
            Br(() => {
                super.updateSize()
            })
        }
        batchRendering(e) {
            this.renderRunner.pause("batchRendering"), e(), this.renderRunner.resume("batchRendering")
        }
        pauseRendering() {
            this.renderRunner.pause("pauseRendering")
        }
        resumeRendering() {
            this.renderRunner.resume("pauseRendering", !0)
        }
        resetOptions(e, t) {
            this.currentDataManager.resetOptions(e, t)
        }
        setClassNames(e) {
            if (!d(e, this.currentClassNames)) {
                var t, r, n = this.el.classList;
                for (t of this.currentClassNames) n.remove(t);
                for (r of e) n.add(r);
                this.currentClassNames = e
            }
        }
        setHeight(e) {
            tt(this.el, "height", e)
        }
    }, e.Draggable = class {
        constructor(e, t = {}) {
            this.handlePointerDown = e => {
                var t = this.dragging,
                    {
                        minDistance: r,
                        longPressDelay: n
                    } = this.settings;
                t.minDistance = null != r ? r : e.isTouch ? 0 : mr.eventDragMinDistance, t.delay = e.isTouch ? null != n ? n : mr.longPressDelay : 0
            }, this.handleDragStart = e => {
                e.isTouch && this.dragging.delay && e.subjectEl.classList.contains("fc-event") && this.dragging.mirror.getMirrorEl().classList.add("fc-event-selected")
            }, this.settings = t;
            e = this.dragging = new ha(e);
            e.touchScrollAllowed = !1, null != t.itemSelector && (e.pointer.selector = t.itemSelector), null != t.appendTo && (e.mirror.parentNode = t.appendTo), e.emitter.on("pointerdown", this.handlePointerDown), e.emitter.on("dragstart", this.handleDragStart), new Sa(e, t.eventData)
        }
        destroy() {
            this.dragging.destroy()
        }
    }, e.Internal = io, e.JsonRequestError = ci, e.ThirdPartyDraggable = class {
        constructor(e, t) {
            let r = document;
            t = e === document || e instanceof Element ? (r = e, t || {}) : e || {};
            e = this.dragging = new Ea(r);
            "string" == typeof t.itemSelector ? e.pointer.selector = t.itemSelector : r === document && (e.pointer.selector = "[data-event]"), "string" == typeof t.mirrorSelector && (e.mirrorSelector = t.mirrorSelector), new Sa(e, t.eventData).hitDragging.disablePointCheck = !0
        }
        destroy() {
            this.dragging.destroy()
        }
    }, e.createPlugin = C, e.formatDate = function(e, t = {}) {
        var r = ea(t),
            t = I(t),
            e = r.createMarkerMeta(e);
        return e ? r.format(e.marker, t, {
            forcedTzo: e.forcedTzo
        }) : ""
    }, e.formatRange = function(e, t, r) {
        var n = ea("object" == typeof r && r ? r : {}),
            i = I(r),
            e = n.createMarkerMeta(e),
            t = n.createMarkerMeta(t);
        return e && t ? n.formatRange(e.marker, t.marker, i, {
            forcedStartTzo: e.forcedTzo,
            forcedEndTzo: t.forcedTzo,
            isEndExclusive: r.isEndExclusive,
            defaultSeparator: mr.defaultRangeSeparator
        }) : ""
    }, e.globalLocales = so, e.globalPlugins = _o, e.sliceEvents = function(e, t) {
        return qn(e.eventStore, e.eventUiBases, e.dateProfile.activeRange, t ? e.nextDayThreshold : null).fg
    }, e.version = "6.1.18", Object.defineProperty(e, "__esModule", {
        value: !0
    }), e
})({});